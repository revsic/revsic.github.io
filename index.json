[{"categories":["Bayesian"],"contents":" Hyunjik kim et al., 2019, arXiv Keyword: Bayesian, Process Problem: Underfitting of Neural Process Solution: NP + Self-Attention, Cross-Attention Benefits: Improvement of prediction accuracy, training speed, model capability. Contribution: Solving underfitting on NP Weakness or Future work: Decoder + Self-Attention  Neural Process and Gaussian Process\nNeural Process는 함수 분포를 모델링하기 위한 효과적인 메소드를 소개했다. linear time에 작동하며, 한번 학습되면 임의의 context pair와 query에 대해 target 분포를 예측할 수 있다. 그럼에도 NP와 GP를 직접 비교하기 어려운 이유는 NP는 stochastic process의 여러 realization (process에서 샘플링한 함수 표본) 에 대해서 학습하지만, GP는 하나의 realization에서 sample 된 observation에 대해 학습하기 때문이다.\nNP는 Scalability, Flexibility, Permutation Invariance라는 점에서 여러 장점이 있지만, consistency 문제를 가지고 있다. 이는 context로부터 target을 추론한 후, 다시 context에 덧붙여 target을 추가 추론했을 때와 온전한 context로부터 전체 target을 추론했을 때 분포차가 발생할 수 있음을 의미한다. 그러므로 NP를 그 자체로 consistent 하다고 보기보다는 consistent stochastic process의 근사라고 보는 것이 맞다.\nNP의 또 하나의 약점은 context set에 underfit한다는 것이다. 실제로 1D Curve Fitting 문제를 살펴보면, context point가 존재하는 지점에서도 과한 분산과 부적절한 평균점을 보인다. 본문에서는 이 이유를 NP가 context set을 고정된 크기의 latent로 변환시키는 과정에 permutation invariant function으로 mean-aggregation을 썼는데, 이 과정이 bottleneck으로 작용했기 때문이라고 판단하였다. 이는 모든 컨텍스트에 동일한 가중치를 주었기에, 디코더가 target을 예측할 때 context point로부터 적절한 관련 정보를 제공받지 못하고 있을 것으로 생각한 것이다.\n이러한 점을 해결하기 위해서 GP의 kernel function을 차용하였다. kernel은 입력값의 두 지점에 대해서 유사도를 측정하는 도구로 이용되는데, NP에는 이러한 메커니즘이 존재하지 않는 것이다. 그래서 제안하고자 하는 게 Attentive Neural Process (ANPs)이고, 이는 NP에 differentiable attention을 추가하여 context point에 대한 underfit을 줄인 모델이다.\nAttentive Neural Process\n먼저 입력과 출력 $x_i \\in \\mathbb R^{d_x}, \\ y_i \\in \\mathbb R^{d_y}$, 그리고 observed context $(x_C, y_C) := (x_i, y_i)_ {i \\in C}$ 와 targets $(x_T, y_T) := (x_i, y_i)_{i \\in T}$를 가정한다. context representation aggregator r에 대해 $r_C := r(x_C, y_C) \\in \\mathbb R^d$로 두고, latent encoder s에 대해 $s_C := s(x_C, y_C)$로 두면 NP는 다음을 모델링하는 것과 같다.\n$$p(y_T | x_T, x_C, y_C) := \\int p(y_T | x_T, r_C, z)q(z | s_C)dz$$\n여기서 NP가 가정하는 process F의 randomness는 global latent z에서 오기 때문에 likelihood를 최대화하는 과정은 z의 샘플링을 통해 여러 개로 realization 된 하나의 process를 학습하는 것과 같다.\nz_context = self.z_encoder(context, key=cx, query=cx)\rz_prob = self.latent_prob(z_context)\rlatent = z_prob.sample()\rself_attend = self.encoder(context, key=cx, query=cx)\rANP는 여기에 두 가지 attention을 덧붙인다. 첫 번째는 self-attention으로 context 사이에서 정보를 공유하고 더 나은 intermediate representation을 만들기 위한 장치이다.\ncross_attend = self.cross_encoder(self_attend, key=cx, query=query)\rrep = self.decoder(cross_attend, query, latent)\rdist, mu, sigma = self.normal_dist(rep)\rcontext에 self-attention을 취하면 context 개수만큼의 intermediate representation(IR)이 생기고, 이는 target과 context의 유사도를 비교하는 cross attention을 통과하여 query-specific representation $r_* := r^*(x_C, y_C, x_*)$을 만든다. 이는 모델이 실제로 어떤 컨텍스트 포인트를 조명할지 명시하기 때문에 target prediction에 도움을 줄 수 있다.\nlatent encoder의 경우에는 self-attention 이후 cross-attention 대신에 mean-aggregation을 선택했는데, 본문에서는 이를 global-latent로써 보존하고 싶었다고 한다. latent path에 cross-attention이 들어오면, latent에 locality가 발생하기 때문이다.\n$$\\log p(y_T | x_T, x_C, y_C) \\ge \\mathbb E_{q(z | s_T)} \\left[ \\log p(y_T | x_T, r_C, z) \\right] - D_{KL}(q(z | s_T) || q(z | s_C))$$\ntraining loss는 ELBO를 동일이 가져간다.\n이렇게 하면 computational complexity가 O(n(n + m))이 되는데, 이는 attention 과정에서 모든 컨텍스트를 탐방하기 때문이다. 하지만 dot-product attention 같은 matrix-multiplication 기반의 attention 알고리즘을 이용하면 대부분이 parallel 하게 동작할 수 있으므로 실제로는 training time이 NP와 비교할 만 하다고 한다.\nDiscussion\nANP는 attention mechanism을 통해 underfitting problem을 효과적으로 풀어냈다. 추측의 정확도가 높아졌고, 학습이 빨라졌으며, 모델링 할 수 있는 메소드의 범위도 늘었다. 저자는 ANP의 decoder에 self-attention을 붙여 expressiveness의 향상 정도를 확인하고 싶다고 한다. 하지만 이는 target prediction 사이에 상관성이 생기는 문제이니 ordering이나 grouping을 어떻게 해야 할지가 중요해질 것이라고 한다.\n","permalink":"https://revsic.github.io/blog/anp/","tags":["Machine Learning","Deep Learning","Bayesian","Stochastic Process","Neural Process","Attentive Neural Process"],"title":"Attentive Neural Process"},{"categories":["Bayesian"],"contents":" Marta Garnelo et al., 2018, arXiv Keyword: Bayesian, Process Problem: Data inefficiency, hard to train multiple datasets in one. Solution: Stochastic Process + Latent variable + NN Benefits: Concurrent training, global uncertainty, explicit latent variable. Contribution: CNP + global uncertainty, concurrent dataset, explicit latent Weakness or Future work: Pairwise correlation.  Function Approximation\n딥러닝에서는 데이터 간의 상관관계를 찾기 위해 함수를 근사하는 작업을 하는데, 주로 지도 학습에서는 parameterized function의 파라미터 셋을 gradient를 통해 업데이트하는 방식을 차용한다. 이러한 경우 대부분의 workload가 학습 중에 이뤄지며, 추론 과정은 단순 forward pass만으로 가능하다. 하지만 한번 학습된 이후로는 추론 결과의 업데이트가 힘들다는 점에서 메타 러닝 쪽도 관심이 많아지는 편이다.\n그 대체재로 Stochastic Process와 그 에인 Gaussian Process(GP)가 있는데, 이러한 모델들은 training phase를 필요로 하지 않고, test-time에 원하는 쿼리를 직접 렌더링 하게 된다. 하지만 렌더링 과정이 O(N^3)의 연산이 필요하기 때문에 대형 데이터셋을 상대로 적용하기 쉽지 않고, kernel과 같은 prior에 의해 함수 모형이 바뀌는 등 여러 문제점도 존재한다.\n이에 제안하고자 하는 게 Neural Process이다. 함수에 대한 분포를 가정하고, observation을 통해 query와 prediction에 대한 uncertainty를 추정한다. GP와 달리 O(n + m)의 단순 forward pass만으로 추정을 진행할 수 있다는 점에서 장점을 지닌다.\nNeural Process\n먼저 random function $F: \\mathcal X \\to \\mathcal Y$와 finite seq $x_{1:n}=(x_1, \u0026hellip;, x_n)$ with $x_i \\in \\mathcal X$, function values $Y_{1:n} := (F(x_1), \u0026hellip;, F(x_n))$를 가정한다. 이 collection의 joint dist $\\rho_{x_{1:n}}$이 존재할 것이고, GP 라면 multivariate gaussian일 것이다.\n이 joint dist는 exchangeability와 consistentcy라는 조건에서 Kolmogorov Extension Theorem에 의해 stochastic process로 정의될 수 있다. 이 때 exchangeability는 permutation invariance를 의미하고, consistentcy는 marginlize한 범위 외의 sequence에 대해 marginalize했을 때 원본 시퀸스와 동일함을 의미한다.\nStochastic process F와 시퀸스 $x_{1:n}$, 그의 joint dist $\\rho_{x_{1:n}}$에 대해 instantiation of stochastic process f는 다음과 같다\n$$\\rho_{x_{1:n}} = \\int p(f)p(y_{1:n}|f, x_{1:n})df$$\nobservation noise를 고려하여 $Y_i \\sim \\mathcal N(f(x_i), \\sigma^2)$라 가정하면 proability p는 다음과 같다\n$$p(y_{1:n}|f, x_{1:n}) = \\prod^{n}_{i=1} \\mathcal N(y_i | f(x_i), \\sigma^2)$$\n이 때 joint dist $\\lbrace\\rho_{x_{1:n}}\\rbrace$의 exchangeability와 consistentcy에 의해 stochastic process F의 존재성이 증명된다. 여기서 NP가 하고 싶은 것은 high-dimensional random vector z로 F를 parameterize하고, fixed function g에 대해 F(x) = g(x, z)를 NN으로 학습하고 싶은 것이다.\n$$p(z, y_{1:n}|x_{1:n}) = p(z)\\prod^{n}_{i=1} \\mathcal N(y_i|g(x_i, z), \\sigma^2)$$\n이 때 random function과 distribution을 학습하기 위해서는 여러 데이터셋을 동시에 학습해야 한다. 여러 input seq $x_{1:n}$와 output seq $y_{1:n}$를 학습시켜 데이터 간의 variability를 학습할 수 있게 한다.\ng를 non-linear NN으로 두기 때문에 학습에는 variational inference를 이용한다. latent z와 prior p(z)는 standard multivariate gaussian으로 두고, variational posterior $q(z|x_{1:n}, y_{1:n})$를 가정한다.\n$$\\log p(y_{1:n}|x_{1:n}) \\ge \\mathbb E_{q(z|x_{1:n}, y_{1:n})}\\left[\\sum^{n}_{i=1}\\log p(y_i|z, x_i) + \\log \\frac{p(z)}{q(z|x_{1:n}, y_{1:n})}\\right]$$\n이 때 test time에 더욱 well-behave model을 만들기 위해 context-set과 target-set을 나누고, true posterior $p(z|x_{1:n}, y_{1:n})$ 대신 variational posterior로 approximate한다.\n$$\\log p(y_{1:n}|x_{1:n}) \\ge \\mathbb E_{q(z|x_{1:n}, y_{1:n})}\\left[\\sum^{n}_{i=m+1}\\log p(y_i|z, x_i) + \\log \\frac{q(z|x_{1:m}, y_{1:m})}{q(z|x_{1:n}, y_{1:n})}\\right]$$\n이렇게 되면 z가 process F를 capture하는 역할을 하고, 이것이 global uncertainty를 capture 했다고도 볼 수 있다.\n실제 구현체에서는 encoder h가 pair $(x, y)_i$에 대해 repr $r_i = h((x, y)_i)$로 구성하고, exchangeable aggregator $r = a(r_i) = \\frac{1}{n} \\sum^n _{i=1}r_i$를 통해 latent $z \\sim \\mathcal N(\\mu(r), I\\sigma(r))$를 표현한다. 마지막으로 decoder g와 sampled latent z에 대해 $y_T = g(z, x_T)$를 통해 output을 결정하게 된다.\nz_context = self.z_encoder(context) z_dist = self.z_prob(z_context) latent = z_dist.sample() rep = self.decoder(context, query, latent) dist = self.normal_dist(rep) log_prob = dist.log_prob(target) log_prob = tf.reduce_sum(log_prob) prior = self.z_prob(self.z_encoder(context)) posterior = self.z_prob(self.z_encoder([query, target])) kl = tfp.distributions.kl_divergence(prior, posterior) kl = tf.reduce_sum(kl) elbo = -log_prob + kl Conditional Neural Process, Marta Garnelo et al., 2018\n동일 저자는 같은 해에 CNP라는 논문을 냈는데, 차이점은 NP는 latent z를 통해 process F를 캡처하고, global uncertainty를 측정하는데, CNP는 그러한 과정 없이 deterministic 하게 context와 query에 대한 target을 내놓는다. NP는 latent를 명시적으로 설정하였기 때문에, concurrent 한 training process에서도 명확히 latent를 포착하는 것을 볼 수 있다.\nDiscussion\nNP는 역시 stochastic process와 NN을 합친 모델이다. 함수에 대한 분포를 정의하고, context conditioned prediction을 생성한다. regression task에 대해서 실험을 주로 했는데, future work로 high dimensional data에 관한 연구를 남겨두겠다 한다.\n","permalink":"https://revsic.github.io/blog/np/","tags":["Machine Learning","Deep Learning","Bayesian","Stochastic Process","Neural Process"],"title":"Neural Process"},{"categories":["Bayesian"],"contents":" Marta Garnelo et al., 2018, arXiv Keyword: Bayesian, Process Problem: Weakness of knowledge sharing and data inefficiency of classical supervised learning Solution: Stochastic Process + NN Benefits: Data efficient, prior sharing Contribution: Encapsulation of parameterized NN function family. Weakness or Future work: Global uncertainty, pairwise correlation.  Function Approximation\n우리는 데이터의 경향성을 파악해 추론을 얻어내기 위해 흔히 데이터셋 $\\lbrace(x_i, y_i)\\rbrace^{n-1}_{i=0}$과 함수 $f: X \\to Y$를 가정한다. 일반적인 지도학습에서는 $f$를 parameterized model로 가정하고, computation을 고정, parameter를 학습하는 방식을 취한다. 그 이후에는 deterministic하게 입력에 대해 출력이 결정된다. 이러한 방식은 prior의 적용이 한정적이고, 그에 따라 learning 사이의 정보 공유가 어려워 매번 대량의 데이터셋에 대한 새로운 학습이 요구되는 등 여러 한계를 보이기도 한다.\nStochastic process는 함수라는 카테고리를 하나의 확률 분포로 가정한다. 함수에 대한 사전 지식은 분포상의 가정으로 표현되고, 학습은 관측된 값들에 대한 조건부 확률과 사후 분포로써 표현된다.\n대표적인 예로 gaussian process는 함수의 smoothness prior를 kernel function으로 나타내었고, 이는 값들 사이의 유사도로 나타나게 된다. 하지만 이러한 메소드들은 prior에 따라서 computationally intractable하기도 하고, $O(N^3)$에 달하는 연산량에 현대에는 많이 쓰이지 않고 있다.\n이러한 문제를 풀기 위해 model family를 제안하고, 이것이 Conditional Neural Process 이다.\nStochastic Process\n먼저 observation $O = \\lbrace(x_i, y_i)\\rbrace \\subset X \\times Y$ 과 target $T=\\lbrace x_i\\rbrace^{n+m-1}_{i=n}$ 를 가정하자. 이 때 $f: X \\to Y$로의 함수와 이 함수의 분포 P가 존재한다면 $f \\sim P$ 이고, 조건부 분포 $P(f(T)|O, T)$로 표현된다.\nGP에서는 P를 Gaussian으로 가정하고, Covariance Matrix 대신 두 지점 사이의 유사도를 측정하는 kernel 함수를 도입한다. 이러한 모델은 data efficient 하지만, prior나 kernel 함수의 설정이 어렵고, 추론 과정이 $O((n+m)^3)$로 computationally expensive 하다.\nConditional Neural Process (CNPs)\nCNP는 함수를 observation에 대한 조건부 분포로 가정한다. CNP는 observation을 고정된 크기의 embedding vector로 표현하고, 이를 토대로 새로운 query에 대한 추론을 만든다. 이 모든 것이 NN을 통한 single forward pass에 이뤄지기 때문에 관측수 n과 쿼리수 m에 대해 O(n + m)의 복잡도만을 요구로 한다.\nobservation O가 주어질 때 CNP는 $Q_\\theta$ 의 conditional process를 가정한다. 기존의 stochastic process처럼 O와 T의 순서에 대해 추론이 변하지 않는 permutation invariance를 보장한다. 또한 factorization $Q_\\theta(f(T)|O, T)=\\Pi_{x \\in T}Q_\\theta(f(x)|O, x)$을 가정한다.\nCNP의 구조는 다음과 같다.\n$r_i = h_\\theta(x_i, y_i) \\quad \\forall (x_i, y_i) \\in O$\n$r = \\oplus^n_i r_i$\n$\\phi_i = g_\\theta(x_i, r) \\quad \\forall x_i \\in T$\n이 때 $h_\\theta: X \\times Y \\to \\mathbb R^d$ 이고, $g_\\theta: X \\times \\mathbb R^d \\to \\mathbb R^e$ 이다. $\\oplus$는 observation embedding을 합치는 operation으로 본문에서는 permutation invariance를 지키기 위해 commutative 하다는 가정을 두었다.\n그 결과 process는 $Q_\\theta(f(x_i) | O, x_i) = Q(f(x_i) | \\phi_i)$ 로 표현되며, 이 과정이 NN forward pass만으로 이뤄지기 때문에 O(n + m)의 복잡도를 가진다.\nregression 에서는 $\\phi_i = (\\mu_i, \\sigma_i^2)$ 와 $\\mathcal N(\\mu_i, \\sigma_i^2)$ 로 두어 최종 $f(x_i)$가 가우시안을 따르게 하고, classification에서는 categorical distribution의 logits로 두었다.\n학습은 nll을 minimize 하는 방식으로 이뤄진다.\n$\\mathcal L(\\theta) = -\\mathbb E_{f \\sim P}\\left[\\mathbb E_N\\left[\\log Q_\\theta(\\lbrace y_i\\rbrace^{n-1}_{i=1}|O_N, \\lbrace x_i\\rbrace^{n-1}_{i=0})\\right]\\right]$\nDiscussion\n본문에서는 CNP가 training 데이터에서 prior을 적절히 학습하였고, 이를 통해 observation 간의 learning share이 가능하다고 이야기한다. 실험에서도 보였듯 data efficient하면서도 NN의 adaptivity를 충분히 잘 활용 하였고, meta-learning이나 few-shot learning 과의 상관성에 대해서도 이야기하였다. 지금은 POC 수준이지만, statistical context에서 function family를 적절히 encapsulate 한 것이 주요 contribution이지 않을까 싶다.\n추후 Neural Process나 Attentive Neural Process에서도 이야기하지만, CNP는 global uncertainty를 측정하는 수단이나, observation과 target 사이의 correlation을 측정하는 수단이 명시적으로 존재하지 않는다는 점도 고려해야 한다.\nImplementation\n Tensorflow v1: tf-neural-process  ","permalink":"https://revsic.github.io/blog/cnp/","tags":["Machine Learning","Deep Learning","Bayesian","Stochastic Process","Neural Process","Conditional Neural Process"],"title":"Conditional Neural Process"},{"categories":["Portfolio"],"contents":"Skills\n Languages: Python, C++ ML Framework: Tensorflow v1, PyTorch Windows Internal  Projects - Machine Learning\n  Behavior based Malware Detection Using Branch Data [GIT]\n: Classify malware from benign software using branch data via LSTM based on Tensorflow\n  AlphaZero Connect6 [GIT]\n: AlphaZero training framework for game Connect6 written in Rust with C++, Python interface.\n  Fine Dust Prediction [GIT]\n: Predict amount of fine dust for next 7 days via Convolutional LSTM based on Tensorflow.\n  numpy-rnn [GIT]\n: Numpy implementation of vanilla-rnn and lstm for solving binary addition and mnist classification problem.\n  np-gaussian-process [GIT]\n: Numpy implementation of Gaussian Process Regression.\n  Chess A.I. [GIT]\n: Java implementation of board game \u0026lsquo;Chess\u0026rsquo; and A.I. based on min-max and alpha-beta pruning.\n  Projects - Windows Internal\n  Anti-Attacher [GIT]\n: C++ implementation for defending windows debugger from attaching the target process.\n  Code-Injector [GIT]\n: C++ implementation of several code injection techniques like dll injection, queue user apc.\n  Branch Tracer [GIT]\n: C++ implementation of dll-based windows debugger for tracking branching instruction via vectored exception handler.\n  cpp-veh-dbi [GIT]\n: C++ implementation of vectored exception handler based simple dynamic binary instrumentation tools.\n  Projects\n  cpp-concurrency [GIT]\n: C++ implementation of golang-style concurrency supports, thread pool, channel, wait-group\n  cpp-obfuscator [GIT]\n: C++ implementation of compile time string and routine obfuscator.\n  RosettaStone [GIT]\n: C++ implementation of game \u0026lsquo;Hearthstone\u0026rsquo; as training environment and A.I. for future work.\n  Haskell Calculator [GIST]\n: Haskell implementation of calculator with generic binary operators.\n  ThreeByteVM [GIST]\n: C implementation of simple virtual machine that word size is 3 bytes.\n  TopMost [GIT]\n: C++ implementation of topmost library for windows and javascript support.\n  PacketInjector [GIT]\n: C++ implementation of simple packet detector and injector.\n  ELF Code Virtualization\n: ELF (Executable Linkable Format) Virtualized Code Protection\n  ML Paper implementation\n  tf-neural-process [GIT] [arxiv: NP, CNP, ANP]\n: Tensorflow implementation of neural process family.\n  tf-began [GIT] [arXiv]\n: BEGAN: Boundary Equilibrium Generative Adversarial Networks\n  tf-vanilla-gan [GIT] [arXiv]\n: Generative Adversarial Networks\n  tf-dcgan [GIT] [arXiv]\n: Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks\n  School Works\n  HYU-ITE2038 [GIT]\n: Database Systems and Applications in Hanyang University\n  HYU-CSE4006 [GIT]\n: Artificial Intelligence\n  Study\n  Modern C++ Challenge [GIT]\n: Challenge real-world problems with C++17 features\n  Stanford-CS166: Data Structure [GIT]\n: Data structure for undergraduate\n  Paper\n Behavior Based Malware Detection Using Branch Data at 2017 KIISE Korea Computer Science Conference  Presentation\n  Behavior based Malware Detection Using Branch Data at CodeGate 2017 Junior\n  Hearthstone++: Hearthstone simulator with reinforcement learning at Deep Learning Camp Jeju\n  Developing Environment for RL at Nexon Developers Conference 2019 as team RosettaStone\n  GP to NP: Gaussian process and Neural Process at A.I.U 1st Open AI Conference\n  Awards\n KISA, 2016 Software Contest,\nApplication Security Section 2nd Prize (Minister of Interior Award) 2016.09  Education\n  Department of Information and Communication Technology at Sunrin Internet High School\n(2015.03 ~ 2017.02)\n  Vulnerability Analysis Track at KITRI BoB\n(2016.05 ~ 2017.03)\n  Department of Computer Software Engineering at Hanyang University\n(2018.03 ~)\n  Works\n TTS Researcher at LionRocket\n(2019.09 ~)  ","permalink":"https://revsic.github.io/blog/worklist/","tags":["Portfolio"],"title":"Work list"}]