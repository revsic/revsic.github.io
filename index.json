[{"categories":["Writing"],"contents":"다사다난한 22년이었다. 즐거운만큼 힘든 일도 많았던듯 하다.\n이번 회고도 지난 1년간의 일을 월별로 정리해본다.\n1월 라로 - 매니징\n3월 코로나 확진\n4월 라로 - 베리미 프로젝트\n5월 여수 여행\n6월 라로 - 연구원 퇴사\n7월 라로 - 비전 연구\n얼굴 생성, 분류, 탐지, 인식 XAI GPU 연산 가속화 8월 고등학교, 대학교 연사\n9월 피티 시작\n10월 속초, 부산 여행\n라로 - 합성 기술 개발\n11월 오픈소스 기여\n12월 라로 - 음성 연구 복귀\n","permalink":"https://revsic.github.io/blog/on2022/","tags":["Writing","2022th"],"title":"On 2022"},{"categories":["Portfolio"],"contents":"Vision\nObject Detection/Recognition/Search, 2022.08. R\u0026amp;R: 1인 연구, 영상 합성 연구원\nObject Classification/Recommendation, 2022.07. R\u0026amp;R: 1인 연구, 영상 합성 연구원\nImage Generation, 2022.06. R\u0026amp;R: 1인 연구, 영상 합성 연구원\nLip-sync Video Synthesis, 2022.01. R\u0026amp;R: 영상 합성 프로젝트 매니저\nSpeech\nStable TTS, 2021.09. ~ 2021.12. : TTS 합성 실패 방지의 이론적 해결책에 관한 연구 R\u0026amp;R: 1인 연구, 음성 합성 연구원, 실험 실패 방지를 위한 연구 수행\n근래의 대부분 딥러닝 모델은 BatchNorm이나 InstanceNorm을 활용합니다. 이 중 BatchNorm은 학습 과정에서 추정한 이동 통계량을 기반으로 표준화를 진행합니다. 만약 학습에 활용한 데이터의 양이 충분하지 않아 통계치가 일반화되지 않았다면 miss-normalization 문제가 발생할 수 있습니다.\n저량의 데이터로 학습된 합성 모델에서 음성이 오합성 되는 이슈가 있었고, 분석 결과 BatchNorm의 miss-normalization에 의한 feature map의 variance exploding 현상을 원인으로 확인하였습니다.\n이를 해결하기 위해 RescaleNet[NeurIPS2020], LayerScale[arXiv:2103.17239], InstanceNorm 등으로 대체하는 연구를 진행하였습니다.\nLatent system, 2021.04. ~ 2021.08. : non-parallel 데이터와 unseen property의 일반화 가능성에 관한 연구 R\u0026amp;R: 1인 연구, 음성 합성 연구원, 다국어 모델 개발을 위한 연구 수행\n음성은 크게 발화자/언어/비언어 표현 3가지 관점에서 관찰할 수 있습니다. 이중 각 도메인의 클래스 간 모든 조합을 데이터로 구성하는 것을 parallel data, 일부 케이스가 비는 것을 non-parallel data라고 할 때, non-parallel 환경에서 문장 내 화자와 언어 정보를 분리하는 것은 natural하게 이뤄질 수 없습니다.\nex. [인물A/B, 영어/한글], parallel: 인물A/한글, 인물A/영어, 인물B/한글, 인물B/영어 natural: 케이스가 비는 경우, 별도의 장치 없이 화자와 언어를 조건화하는 것만으로는 unseen pair의 합성 품질을 보장할 수 없습니다. 따라서 non-parallel 환경에서 다화자-다국어 음성 합성 모델을 개발하는 경우, 특정 화자에서 관측되지 않은 언어 정보, unseen property에 대한 일반화가 이뤄질 수 있어야 합니다.\nLatent System 연구에서는 VAE와 GAN 등 방법론을 통해 Latent variable을 도입하고, 정보의 흐름을 보다 명확히 관리하는 것을 목표로 합니다. CLUB[arXiv:2006.12013]을 활용한 국소-전역부의 잠재 변수 분리, CycleGAN[arXiv:1703.10593]을 활용한 unseen-property 일반화 등을 가설로 연구를 수행하였습니다.\n다음은 당시 모델로 만들었던 프로토타입 영상입니다.\nyoutube:Lionrocket Semi-Autoregressive TTS, 2020.12. ~ 2021.04. : 합성 속도와 음질상 이점의 Trade-off에 관한 연구 R\u0026amp;R: 음성 합성 연구원, 베이스라인 개선 실험 수행\nTTS 모델은 Autoregressive(이하 AR) 모델과 Duration 기반의 Parallel(이하 PAR) 모델로 나뉩니다. AR 모델은 대체로 합성 속도가 음성의 길이에 비례하여 느려지지만 전반적인 음질 수준이 높고, PAR 모델은 상수 시간에 가까운 합성 속도를 가지지만 전반적으로 노이즈 수준이 높은 편입니다.\nSemi-Autoregressive TTS 연구는 이 둘을 보완하기 위한 연구입니다. AR TTS의 병목은 대부분은 AR 방식의 Alignment에서 오기에, Alignment는 Duration 기반의 PAR 모델을 따르고, 이후 Spectrogram 생성은 Autoregression하는 방식의 가설로 삼았습니다. 이는 DurIAN[arXiv:1909.01700], NAT[2010.04301]와 유사합니다.\n이후 추가 개선을 거쳐 실시간에 가까운 AR 모델을 개발하였지만, 음질의 중요성이 높아지며 추가 개선 및 배포가 보류된 프로젝트입니다.\nTTS Baseline, 2019.09. ~ 2020.10. : Text-to-Speech 음성 합성 모델 베이스라인 선정에 관한 연구 R\u0026amp;R: 음성 합성 연구원, 오픈소스 검토, 논문 구현, Ablation\nTTS 모델의 베이스라인 선정에 관한 연구입니다. Autoregressive 모델인 Tacotron[arXiv:1703.10135]부터 Duration 기반의 parallel 모델인 FastSpeech2[arXiv:2006.04558] 등을 폭넓게 검토하였습니다. 검토 과정에서 어떤 백본을 썼을 때 발음이나 음질 오류가 줄어드는지 검토하고, Duration을 어떤 모델을 통해 추정할지, Joint training이 가능한지를 연구하였습니다.\nAcoustic 모델이 완료된 후에는 Vocoder 군에서 Autoregressive 모델인 WaveNet[arXiv:1609.03499], WaveRNN[arXiv:1802.08435] LPCNet[arXiv:1810.11846]과 Parallel 모델인 MelGAN[arXiv:1910.16711] 등을 검토하였습니다. 이후 LPCNet에서 영감을 받아 Source-filter 기반의 방법론을 GAN 기반의 Parallel 모델에 적용하여 음질 개선이 이뤄질 수 있는지 연구하였습니다.\n연구된 베이스라인은 TTS 서비스인 On-air studio에서 활용하고 있습니다.\n다음은 그 외 사이드 프로젝트로 구현한 TTS 모델입니다.\rtorch-diffusion-wavegan [GIT], 2022.03. : Parallel waveform generation with DiffusionGAN, Xiao et al., 2021.\ntorch-tacotron [GIT], 2022.02. : PyTorch implementation of Tacotron, Wang et al., 2017.\ntf-mlptts [GIT], 2021.09. : Tensorflow implementation of MLP-Mixer based TTS.\njax-variational-diffwave [GIT], [arXiv:2107.00630], 2021.09. : Variational Diffusion Models\ntf-glow-tts [GIT] [arXiv:2005.11129], 2021.07. : Glow-TTS: A Generative Flow for Text-to-Speech via Monotonic Alignment Search\ntf-diffwave [GIT] [arXiv:2009.09761], 2020.10. : DiffWave: A Versatile Diffusion Model for Audio Synthesis, Zhifeng Kong et al., 2020.\nEngineering\nface_provider [GIT:lionrocket-inc/private], 2022.06 : All-in-one Face generation API 얼굴 인식, 검색, 합성, 분류, 추천 목적 통합 서비스 지원 프레임워크 Skills: Python, PyTorch, dlib, opencv, FAISS R\u0026amp;R: 1인 개발\n통합 얼굴 이미지 지원 프레임워크입니다. 이미지 내 얼굴 탐지를 시작으로 정렬, 인식, 분류, 벡터 데이터베이스에서의 검색과 추천을 지원합니다.\n얼굴 탐지와 인식 과정에는 입력 이미지의 회전량에 따라 인식 성능이 떨어지는 문제가 있었고, 이를 보정하기 위해 두상의 회전량을 추정하여 이미지를 정면으로 정렬하거나, 인식이 불가능한 이미지를 사전에 고지할 수 있게 구성하였습니다.\n이후 검색과 분류, 추천 과정이 실시간으로 이뤄져야 한다는 기획팀의 요청이 있었고, 벡터 검색 과정은 MetaAI의 벡터 검색 시스템 FAISS를 활용하여 최적화를 진행하였습니다. 얼굴형에 관한 초기 분류 모델은 dlib의 Facial Landmark를 기반으로 작동하였으나, dlib은 실시간 구성이 어렵다는 문제가 있었고, 추후 Mediapipe 교체를 고려하고 있습니다.\nCULICULI [GIT:lionrocket-inc/private], 2020.07.10 : CUDA Lib for LionRocket C++ CUDA Native를 활용하여 딥러닝 추론 속도를 10배 가량 가속화한 프레임워크 Skills: C++, CUDA, Python, PyBind R\u0026amp;R: 1인 개발\n음성 합성 파이프라인의 추론 가속화를 위해 C++ CUDA Native를 활용하여 10배가량 합성 시간을 단축시킨 프로젝트입니다. C++과 CUDA를 통해 기본적인 Tensor 객체와 BLAS(Basic Linear Algebra Subroutines)를 구성하고, 합성 속도를 최적화한 후, PyBind를 통해 python 인터페이스를 제공하였습니다.\n당시 TTS 모델에는 음성의 길이에 합성 시간이 비례하는 문제가 있었고, 단위 시간을 줄여 거의 실시간에 가까운 합성 속도를 구성할 수 있어야 했습니다. 이를 위해 C++로 BLOB-Shape Tuple 형태의 Tensor 객체를 구축하고, 템플릿 프로그래밍을 통해 이를 CUDA Native에서도 활용할 수 있게 두었습니다.\nBLAS 구현과 POC 이후 병목이 메모리 할당에 있음을 확인하여, 메모리 풀과 CUDA API를 활용하지 않는 자체적인 메모리 할당 방식을 구성, 대략 5~7배의 속도 향상을 확인할 수 있었습니다.\n이렇게 만들어진 프레임워크를 팀에서 활용하고자 했고, LR_TTS에서 학습된 체크포인트를 파이썬 인터페이스로 실행 가능하도록 PyBind를 활용하였습니다.\nLR_TTS [GIT:lionrocket-inc/private], 2019.09 : PyTorch implementation of TTS base modules 음성 데이터 전처리, 모델 구현, 학습, 데모, 패키징, 배포까지의 파이프라인을 구성한 프레임워크 Skills: Python, PyTorch, Librosa, Streamlit, Tensorboard R\u0026amp;R: 기획, 개발, 배포, 총책임\n음성 합성팀의 통합 연구 환경을 위한 플랫폼 개발 프로젝트입니다. 당시 PyTorch에는 Keras나 Lightning과 같이 단순화된 프레임워크가 부재했기에 데이터 생성부터 연구, 개발, 학습, 패키징, 평가, 배포, 데모 등 일련의 과정을 프로세스화 하고 코드 재사용성을 극대화하여 적은 리소스로 연구자가 부담없이 배포가 가능하도록 구성했습니다.\n자사 내의 데이터 전처리 구조를 단순화하고, 모든 학습이 고정된 프로토콜 내에서 가능하도록 모델 구조와 콜백 함수를 추상화하여 연구 프로세스를 정리했습니다. 또한 패키징과 배포의 단순화를 위해 모델 구조와 하이퍼파라미터를 분리, 각각을 고정된 프로토콜에 따라 저장, 로딩하는 모든 과정이 자동화될 수 있도록 구성했습니다.\n개발 중 UnitTest와 CI를 도입해보았지만, 딥러닝 모델의 테스트 방법론이 일반적인 소프트웨어 테스트 방법론과는 상이한 부분이 존재했고, 끝내 테스트가 관리되지 않아 현재는 테스트를 제거한 상태입니다.\nCI의 경우에는 이후 PR 생성에 따라 자동으로 LR_TTS의 버전 정보를 생성하고, on-premise framework에 모델을 자동으로 배포할 수 있도록 구성하였습니다.\nBehavior based Malware Detection Using Branch Data [GIT], 2019.08. : Classify malware from benign software using branch data via LSTM based on Tensorflow 브랜치 데이터를 통한 행위 기반 멀웨어 탐지 기법 연구 Skills: C++, Windows Internal, PE, Cuckoo Sandbox, Python, Tensorflow R\u0026amp;R: 1인 연구\nVEH를 기반으로 분기구문(branch instruction)을 추적하는 Branch Tacer를 구현한 후, DLL Injection 방식을 통해 보안 가상 환경(sandbox)에서 멀웨어와 일반 소프트웨어의 분기 정보(branch data)를 축적, 딥러닝 기반 탐지 모델을 개발하였습니다.\nSandbox 환경 내에서는 MSR을 사용할 수 없어 VEH를 통해 branch tracer를 직접 구현해야 했고, 분기문 탐색을 위해 디스어셈블러의 일부를 직접 구현하면서 기술적 어려움을 겪었습니다. 이는 후에 인텔 매뉴얼을 참고하며 tracer를 완성하였고, 이후 이를 발전시켜 VEH 기반의 DBI(Dynamic Binary Instrumentation)[GIT:cpp-veh-dbi] 도구를 구현할 수 있었습니다.\n딥러닝 모델은 LSTM 기반의 간단한 시퀸스 모델을 이용하였고, 결과 88% 정도의 정확도를 확인할 수 있었습니다.\n이는 당시 논문의 형태로 정리되어 정보과학회 2017년 한국컴퓨터종합학술대회 논문집[PAPER]에 고등학생 부문으로 기재되었습니다.\n","permalink":"https://revsic.github.io/blog/project/","tags":["Portfolio"],"title":"Project Overview"},{"categories":["Attention"],"contents":" Survey of Neural Text-to-Speech models and Attention Alignment Keyword: TTS, Attention, Alignment Introduction\n16년도 WaveNet[arXiv:1609.03499], 17년도 Tacotron[arXiv:1703.10135]을 기점으로 딥러닝 기반의 음성 합성 TTS 모델들이 현재까지 꾸준히 발전해 오고 있다. 19년도부터 21년도까지 음성 합성 연구원으로 재직하며 보고 느꼈던 TTS의 발전에 관해 정리해보고자 한다.\nTTS: Text-to-Speech\nTTS는 텍스트를 조건으로 발화 음성을 합성하는 생성 분야를 이야기할 수 있다.\n자연에 존재하는 발화 신호는 기계 신호로 양자화하는 과정에서 1초에 몇 개의 샘플을 획득할 것인지의 Sample Rate(이하 SR)와 샘플을 몇 가지 수로 나타낼 것인지의 Bit Rate로 2가지 변수를 가진다.\nTTS 합성 분야에서 SR은 과거 16kHz부터, 이후 22.05kHz와 24kHz, 현재 32kHz, 44.1kHz, 48kHz까지 꾸준히 증가해왔다. Nyquist 이론에 근거하면 SR의 절반이 획득할 수 있는 주파대역의 상한이므로, TTS는 과거 최대 8khz에서 24khz까지 점점 더 높은 주파대역을 복원할 수 있게 되었다.\nIntermediate representation\nTTS가 처음부터 높은 SR의 음성을 생성할 수 없었던 이유는 1.) 1초에 2만여개 프레임을 포함하는 sparse input으로부터 context를 추정할만큼 넓은 receptive field를 가진 아키텍처가 없었고 (WaveNet[arXiv:1609.03499] 이전) 2.) 음소의 발화 시간은 대략 10~50ms으로 1초에 20~50여개 정도이지만, 음성은 1초에 2만에서 4만여개 프레임으로 1k배 정도 길이 차 사이의 관계성을 학습시키기 어려웠으며 3.) 고주파대역으로 갈 수록 임의성이 짙어져 확률 모델 도입 없이 고주파 정보의 구현이 어려웠기 때문이다.\n이를 해결하기 위해 TTS 모델은 Spectral feature를 중간 매개로 두고, 텍스트에서 spectral feature을 합성하는 acoustic 모델과 spectral feature로부터 음성을 복원하는 vocoder 모델 2단계 구조를 구성하기 시작했다.\nSpectral feature로는 대체로 Short-time Fourier Transform(이하 STFT)으로 구해진 fourier feature의 magnitude 값(이하 power spectrogram)을 활용했다. 오픈소스 TTS 구현체에서는 주로 12.5ms 주기마다 50ms 정도의 음성 세그먼트를 발췌하여 주파 정보로 변환하였다. 이렇게 되면 spectral feature는 1초에 80개 정도의 프레임을 가지고, 텍스트에서 대략 2~4배, 음성까지 250~300배 정도로 구성된다.\nFourier feature를 활용할 수 있었던 이유는 1.) 음성의 발화 신호가 기본 주파수(F0)와 풍부한 배음(harmonics)로 구성되기에 fourier transform을 통해 각 주파대역별 세기를 나타내는 power spectrogram으로 표현하더라도 정보 유실이 크지 않았고 2.) Source-filter 이론에 근거하였을 때 발화 신호 중 발음 성분이 spectral magnitude의 형태(filter)에 상관관계를 가지기 때문에, 텍스트로부터 발음 정보를 만드는 문제로 치환한 것이다.\n그럼에도 발음 정보에 대응 가능한 quefrency 영역의 cepstral feature(ex. MFCC)를 사용하지 않은 이유는, 기본 주파수 등의 정보 손실이 커 음성 신호로 복원하는 보코더의 문제 난이도를 어렵게 했기 때문이다.\nLog-scale, Mel-filter bank\nFigure 1: Power spectrogram\n대체로 오픈소스 TTS 구현체에서는 STFT의 frequency bins를 1024개 혹은 2048개로 설정한다. 이때 TTS 모델이 합성해야 하는 프레임당 벡터의 길이는 spectral feature 중 허수 반전을 제외한 513개 혹은 1025개이다.\n인간의 청각 체계는 음의 세기와 높낮이에 모두 log-scale로 반응한다. 신호의 세기가 N배 커지더라도, 실제로는 logN 정도로 인식하는 것이다. 이를 반영하여 인간이 실제로 듣는 신호의 세기와 높낮이 대역을 강조하기 위해 TTS에서는 power spectrogram (linear spectrogram)을 곧장 활용하기보다는 주파대역의 인지적 선형화를 위해 filterbank를 취하고, 세기의 인지적 선형화를 위해 log를 취한다.\nfilterbank는 주로 2가지를 활용하는 듯하다. 가장 많이 쓰이는 Mel-scale filterbank와 LPCNet[git:xiph/LPCNet] 등에서 간간이 보이는 Bark-scale filterbank이다. 대체로 오픈소스 TTS 구현체에서는 0Hz ~ 8kHz의 영역을 나눈 STFT 기존 513개~1025개 frequency bins를 80개~100개로 축약하는 mel-scale filterbank를 활용하는 편이다.\nMel-scale filterbank를 활용하는 경우를 log-Mel scale spectrogram이라고 하여, 간략히 mel-spectrogram이라 일컫는다.\nFigure 2: log-Mel scale spectrogram\nVocoding\n보코더는 음성을 압축/복원하는 기술을 통칭한다. TTS에서는 algorithmic 하게 구해진 spectrogram(mel-scale)을 음성으로 복원하는 모델을 이야기한다.\n단순히 STFT만을 취했다면 발화 신호 특성상 iSTFT만으로도 충분한 음성을 복원해낼 수 있지만, mel-spectrogram 변환 과정에서 1.) 주파대역별 세기를 측정하기 위해 실-허수 신호를 실수 신호로 축약하는 Absolute 연산 2.) 500~1000여개 bins를 80~100개로 압축하는 filter bank 연산의 2가지 손실 압축을 거치기에 algorithmic한 복원에는 한계가 존재한다.\nTacotron[arXiv:1703.10135]에서는 power-spectrogram을 활용하여 filter bank 연산이 없었고, 허수부(phase) 복원에는 griffin-lim 알고리즘을 활용하였다.\n상용화하기 어려운 음질이었고, 부족한 주파대역과 허수(phase) 정보 복원을 위해 Tacotron2[arXiv:1712.05884]에서는 2016년 WaveNet[arXiv:1609.03499]을 별도의 경험적 보코더로 두어, mel-spectrogram에서 time-domain signal을 복원하도록 학습하여 활용하였다.\nBit-rate\n음성은 과거와 현재 크게 다르지 않게 16bit를 bitrate로 산정하여, 음성 신호를 대략 6만여개 실수로 양자화하였다.\nWaveNet을 경량화한 WaveRNN[arXiv:1802.08435]에서는 신호 복원 문제를 6만여개 클래스의 분류 문제로 바꾸고자 했는데, 현실적으로 6만개 클래스를 분류하는 것에는 네트워크 학습에 어려움이 있었다.\n이를 위해 시간축 신호 역시 청각 구조에 따른 인지적 선형화를 진행하며 16bit를 8bit로 2차 양자화하였다. 대체로 mu-law를 활용하였으며, 8bit 256개 클래스로 분류하는 보다 쉬운 문제로 치환하였다.\n하지만 mu-law 역시 손실 압축이기 때문에, 복원된 8bit 음성을 algorithmic 하게 16bit로 복원하는 과정에서 배경 노이즈가 섞이는 이슈가 있었다.\n이는 이후 GAN 기반 신호 복원 방법론인 MelGAN[arXiv:1910.06711] 등이 등장하며 bitrate 상관없이 [-1, 1]의 실수 범위 신호를 직접 복원하게 된다.\nNow-on\n근래에는 24khz, 32khz, 48khz의 SR과 16bitrate의 데이터셋을 주로 활용하고 있으며, 대체로 1024bins/12.5ms(or 256frame)/50ms(or 1024frame)의 STFT, 80~100bins log-Mel scale spectrogram을 활용하는 듯하다. [git:seungwonpark/melgan, git:jik876/hifi-gan] 아무래도 Tacotron2의 영향이지 않을까 싶다. [git:NVIDIA/tacotron2]\n이외로 preemphasis 필터를 거치거나, 기준 세기를 잡아 amplitude 영역의 주파정보를 decibel 단위로 변환하기도 하고, [-1, 1] 범위로 값을 scaling 하기도 한다. [git:keithito/tacotron]\nAcoustic Model - Sequence-to-Sequence\nAcoustic model은 텍스트에서 mel-spectrogram으로의 가변 길이 Sequence-to-Sequence 모델을 상정한다.\n주로 문장 단위로 음성을 전처리하는데, 입력으로 들어온 문장은 표기 문자인 자소를 그대로 쓰기도 하고, 소리 문자인 음소로 변환하여 활용하기도 한다. 이 과정을 grapheme-to-phoneme(이하 G2P)라 하며, [git:Kyubyong/g2p]의 카네기 멜론 대학 음소 사전(CMU-Dictionary)를 활용하거나 [git:bootphon/phonemizer]의 International Phonetic Alphabet(이하 IPA)을 활용하기도 한다.\nSequence-to-Sequence 모델은 기본적으로 Encoder-Alignment-Decoder 3개 모듈로 이뤄진다. 음소/자소 열은 Text Encoder에 들어가게 되고, Alignment를 통해 텍스트와 합성하고자 하는 spectrogram의 관계를 정립/정렬한다. 이후 정렬된 텍스트 인코딩은 Spectrogram Decoder에 의해 mel-spectrogram으로 합성된다.\nEncoder와 Decoder를 어떻게 구성할지를 TTS의 Network Backbone 관련 연구에서 다루고, 어떻게 텍스트와 spectrogram의 관계를 정의하고, Alignment 모듈을 학습할 것인지를 Attention Alignment 관련 연구에서 다룬다.\n텍스트와 spectrogram의 관계가 다른 Sequence-to-Sequence 태스크와 다른 점은 1.) 발화 특성상 음소가 동일한 문장이어도 사람마다, 녹음마다 발화의 길이가 달라질 수 있어 음소만으로는 발화 길이의 추정이 어려울 수 있다는 점과 2.) 텍스트와 발화 음성 모두 시간 축에 따라 정렬되기 때문에 둘의 관계성이 순증가(monotonic) 하는 특성을 띤다는 것이다.\nTTS에서는 이러한 특성을 활용하여 Alignment 모듈을 Joint training 하기도 하고, 외부에서 학습한 모듈을 활용해 Distillation 하기도 한다.\n이를 토대로 특성에 따라 TTS를 분류한다면 다음과 같이 나눌 수 있을 것 같다.\nDecoding: Autoregressive, Parallel Backbone: CNN, RNN, Transformer AR Alignment: Forced-Align, Content-based, Location-based PAR Alignment: Distillation, Joint-Distillation, End-to-End Autoregressive TTS\nTTS 모델은 일차적으로 spectrogram의 디코딩 방식에 따라 2가지로 나눌 수 있다. $x_t$를 t번째 spectrogram frame, $c$를 텍스트 입력이라 할 때, Autoregressive 모델은 t번째 프레임 생성에 이전까지 생성한 프레임을 참조하는 방식 $\\prod_{t=1}^T p(x_t; x_{\\cdot \u0026lt; t}, c)$, Non-autoregressive(or parallel) 모델은 이전 프레임의 참조 없이 텍스트로부터 spectrogram을 합성하는 방식이다 $p(x_{1:T}; c)$.\n전자의 경우 대체로 첫 번째 프레임부터 마지막 프레임까지 순차적으로 합성해야 하기에 합성 속도가 느리지만, 이전 프레임을 관찰할 수 있기 때문에 대체로 단절음이나 노이즈 수준이 적은 편이고, 후자는 GPU 가속을 충분히 받아 상수 시간 안에 합성이 가능하지만 상대적으로 단절음이나 노이즈가 발견되는 편이다.\nWaveNet: A Generative Model for Raw Audio, Oord et al., 2016. [arXiv:1609.03499] Category: Autoregressive, CNN, Forced-Align Problem: Inefficiency of increasing receptive field Contribution: Dilated convolution, exponential field size Future works: Reduce real-time factor(RTF \u0026gt; 1), remove handcrafted features\nFigure 3: Visualization of a stack of dilated causal convolutional layers. (Wavenet, 2016)\n기존까지의 TTS 시스템은 크게 두 가지로 나뉘었다. 1.) Unit-selection/Concatenative: 사전에 녹음된 음성을 규칙에 따라 이어 붙이는 방식 2.) Statistical Parametric TTS: HMM을 기반으로 보코더 파라미터를 추정, 합성하는 방식\n이러한 시스템들은 대체로 음소, 음소별 발화 길이, F0 등의 입력을 요구하였고, 그럼에도 기계가 발화하는 듯한 음성을 합성해 내는 특성을 가지고 있었다.\n기존까지 음성 신호를 직접 합성하지 않고 보코더 파라미터를 추정하였던 이유는 초당 2만여개 프레임을 감당할만한 receptive field의 현실적 확보가 어려웠기 때문이다. 예로 strided convolution을 활용한다면, receptive field의 크기는 네트워크의 깊이에 비례하고, 2만여개 프레임을 커버하기 위해 2만개의 레이어가 필요하다.\nWaveNet은 이를 Dilated convolution(or atrous convolution)을 통해 해결하였다. 인접 프레임을 커널과 합성곱 하는 것이 아닌, N개 프레임마다 1개 프레임을 선출하여 합성곱 하는 방식을 활용한다. 이때 N을 dilation이라고 하며, N을 지수에 따라 늘려가면 receptive field의 크기를 레이어 수의 지수에 비례하게 구성할 수 있다. 2만여개 프레임을 커버하기 위해 14개 레이어면 충분한 것이다. (jax/flax에서는 input의 dilation을 transposed convolution의 stride, kernel의 dilation을 dilated convolution의 dilation이라고 표현, ref:jax.lax.conv_general_dilated)\n이에 신호를 직접처리할 수 있게 되었고, WaveNet은 사전에 구한 음소별 발화 길이와 log-F0를 추가 입력으로 하여 음성 신호를 생성하는 TTS를 구현하였다.\nHMM 기반 TTS 혹은 Forced Aligner을 통해 구한 음소별 발화 길이를 기반으로 텍스트 토큰을 길이만큼 반복, 음성과 정렬 (ex.MFA: Montreal Forced Aligner) 반복/정렬된 음소는 conditional input으로 전달 이전까지 합성된 음성 프레임을 dilated convolution으로 encoding 하여 최종 다음 프레임을 합성 합성은 8bit mu-law에 따라 압축한 음성을 256개 클래스의 분류 문제로 치환 합성 과정 중에는 음소별 발화 길이를 텍스트로부터 추정하는 별도의 모듈을 학습하여 활용 MFA: Text-Speech align sample (ResearchGate, Zhiyan Gao)\nWaveNet은 16khz 음성을 대상으로 했기에 1초에 16k개 프레임을 생성해야 했으며, 프레임마다 dilated convolution을 구동해야 했기에 합성 속도가 실시간보다 느린 문제가 있었다. 그럼에도 음성은 기존 시스템보다 자연스러웠으며, 보코더 파라미터가 아닌 음성을 직접 모델링할 수 있었다는 기여를 가진다.\nTacotron: Towards End-to-End Speech Synthesis, Wang et al., 2017. [arXiv:1703.10135] Category: Autoregressive, CNN + RNN, Content-based alignment Problem: Large RTF of Wavenet, handcrafted features required Contribution: Bahdanau attention, Spectrogram synthesis Future works: Noisy output, instability of attention mechanism\nFigure 1: Model Architecture. (Tacotron, 2017)\n이후 17년도 구글은 Tacotron이라는 TTS 모델을 공개한다. 1.) Learnable 한 Attention mechanism을 도입하여 음소별 발화 길이가 필요하지 않고 2.) Spectrogram을 생성하도록 목표를 재설정하여, 3.) RNN 기반의 Decoding을 통한 효율화를 가능케 했다.\nLearnable Attention Mechanism 기존까지 TTS는 HMM 등을 활용하여 음소별 발화 구간을 추정하는 별도의 모델을 두고, 이를 통해 음소를 반복, 음성과 정렬하는 방식을 많이 사용하였다. 이 경우 구간 추정 모델과 TTS를 이중으로 학습해야 했기에, Tacotron에서는 Bahdanau et al., 2014.[arXiv:1409.0473]의 Joint training이 가능한 learnable alignment를 활용하였다.\n기계 번역(Neural Machine Translation, 이하 NMT) 분야 역시 가변 길이의 Seq2Seq 문제를 상정한다. NMT에서는 생성하려는 토큰과 입력의 관계를 명시하여 학습/추론 과정을 안정화하기 위해 \u0026ldquo;Alignment\u0026quot;라는 것을 도입하였다. 이는 다음 토큰을 생성하기 위해 입력으로 들어온 텍스트 토큰 중 어떤 것을 관찰할지를 결정하는 Bipartite 그래프의 간선들을 의미한다.\nTTS에서는 다음 프레임을 합성하기 위해 텍스트의 어떤 부분을 관찰할지 결정하는 map을 alignment라고 한다. 음소는 대략 20~50ms의 발화 구간을 가지고, spectrogram frame은 대략 10~20ms으로 구성되기 때문에 alignment는 음소 별로 1~3개 프레임을 순차적으로 할당하는 역할을 한다.\n이렇게 alignment를 명시하고 명확히 제약할수록 관계 해석에 대한 Encoder와 Decoder의 부하가 줄어 TTS의 학습이 가속화되는 이점이 있다.\nFigure 3: Attention alignments on a test phase. (Tacotron, 2017)\n이때 발화는 음소를 순서대로 읽는 방식으로 작동하기 때문에, NMT와 달리 TTS의 Alignment는 순증가(순차 할당) 하는 특성을 가진다.\n대체로 Alignment를 활용하는 Autoregressive TTS는 $x_{1:S}$를 S개 음소로 이뤄진 입력 문장, $y_{1:T}$를 T개 프레임으로 이뤄진 출력 spectrogram이라 할 때 다음과 같이 fomulation 된다.\n$$\\begin{align*} \u0026amp;s_{1:S} = \\mathrm{TextEncoder}(x_{1:S}) \\in \\mathbb R^{S\\times C} \\\\ \u0026amp;q_t = \\mathrm{SpecEncoder}(y_{1:t - 1}) \\in \\mathbb R^{C}\\\\ \u0026amp;a_{t, \\cdot} = \\mathrm{Attention}(Wq_t, Us_{1:S}) \\in [0, 1]^{S} \\\\ \u0026amp;h_t = \\sum_{i=1}^S a_{t, i}s_i \\\\ \u0026amp;y_t = \\mathrm{SpecDecoder}(q_t, h_t) \\end{align*}$$\n이렇게 텍스트 $x_s$와 spectrogram $y_t$의 관계성을 나타내는 map $a_{s, t}$을 attention alignment라 부르게 된다. $a_{s, t}$가 0이라면 s번째 음소와 t번째 프레임은 독립인 것이고, 1에 가까울수록 s번 음소에 의해 t번 프레임이 합성될 확률이 높아지는 것이다.\nTacotron에서는 Bahdanau의 alignment mechanism을 그대로 활용한다.\n$$\\begin{align*} \u0026amp;e_{t, \\cdot} = v^T\\mathrm{tanh}(Wq_t + Us_{1:S}) \\\\ \u0026amp;a_{t, \\cdot} = \\mathrm{softmax}(e_{t, \\cdot}) \\\\ \u0026amp; \\mathrm{where} \\ W, U \\in \\mathbb R^{C \\times H}, \\ v \\in \\mathbb R^H \\end{align*}$$\n이러한 alignment mechanism을 additive attention이라고도 하고, 입력 텍스트와 이전 프레임의 정보를 통해서만 alignment를 결정하기 때문에 content-based attention이라고 한다.\n별도의 constraint 없이도 정상적으로 학습된 Tacotron은 monotonic 한 alignment로 유도된다. 하지만 monotonic 한 align이 정상적으로 학습되지 않는 경우도 종종 있고(학습 불안정성), 이 경우 Autoregressive Decoding을 통해 음성을 정상 합성할 수 없다.\n또한 content-based attention이기 때문에 경우에 따라 문장 내에 동일한 음소가 2개 이상 있는 경우 alignment가 현 발화 시점 이전 혹은 이후의 텍스트에 attending 하기도 한다. 이 경우 반복/누락 등의 발음 오류를 만든다.\nRepeating issue, [discourse.mozilla:julian.weber]\nSpectrogram Retarget, RNN-decoding 기존의 WaveNet이 음성 신호를 직접 복원하고자 하였다면, Tacotron은 Spectrogram으로 합성 대상을 변경한다.\n앞서 이야기하였듯 spectrogram은 reasonable 한 선택이었다. 기존의 시스템은 높은 SR로 인해 RNN을 학습하는 것이 어려웠고, CUDA 등 GPU toolkit에 의해 well-optimizing 된 프로시져를 활용하지 못하는 아쉬움이 있었다.\nspectrogram은 초에 80여 프레임, 이마저도 한 번에 N개 프레임을 동시에 디코딩하는 reduction heuristic을 적용하면 80/N개 프레임으로 축약된다. Tacotron에서는 N=2를 가정하며, 초에 40개 프레임을 구성한다. 20~40개 음소로 구성되는 텍스트와도 관계성이 단순해져 Bahdanau attention의 부하도 줄일 수 있다.\n또한 초당 프레임 수가 줄어들었기에 Decoder을 RNN으로 구성할 수 있고, GPU toolkit의 최적화된 연산을 충분히 활용하여 실시간에 가깝게 합성할 수 있다.\n다만 기존 WaveNet과 달리 spectrogram을 활용할 경우 별도의 음성 복원 방법론이 필요했고, Tacotron에서는 linear spectrogram을 생성, griffin-lim 알고리즘을 통해 phase를 복원하는 방식을 채택하였다.\n대체로 속도는 빨라졌지만, griffin-lim을 통해 복원된 음성은 기계음이 섞인 음성을 만들어내는 이슈가 있었다.\nEnd of decode Autoregressive decoding에서 가장 중요한 것은 종료 시점이다. WaveNet에서는 발화 길이에 따른 forced alignment를 활용하여 decoding 전에 신호의 길이를 미리 알 수 있다. 하지만 Bahdanau attention을 쓰는 Tacotron에서는 align과 decoding이 동시에 이뤄지기 때문에 decoding 과정에서 음성의 길이나 종료 시점을 추정할 수 있어야 한다.\nTacotron 구현체에서는 종료 시점에 관해 몇 가지 휴리스틱을 활용하는데, 1.) 묵음에 해당하는 spectrogram이 일정 프레임 이상 합성되면 정지하거나 [git:r9y9/tacotron_pytorch] 2.) Alignment가 텍스트의 마지막 토큰에서 일정 프레임 이상 머무르면 멈추기도 하고, 3.) 음소당 3~5개 프레임을 합성한다는 배경지식을 토대로 음성의 길이를 \u0026ldquo;음소의 수 x 4\u0026rdquo; 정도로 설정하여 고정된 길이를 합성하기도 한다.\n그리고 이 3가지 방법론에는 모두 단점이 존재한다. 1.) 임계치를 잘못 설정하면 쉼표나 띄어쓰기의 묵음부에서 디코딩이 멈추기도 하고, 2.) 앞서 이야기한 alignment 반복 등의 이슈로 무한히 디코딩하는 현상이 발생하거나 3.) 음성 길이 추정에 실패해 합성 도중에 강제 종료되기도 한다.\n이후 논문들에서는 이러한 종료 시점에 관한 엔지니어링 코스트를 줄이기 위해 별도의 방법론을 도입하기도 한다.\nTacotron2: Natural TTS Synthesis by Conditioning WaveNet on Mel Spectrogram Predictions, Shen et al., 2017. [arXiv:1712.05884] Category: Autoregressive, CNN + RNN, Location-sensitive alignment Problem: Spectorgram inversion, Content-based attention Contribution: Location-sensitive attention, WaveNet vocoder Future works: Unconstrained monotonicity, stop token misprediction\nFigure 1: Block diagram of the Tacotron 2 system architecture. (Tacotron2, 2017)\nTacotron2는 Tacotron의 후속작으로 Neural TTS의 가장 기본적인 baseline을 제시한다.\nMel-spectrogram retarget, WaveNet Vocoder 기존의 Tacotron은 Linear spectrogram과 griffin-lim을 활용하였다. 하지만 앞서 이야기하였듯 linear spectrogram은 인지적 선형화가 이뤄지지 않은 feature이고, 강조될 필요 없는 고주파 대역까지의 복원을 목표로 해야 하기에 Decoder의 network capacity를 높여야 하는 등의 이슈가 있었다.\nTacotron2에서부터는 mel-spectrogram을 활용하여 기존 500bins spectral feature를 80bins까지 압축하였고, network capacity를 덜 고려한 단순한 아키텍처로도 음성 모델링이 가능케 했다.\n가장 큰 문제는 mel-spectrogram이 linear-spectrogram에 비해 압축률이 높은 feature라는 것이고, 이를 음성으로 복원하기 위해서는 별도의 경험적 보코더가 필요했다.\nTacotron2에서는 이를 위해 mel-spectrogram을 조건으로 time-domain의 음성 신호를 복원하는 WaveNet을 학습하여 보코더로 활용하였다.\nNeural TTS는 Tacotron2 이후 mel-spectrogram을 생성하는 acoustic 모델과 음성 신호를 복원하는 vocoder 모델 2개의 분야로 세분화되었다. NVIDIA에서는 Tacotron2의 구현체[git:NVIDIA/tacotron2]를 공개하였고, [git:seungwonpark/melgan] 등의 오픈소스 보코더가 NVIDIA 구현체와의 호환을 지원하면서 Tacotron2의 세팅은 학계의 pivot처럼 작동하였다.\nLocation-sensitive attention 기존의 Tacotron은 content-based additive attention을 상정하였다.\n$$a_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(Wq_t + Us_{1:S}))$$\n음성은 문자를 순차적으로 발화한 신호이기 때문에, TTS 혹은 ASR(Automatic Speech Recognition, 음성 인식) 분야에서는 Alignment가 시간 축에 따라 순증가 해야 한다는 사전 지식이 존재한다.\n하지만 $q_t$와 $s_{1:S}$로만 이뤄진 alignment mechanism은 연산에 순증가의 사전 지식이 반영되어 있지 않다.\n[arXiv:1506.07503]에서는 ASR에 이러한 순증가의 사전 지식을 적용하기 위해 다음과 같은 formulation을 제안한다.\n$$a_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(Wq_t + Us_{1:S} + F \\ast a_{t - 1, \\cdot}))$$\n$\\ast$는 convolution 연산으로, 이전의 alignment에 convolution을 취해 energy 연산에 더하는 방식이다.\n간단한 예로 F가 크기 3의 [1, 0, 0] 커널이어서 PyTorch 기준 F.conv1d(a[:, None], [[[1, 0, 0]]], padding=1)의 연산으로 구현된다면, 이는 F.pad(a, [1, -1])로 alignment의 modal이 다음 텍스트로 이동한 것과 동치가 된다.\n즉 과거 alignment를 convolution하는 것은 alignment의 이동 방식에 관한 prior knowledge를 연산에 반영하는 것이고, content-based attention에 비해 상대적으로 안정적인 alignment 학습과 추론이 가능해진다.\n이렇게 과거 alignment를 활용하는 방식을 cumulative attention이라고도 하고, location-sensitive attention이라고도 한다.\n하지만 이 역시 kernel F의 작동 방식을 완전히 순증가 하도록 제약한 것이 아니기 때문에 기존 보다는 완화되었지만 여전히 반복과 누락 등의 이슈가 발생한다.\n이후 [git:coqui-ai/TTS] 등의 오픈소스에서는 순증가의 제약을 강제하기 위해 이전 align 시점의 근방에 대해서만 softmax를 취하는 휴리스틱을 적용하기도 한다.\n# PyTorch\r# previous_align: [B, S]\r# energy: [B, S]\rfor i, p in enumerate(previous_align.argmax(dim=-1)):\renergy[i, :p] = -np.inf\renergy[i, p + 3:] = -np.inf\r# [B, S]\ralign = torch.softmax(energy, dim=-1) Stop-token prediction Tacotron에서는 decoding의 종료 시점을 명시적으로 모델링하지 않아 여러 heuristic에 따라 종료 시점을 판단해야 했다.\nTacotron2에서는 NLP의 End-of-sentence(이하 EOS) 토큰과 유사히 어느 시점부터 합성을 종료할지 판단하는 Stop token을 명시적으로 모델링한다.\n가변 길이 시퀀스는 배치로 묶는 과정에서 패딩을 붙여 고정된 크기의 텐서로 변환하는데, spectrogram이 존재하는 부근을 false, 패딩이 존재하는 부근을 true로 하는 binary classification 문제를 decoding 할 때마다 추론하게 하는 것이다.\n이렇게 되면 decoding 과정에서 프레임마다 stop token을 추론하여 decoding을 지속할지 멈출지 판단할 수 있는 근거로 작동시킬 수 있다.\n하지만 이 역시도 모델의 판단에 맡기는 것이기 때문에 합성 중 잘못 추론하는 경우 조기 종료되거나 장기화되는 이슈가 발생할 수 있다. 이에 stop token이 연속 N번 발생하면 종료하는 heuristic을 설정하여 안정성을 높이는 방식을 채택하기도 한다.\n대체로 Align과 Autoregressive Decoding을 동시에 진행하는 모델은 종료 시점에 대한 엔지니어링 이슈가 상시 발생할 수밖에 없다. 이는 추후 TTS field가 AR 모델에서 병렬 합성 모델로 이동하는 원인이 되기도 한다.\nAR TTS - Architecture\nTacotron2가 Neural TTS의 baseline으로 선정된 이후 TTS의 백본 네트워크를 어떻게 잡는 것이 합성 품질을 높이는가의 추가 연구가 있었다.\nDCTTS: Efficiently Trainable Text-to-Speech System Based on Deep Convolutional Networks with Guided Attention, Tachibana et al., 2017. [arXiv:1710.08969] Category: Autoregressive, CNN, Content-based alignment Contribution: CNN-based architecture, SSRN\nFigure 1: Network Architecture. (DCTTS, 2017)\nDCTTS는 그중에서 전체 아키텍처를 convolution으로 구성한 TTS 모델이다.\n특이한 점 한가지는 attention alignment에 additive attention이 아닌 dot-product attention을 썼다는 것이다. 이 경우 역시 monotonicity에 관한 prior knowledge는 연산상에 반영되지 않는다.\n$$a_{t, \\cdot} = \\mathrm{softmax}(K^TQ/\\sqrt d) \\ \\ \\mathrm{where} \\ \\ K=Us_{1:S}, \\ Q = Wq_t$$\n저자는 대신 guided-attention loss라는 목적 함수를 제시한다. attention alignment가 \u0026ldquo;nearly diagonal\u0026quot;이 되도록 유도하는 방식으로, monotonic한 alignment가 대각 성분에서 값을 가지는 꼴로 표현되는 현상을 구현한 것이다. 연산 상에서 순증가성을 반영하지는 않았지만, 목적함수를 통해 유도하는 방식으로 학습 안정성을 도모한다.\n$$\\mathcal L_\\mathrm{att}(A) = \\mathbb E_{t, s}[A_{t, s}W_{t, s}] \\\\ \\mathrm{where} \\ \\ W_{t, s} = 1 - \\exp\\{-(t / T - s / S)^2/g^2\\}$$\nFigure 3: Comparison of the attention matrix. (DCTTS, 2017)\n또 한 가지 특이한 점은 SSRN: Spectrogram Super-resolution Network를 활용한 점이다.\nDCTTS에서는 mel-spectrogram을 1/4배로 downsampling(mean-pool)한 결과물을 spectrogram decoder가 생성하도록 학습한다. 대체로 음소 1개에 대응되는 spectrogram은 4개 프레임인 것에 착안하여 텍스트의 길이와 downsampling된 spectrogram의 길이 비가 대략 1대1이 되도록 구성한 것이다.\n대신 생성된 1/4-scale의 spectrogram을 원본 길이로 복원하기 위해 별도의 경험적 upsampler를 구성하며, 이것이 SSRN이다. 기본적으로 autoregressive decoding은 연산 비용이 높기 때문에, AR decoding에서는 downsample된 spectrogram을 합성하고, SSRN에서는 parallel한 convolution 연산을 상정하여 연산을 가속한 것으로 보인다.\nTacotron의 reduction heuristic이 한 번에 N개 프레임을 합성하는 대신 iteration을 T/N으로 줄였다면, DCTTS는 T/N개 프레임을 합성한 후에 T개 프레임으로 SR 하는 방식을 차용했다는 차이점이 있다.\nTransformerTTS: Neural Speech Synthesis with Transformer Network, Li et al., 2019. [arXiv:1809.08895] Category: Autoregressive, Transformer, Content-based alignment Contribution: Transformer-based architecture\nFigure 3: System architecture of our model. (TransformerTTS, 2018)\nTransformer TTS는 engineering 관점에서 연구가 많이 이뤄졌다.\nSinuositional encoding의 범위는 [-1, 1]인 것에 반해, Prenet의 output이 ReLU일 경우 $[0, \\infty]$의 범위를 가져 feature map의 center point가 다르게 잡히는 현상이 발생했고, 이것이 실제 성능 저하로 이뤄짐을 확인했다. 저자는 이를 방지 하기 위해 prenet에 projection layer를 추가하고 PE 앞에 weighted term을 두었다.\n$$l_i = W\\mathrm{prenet}(x_i) + \\alpha PE_i$$\nStop token prediction에서는 true와 false의 비율이 다른 unbalanced classification 문제임을 지적하였고, 패딩에 해당하는 true 케이스의 목적함수에 가중치를 곱하였다고 이야기한다.\nTransformer TTS도 DCTTS와 마찬가지로 dot-product attention을 활용하였다. 다른 점은 Transformer에서 제안한 multihead attention을 활용한 점이다.\n개인적인 경험으로는 TTS에서 attention이 여러 개일 때 monotonicity가 유도되는 alignment map은 대체로 1개만 나오는 편이다. 나머지 alignment들은 해석이 불가능하거나, 무의미한 경우가 많다. 저자는 attention head가 4개일 때 보다 8개일 때 MOS가 높았다고 이야기하였다. 이 경우 어떤 이유에서 좋아진 것인지, single-head일 때와 multi-head일 때의 alignment plot을 첨부해주었다면 어땠을까 하는 아쉬움이 있다.\nAR TTS - Alignment\nContent-based attention의 문제점이 지적되며, attention의 순증가성을 연산에 어떻게 강제할 것인지, content를 energy 연산에서 제거할 수 있는지의 추가 연구도 있었다.\nForward Attention in Sequence-to-sequence Acoustic Modeling for Speech Synthesis, Zhang et al., 2018. [arXiv:1807.06736] Category: Location-sensitive alignment Problem: Training instability, lack of monotonicity prior Contribution: Forcing monotonicity Future works: Content inputs\nFigure 1: Grey circles represent a possible alignment path. (Forward Attention, 2018)\nForward attention은 CTC(Connectionist Temporal Classification, Graves et al., 2016.)에서 영감을 받아, 현재의 attending phoneme에서 다음 음소로 이동할지, 현재의 음소에 남아 있을지를 확률로 판단하고자 한다.\nContent-based attention은 TTS가 기존까지 어떤 음소들을 attending 하였는지 고려하지 않고, 현재 시점에서 가장 가능도가 높은 지점을 선택한다. 하지만 alignment의 연속성과 순증가를 기저로 한다면, 현재의 attending point는 이전 프레임의 attending point와 현재 시점의 가능도를 모두 고려해야 한다.\n연속성(Continuity): 음소의 누락 없이 alignment는 모든 음소를 순차적으로 1회 이상 attending 해야 한다. 순증가(Monotonicity): alignment의 attending point(가장 확률이 높은 지점)는 양의 방향으로만 이동한다. 예로 t번 프레임에서 s번 음소가 attending 될 확률은 t-1번 프레임의 s-1번 확률(이동)과 s번 확률(유지)을 더한 후, content 상에서 t번 프레임의 s번 확률(실체화 가능성)을 곱해야 한다. 과거 프레임에 의해 전이될 확률을 더하고, 실체화될 가능성을 곱하는 것이다.\n즉 \u0026ldquo;content 상에서 실체화될 가능성\u0026rdquo;(=content-based energy)과 \u0026ldquo;continuity \u0026amp; monotonicity에 의해 attending 될 가능성\u0026rdquo;(=attending probability)을 분리한다. 이렇게 되면 기존 content-based attention과 달리 연속성과 순증가의 기저에 따라 attending될 가능성을 고려할 수 있다.\ncontent-based energy를 $y$, attending probaility를 $a$라 하면 다음과 같이 표현 가능하다.\n$$\\begin{align*} \u0026amp;y_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(Wq_t + Us_{1:S})) \\\\ \u0026amp;a_{t, s} = (a_{t - 1, s - 1} + a_{t - 1, s})y_{t, s} \\\\ \u0026amp;\\hat a_{t, s} = a_{t, s} / \\sum^S_{i=1} a_{t, s} \\\\ \u0026amp;h_t = \\sum^S_{i=1}\\hat a_{t, i}s_i \\end{align*}$$\n위 표현은 이동 확률$\\alpha_{t-1, s-1}$과 유지 확률$\\alpha_{t - 1, s}$을 동일하게 0.5로 보고 있다. Forward attention에서는 이동 확률과 유지 확률 또한 학습 가능한 대상으로 보았고, transition agent $u$라는 확률을 도입한다.\n$$a_{t, s} = (u_{t - 1}a_{t - 1, s - 1} + (1 - u_{t - 1})a_{t - 1, s})y_{t, s}$$\n경우에 따라 content-based energy를 location-sensitive attention 꼴로 formulation 하기도 한다. attending 확률을 분리한 것과 별개로, energy의 연산상에도 monotonicity가 반영될 수 있도록 유도하는 것이다.\n$$y_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(Wq_t + Us_{1:S} + F\\ast y_{t - 1}))$$\nFigure 2: Alignmnts of an utterance. (Forward Attention, 2018)\nForward attention은 alignment map의 확률적 표현을 통해 alignment에 continuity와 monotonity를 부여하였다. 이를 통해 실제 학습 안정성은 더욱 올라왔고, 기존 보다 확률이 양단화된 hard한 attention의 꼴로 표현되었다.\n그럼에도 강제하는 수준은 아닌만큼 여전히 이전 프레임의 attending point를 기반으로 alignment map을 마스킹하기도 한다.\nDCA: Location-Relative Attention Mechanisms For Robust Long-Form Speech Synthesis, Battenberg et al., 2019. [arXiv:1910.10288] Category: Location-sensitive alignment Contribution: Remove contents from energy\nAttention alignment는 대체로 장기성 문제를 가지고 있었다. 문장의 길이가 길어질수록 누락/반복 등의 합성 실패 확률이 높아지는 것이다. DCA에서는 이를 해결하기 위해 2가지 방법론을 제안한다.\nGMM-based Attention 하나는 attending point를 직접 가정하는 방식이다. 기존까지는 content를 기반으로 energy를 계산했다면, 이번에는 content를 통해 몇번째 음소를 attending할지 직접 추정하는 것이다.\nNetwork $P_\\theta$는 query와 text encodings를 통해 $\\mu_t$번째 프레임을 attending 할 것이라고 명시한다. 이후 alignment는 Gaussian likelihood를 통해 $\\mu_t$를 기준으로 weight가 확산되는 꼴로 표현된다.\n$$\\begin{align*} \u0026amp;\\alpha_{t, s} = \\mathrm{softmax}\\left(-\\frac{(s - \\mu_t)^2}{2\\sigma_t^2}\\right) \\\\ \u0026amp;\\mathrm{where} \\ \\ \\mu_t, \\sigma_t = P_\\theta(Wq_t, Us_{1:S}) \\end{align*}$$\n이 때 monotonicity와 continuity는 $\\mu_t$를 이동량 $\\delta_t$로 표현하여 자연스럽게 획득할 수 있다.\n$$\\begin{align*} \u0026amp;\\delta_t, \\sigma_t = P_\\theta(Wq_t, Us_{1:S}) \\\\ \u0026amp;\\mu_t = \\mu_{t - 1} + \\delta_t \\ \\ \\mathrm{where} \\ \\ \\delta_t \\in [0, 1]\\end{align*}$$\nDCA에서는 하나의 프레임이 multiple point를 attending할 수 있다는 가정 아래, unimodal gaussian을 multimodal gaussian mixture로 확장한다. 이를 GMM-based attention이라 부른다.\n$$\\alpha_{t, s} = \\sum^{K}_{k=1}\\frac{w _{t, k}}{Z _{t, k}}\\exp\\left(-\\frac{(s - \\mu _{t, k})^2}{2\\sigma _{t, k}^2}\\right)$$\nDynamic convolution attention 다른 하나는 energy 연산에서 직접적인 content의 영향력을 배제하는 것이다.\n$$a_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(Wq_t + Us_{1:S} + F \\ast a_{t - 1, \\cdot}))$$\n기존까지의 location-sensitive attention은 $Wq_t$와 $Us_{1:S}$를 통해 content의 직접적 영향력을 행사한다. 이는 query가 과거의 context에 매칭되었을 때 alignment가 backward 할 수 있다는 문제점을 가진다.\n이를 방지하기 위해 content 요소를 완전히 제거하면, alignment는 location convolution을 통해 항상 고정된 만큼만 움직일 수 있다. 이를 해결하기 위해 제안된 것이 dynamic convolution이다.\n$$\\begin{align*} \u0026amp;a_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(F\\ast a_{t - 1, \\cdot} + \\mathcal G_\\psi(h_{t - 1}, q_t) \\ast a_{t - 1})) \\\\ \u0026amp;h_t = \\sum^S_{i=1}a_{t, i}s_i \\end{align*}$$\ndynamic convolution은 network $\\mathcal G_\\psi$를 통해 kernel을 생성하여 convolution 연산을 수행한다. 이렇게 weight를 런타임에 생성하는 네트워크를 hyper network라고도 부른다.\nDCA에서는 content 정보를 에너지에 직접 반영하는 대신, content를 기반으로 alignment를 얼마나 움직일지 추정한다. 이렇게 되면 query와 text를 직접 매칭하지 않기 때문에 content에 의한 backward를 방지하면서, query를 기반으로 현시점이 attending point를 이동할 시점인지 추정할 수 있게 된다.\n하지만 이 역시 $\\mathcal G_\\psi$의 추정에 따라 attending point가 backward로 이동할 수 있다. DCA는 이를 방지하기 위해, 항상 앞으로 움직이는 고정된 kernel $\\mathcal P$를 prior로 제공한다.\n$$a_{t, \\cdot} = \\mathrm{softmax}(v^T\\mathrm{tanh}(F\\ast a_{t - 1} + \\mathcal G_\\psi(h_{t - 1}, q_t) \\ast a_{t - 1} + \\mathcal P \\ast a_{t - 1}))$$\nprior kernel $\\mathcal P$는 beta bernoulli의 likelihood 값을 활용하며, 다음은 prior kernel을 convolution 했을 때의 실제 alignment 이동을 도식화한 것이다.\nFigure 1: Initial alignment encouraged by the prior filter. (DCA, 2019)\n이렇게 구성된 DCA는 다른 alignment 보다 빠르게 수렴하기 시작하고, 문장이 길어지더라도 오합성률이 크게 늘어나지 않는다.\nFigure 2: Alignment trials for 8 different mechanisms. (DCA, 2019)\nFigure 3: Utterance length robustness. (DCA, 2019)\nMove to Parallel TTS\nAutoregressive 모델은 꾸준히 발전해왔지만, 태생적으로 합성 속도와 alignment에 대한 engineering cost는 극복할 수 없다.\n이에 연구자들은 다시금 발화 길이를 기반으로 forced align을 구성하는 것에 관심을 가지기 시작했고, 이렇게 개발된 것이 FastSpeech[arXiv:1905.09263]이다.\n다음 글에서는 FastSpeech와 이후의 Parallel TTS에 관해 이야기 한다.\nReference\nA Survey on Neural Speech Synthesis, Tan et al., 2021. [arXiv:2106.15561] Connectionist temporal classification: Labelling unsegmented sequence data with recurrent neural networks, Graves et al., 2006. WaveNet: A Generative Model for Raw Audio, Oord et al., 2016. [arXiv:1609.03499] Tacotron: Towards End-to-End Speech Synthesis, Wang et al., 2017. [arXiv:1703.10135, git:keithito/tacotron, git:r9y9/tacotron_pytorch] Neural Machine Translation by Jointly Learning to Align and Translate, Bahdanau et al., 2014. [arXiv:1409.0473] Tacotron2: Natural TTS Synthesis by Conditioning WaveNet on Mel Spectrogram Predictions, Shen et al., 2017. [arXiv:1712.05884, git:NVIDIA/tacotron2] Attention-Based Models for Speech Recognition, Chorowski et al., 2015. [arXiv:1506.07503] DCTTS: Efficiently Trainable Text-to-Speech System Based on Deep Convolutional Networks with Guided Attention, Tachibana et al., 2017. [arXiv:1710.08969] TransformerTTS: Neural Speech Synthesis with Transformer Network, Li et al., 2019. [arXiv:1809.08895]- Forward Attention in Sequence-to-sequence Acoustic Modeling for Speech Synthesis, Zhang et al., 2018. [arXiv:1807.06736] Forward Attention in Sequence-to-sequence Acoustic Modeling for Speech Synthesis, Zhang et al., 2018. [arXiv:1807.06736] DCA: Location-Relative Attention Mechanisms For Robust Long-Form Speech Synthesis, Battenberg et al., 2019. [arXiv:1910.10288] WaveRNN: Efficient Neural Audio Synthesis, Kalchbrenner et al., 2018. [arXiv:1802.08435] LPCNet: Improving Neural Speech Synthesis Through Linear Prediction, Valin and Skoglund, 2018. [arXiv:1810.11846, git:xiph/LPCNet] MelGAN: Generative Adversarial Networks for Conditional Waveform Synthesis, Kumar et al., 2019. [arXiv:1910.06711, git:seungwonpark/melgan] FastSpeech: Fast, Robust and Controllable Text to Speech, Ren et al., 2019. [arXiv:1905.09263] g2p: English Grapheme To Phoneme Conversion, [git:Kyubyong/g2p] phonemizer: Simple text to phones converter for multiple languages, [git:bootphon/phonemizer] TTS: a deep learning toolkit for Text-to-Speech, battle-tested in research and production, [git:coqui-ai/TTS] ","permalink":"https://revsic.github.io/blog/alignment/","tags":["Machine Learning","Deep Learning","TTS","Attention","Alignment","Monotonic"],"title":"Survey: Neural TTS and Attention Alignment"},{"categories":["Writing"],"contents":"21년도 한 해가 지났다. 학교와 회사를 병행한 20년도였다면, 21년은 자신과 회사 일의 균형을 맞춘 한 해였다.\n올해의 회고는 지난 1년간의 일을 월별로 정리해보려 한다.\n1월 라로 - Ablation Study\n21년 1월 처음으로 개발 중이던 모델에 Ablation Study를 진행했다.\nAblation Study는 모델의 각 요소를 제거해보고, 대체하며 현상을 확인하는 작업이다. 딥러닝이란 분야적 특성도 있고, 이전까지 연구 방법론에 대한 프로세스가 정립되지 않았었기에 각 요소가 어떤 역할을 하는지, 중간 표현은 어떤 의미를 가지는지 전혀 모르고 있었다.\nAblation Study는 이를 확인하기 위한 작업이었고, 현행 TTS 모델에 대해 아주 많은 인사이트를 얻어갈 수 있었다.\n연구는 텍스트 인코더, 어텐션 메커니즘, 스펙트로그램 디코더로 나눠 진행했으며, 어떤 아키텍처가 발음 문제에 강하고 음질 수준에 도움을 주는지, 각 어텐션 메커니즘이 최종적으로 회귀하는 옵티멀한 선택지가 있는지 등을 알아보았다.\n한참이 지나 11월에는 단순 연구 노트의 실험 기록과 정리를 넘어 지식의 형태로 남기길 바랐고, 이에 Wiki를 만들어 각 컴퍼넌트와 품질의 상관관계를 글로 정리했다.\n연구 조직에서 활동하다 보면 성공보다 실패의 경우가 많고, 작동 방식이나 구성 요소에 관한 연구를 진행하는 것이 실질적인 성과로 이어지지 않는 때도 있다. 그렇기에 더더욱 연구 조직은 성과로 가는 길에 체크포인트를 둘 수 있어야 하고, 꾸준히 과정 자체를 결과물로 기록해둘 수 있어야 하는 것 같다. Wiki와 중간 샘플 공유는 이의 결과물이고, 실패를 성과화 할 수 있는 방법론이었다.\n2월 라로 - 모델 배포\n19년도 9월부터 대략 1년 6개월의 장정 끝에 처음으로 모델을 배포했다. 가칭 PTv2 모델은 Tacotron을 시작으로 한 우리 회사의 첫 Parallel TTS 모델이었다. 당연히 합성 품질이 이전 같지 않다는 문제가 있었지만, 당시에는 실시간 합성이 가능한 딥러닝 TTS 모델이 필요했고, PTv2는 이에 가장 알맞은 모델이었다.\n첫 배포였기에 학습 정량화부터 진행하였다. 추가 튜닝 없이 다양한 데이터셋에서 어느 정도의 품질을 냈는지, 의도한 품질까지 얼마만큼의 데이터셋 규모와 학습량이 필요한지 등을 실험적으로 구하였다.\n이는 엔진 제작팀으로 전달되었고, 12월인 지금까지도 PTv2 모델을 가장 기본으로 사용하고 있다.\n이후 모델은 프로덕트에서 더욱 다양한 데이터셋과 사용자 입력을 만나며 다양한 버그가 리포트 되었다. 하지만 대부분의 버그는 딥러닝 특성상 모델 구성 수준에서 해결하기 어려웠다. 실험적으로 더 많은 데이터를 넣어 결과를 확인하거나, 개별적으로 파라미터 튜닝을 하는 것 정도가 일차적인 해결방안이었다.\n의미도 모를 중간 표현을 관찰하는 등 디버깅은 계속됐다. 관찰 도중 중간 표현의 분포가 특정 입력에서 변화하는 현상을 확인했고, 9월에는 이를 모델 구성 수준에서 해결하기 위한 연구가 진행되었다.\n이후 버그는 1/4 수준으로 줄어들었고, 새로이 모델의 배포를 준비 중이다. 이 외에도 중간 표현을 관찰하여 자동으로 이상을 탐지하는 딥러닝 디버거 개발 등을 앞두고 있다.\n딥러닝 모델을 디버깅할 수 없다는 건 이제 옛말일지도 모른다. 연구팀은 주어진 환경에서 문제를 정의하고, 이제 원인을 밝혀낼 수 있어야 한다. 내년에는 이에 대한 프로세스를 확립하고 공유할 수 있으면 좋을 것 같다.\n3월 독립\n지난 3월 본가를 나와 교통편이 좋은 곳에서 자취를 시작했다.\n원래도 정거장 수만 세면 본가에서 사무실이 멀지는 않았는데, 본가에서 역으로 나가 환승하는 것까지 고려하면 대략 왕복 2시간 정도가 소요되었다. 2년 정도는 이렇게 출퇴근했었고, 이는 생각보다 생활 패턴을 망쳐갔다.\n지금 회사는 8시에서 11시 사이에 출근하는 탄력 근무제를 시행하고 있다. 처음에는 9시에 출근해 6시에 퇴근했었는데, 6시의 지옥철을 타고 1시간을 퇴근하는 것은 절대 쉬운 일이 아니었다. 그렇게 피로감을 느끼고 7시 집에 도착, 8시에 저녁을 먹고 나면 8시부터 10시는 낮잠 시간이었다.\n낮잠을 자고 나니 밤잠을 늦게 자게 되고, 생활 패턴은 꼬여만 갔다. 늦잠 몇 번에 출퇴근 시간이 늦어지고 나니 퇴근 후 개인 시간이 존재하지 않았고, 퇴근-저녁-잠-출근의 워크 앤 워크 사이클로만 시간이 채워져 갔다.\n감정 상태나 피로감에 대한 충분한 이완 없는 사이클은 번아웃으로 이어졌다. 어떻게든 일을 지속하려면 이를 타파해야 했고, 몇 가지 시작한 생활 습관이 있다.\n우선 부모님과 이야기 중이던 독립을 앞당겼고, 교통편이 좋은 곳에서 자취를 시작했다. 자취방에서 사무실은 전철로 10분 거리고, 문에서 문으로 20분 정도면 도착한다. 왕복 시간이 줄어들면서 근본적인 출퇴근 피로감을 많이 줄일 수 있었다.\n또 체력이 부족하다고 생각해서 근래에는 조금씩 운동을 시작하고 있다. 확실히 운동하고 나면서 낮잠을 자는 빈도도 많이 줄어든 것 같다.\n이렇게 생활 패턴이 정상화된 이후로는 8시 출근, 5시 퇴근을 하면서 저녁 시간도 챙겨가고 있다. 기타도 사서 하고 싶던 취미 생활도 시작하고, 온라인 게임이나 저녁 약속 잡는데도 부담이 줄었다. 저녁이 생기고, 감정적 이완이 가능해지니 번아웃도 많이 줄어들었다.\n나는 생활력이 꽤 있는 편인 것 같다.\n친구들과 독립에 대해 이야기할 때에도 너는 걱정 없다는 이야기를 많이 들었던 것 같다. 밥도 해먹고, 요리도 잘 하고, 청소도 매일 하고 그러고 지내고 있다. 자취방 근처에 밥집이 없는 것도 한몫한 것 같다.\n먼저 자취하던 친구들은 외롭다는 이야기도 많이 했었는데, 나는 혼자 있는 것에 크게 외로움을 느끼지는 않는 편이어서 다행인 것 같다. 오히려 내 생활 패턴에 온전히 집중할 수 있고, 모든 상황이 의지 아래 조절 가능하단 점이 너무 좋다. 어쩌면 고등학생 때부터 이어진 결벽의 만족감일 수도 있겠다.\n좀 이른 나이에 경제적 독립과 주거의 독립을 이뤘지만, 굉장히 만족하는 삶을 살고 있다.\n글을 마무리 짓기도 전에 이 문장을 수정할 줄 몰랐다.\n겨울이 되니 집에 하자가 많다. 온수가 안 나오고, 후드를 열 때마다 물 폭탄이 떨어진다. 집을 알아볼 때부터 그런 것은 아니었다. 3월에는 온수도 잘 나왔고, 후드는 말라 있었다.\n그러던 12월 초, 영하의 온도가 찾아오면서 아침에 샤워하려는데 온수가 안 나오기 시작하고 요리 중에 후드를 열면 결로가 고여 있다가 후두둑 떨어진다. 덕분에 아침마다 샤워를 고민하고, 요리도 여럿 버렸다.\n지금 집은 집주인 아저씨가 와서 직접 고치시는데, 차라리 기사를 불렀으면 하는 마음이다.\n자취 참 쉽지 않다.\n4월 라로 - 첫 단독 연구\n모델을 배포하고 난 후의 4월, 해외 진출에 관한 이야기가 시작되면서 연구팀으로 다국어 모델에 대한 요청이 들어왔다. 한국어 데이터셋만 가지고 영어를 말하게 만드는 연구였다.\n여느 때처럼 arxiv와 paperswithcode에 들어가 다국어 모델에 대한 조사를 시작했다. 회사에서는 병렬 합성 모델을 배포한 이후였고, 애드온과 같은 방식으로 기존 모델 위에 올렸으면 하는 상황이었다.\n하지만 parallel tts의 연구가 등장한 지 얼마 되지 않은 시점이었기에 대부분의 다국어 연구는 Tacotron 위에서 작동했다. 그마저도 원하는 퀄리티가 아니었고, 회사 데이터셋 환경과 호환이 되지도 않았다.\n약간의 힌트와 데이터셋, 모델의 제약만 존재하는 상황이었고, 처음으로 남들이 공개하지 않은 미지의 영역에 발을 딛은 느낌이었다.\n이는 굉장한 설렘으로 다가왔다. 첫 개인 연구이기도 하고, 연구자로 유의미한 발자국을 남길 기회라 생각했다.\n베이스라인부터 차근차근 시작했다. Tacotron 기반 다국어 모델에서 필요한 요소들을 적용해 보면서 최초 현상을 관찰했다. 어느 부분에서 문제가 생겼을지 현상과 직관을 기반으로 가설을 세우고 하나둘 실험을 통해 검증해갔다.\n처음에는 언어 표현을 어떻게 해야 할지, 어떤 방식으로 언어 정보를 첨가해야 할지 고민했고, 이후에는 비언어적 특성을 화자에서 분리해낼 수 있는지, 혹은 이를 모사해낼 수 있는지 등을 고민했다.\n시간은 6월 훈련소 가기 전까지 2달 정도로 촉박했고, 하루에 8개 정도의 실험을 꾸준히 돌려 가며 대략 200여 개의 모델을 구성해 보았다.\n그 결과가 다음의 영상이다. 2달의 연구 기간, 첫 단독 연구였기에 이 정도 음성은 꽤 만족스러웠다. parallel tts에서의 비언어적 특성과 정보 전이란 주제로 무언가 발자국을 남긴 기분이었다. 이 모델은 1차 배포가 진행되었지만, 이후 발음 이상이나 음질 문제로 아직 프로덕트에 가진 못했다.\n그렇게 6월 훈련소를 갔다 오고, 다른 프로젝트에 우선순위가 돌아가며 다국어 연구는 중단되었다.\n이 외에도 연구 프로세스나 기간 산정, 성과 평가 등 연구 정량화에 관한 이야기가 이때를 기점으로 시작되었다. 현재에 연구팀에 공유되고 있는 연구 프로세스라는 문서도 이 시기의 경험을 기반으로 작성되었다.\n성과도 만족스러웠지만, 프로세스를 확립하고 정량화에 대한 논의가 시작되었단 점에서도 긍정적이다.\n라로 - 연구팀장\n19년도 9월, 음성 연구원으로 입사한 이후 1년 6개월 정도의 기간 동안 TTS 모델만을 연구해 왔다. 이후로 여러 인턴과 연구원분들이 왔다 갔다 했지만, 회사 규모는 여전히 10명 정도였고, 팀은 기획-마케팅과 R\u0026amp;D 정도로만 나뉘어 있었다.\n그러던 중 4월에 인사팀장님과 연구원을 공격적으로 채용하면서 연구팀의 운영에 수요가 생겼다. 대표님이 먼저 연구팀장의 위치를 제안해주셨지만, 처음에는 할 생각이 없었고, 거절했다.\n나는 특성화고를 나와 졸업하자마자 취업한 여러 친구의 고생을 보며 알게 모르게 회사란 존재에 적대감을 가지고 있었다. 이러한 적대감은 내가 연구에는 몰입할지언정, 회사에는 몰입하지 못하게 했다.\n지금 보면 창업 초기 멤버로 시작해 2년간 일한 회사에 몰입하지 못하는 것도 아이러니하긴 하다.\n이러한 배경 속에서 나는 굳이 팀장 자리를 맡을 이유가 없었고 처음에는 그저 연구원으로 자리를 물렀다.\n그러던 중 회사에 첫 퇴사자가 나왔다. 회사는 안 믿어도 사람은 좋아하던 나에겐 꽤 충격적인 일이었다. 당시에는 모두가 어렸고, 모두에게 첫 창업이자 첫 직장이었다. 서로에게 너무나도 쉽게 상처를 줄 수 있었고, 그렇게 떠나갔다.\n나는 이를 기점으로 최소한 내가 뽑은 사람들은 이런 일이 없었으면 하는 마음이 생겼다.\n나는 연구팀의 운영에 다시 관심을 가지기 시작했고, 나라는 필터를 통해 우리 팀원들이 상처받지 않았으면 했다. 강한 피드백이 온다면 좀 더 돌려서 전달할 수 있는 환경이었음 했고, 모두가 서로를 견제하기보다는 으쌰으쌰 하며 시너지를 낼 수 있었으면 좋겠다고 생각했다.\n이왕 하는 김에 연구자들의 목소리도 전달 할 수 있으면 좋을 것 같았다.\n당시에는 연구를 중단하고 다른 프로젝트로 넘어가는 일이 허다했다. 왜 이 연구를 해야 하는지 설득할 채널도 없었고, 연구 방향이 사업과 정렬되어 있지 않아 주제를 트는 경우도 다반사였다.\n연구자는 연구에 애정을 붙이기 어려운 환경이었고, 동력이 떨어진 후에는 이전만큼 열심히 하지 않았다.\n나는 다시 대표님을 찾아가 연구팀장 자리를 제안했다. 기술 대표님이 총괄하던 R\u0026amp;D에서 연구팀을 분리했고, 주간 회의에도 참여하여 연구자 대표의 입장에서 왜 이 연구를 해야 하고, 앞으로의 사업 방향성에 맞추기 위해 이런 주제나 연구가 필요하다고 이야기하기 시작했다.\n팀이 생기니 할 일이 많아졌다.\n보다 본격적인 연구 활동을 위해 연구 프로세스를 정립하기 시작했고, 연구 기간에 대한 정량화를 진행했다.\n굉장히 막막한 일이었다. 주변 대학원생 형들은 연구 프로세스라는 것이 있냐고 오히려 반문해왔다. 대학원은 이를 논문 쓰기라는 과목에서 가르치고는 있었지만, 프로젝트 단위의 기간이나 리소스 사용량을 정량화하는 정도는 아니었다.\n결국 4월에 진행한 다국어 연구를 기반으로 하나둘 기준을 잡아갔다. 한 번의 연구 시도를 몇 개의 실험으로 잡고, 대략 몇 개의 시도 정도에 얼마만큼의 성과 가능성이 있는지 기록했다.\n실제로 주간 회의에서의 연구 공유는 이 포맷을 통해 이뤄졌고, 여전히 꽤 유의미하게 들어맞고 있어 신기하다.\n정량화가 끝나니 본격적인 매니징이 시작되었다.\n내 연구만을 보던 나는 처음으로 타인의 연구를 보고 공유하기 시작했다. 원활한 소통을 위해 연구 포맷을 맞추고, 연구 방향성과 방식에 대한 피드백을 진행하기도 했다.\n처음 하는 일이다 보니 굉장히 많은 리소스를 잡아 먹었다. 내 연구를 못할 정도는 아니었지만, 이전만큼 집중하지 못하기도 했다. 그뿐만 아니라 다른 사람의 연구 성과도 내가 책임을 지게 되니 어깨는 무거워져 갔다.\n이후 매니징의 부담감은 10월 비전팀 신설과 함께 굴러 나가기 시작했고, 결국 번아웃으로 이어졌다.\n5월 오마카세\n6월 훈련소 입소가 확정이 나고, 5월 코로나로 못 보던 사람들을 만나기 시작했다. 그 중엔 옥찬호 형도 있었는데, 꽤 오랜만에 만나 스시 오마카세에 가게 되었다.\n오마카세를 자주 갈 만큼 잘 먹고 다니는 편은 아니었다 보니 먹으러 가는 길 자체가 설렜던 것 같다.\n21.05.22.스시 스미레\n평소에도 회나 초밥류를 굉장히 좋아하는 편이었기에 만족도는 하늘을 찔렀다. 나는 특히 청어나 고등어를 좋아하는 편인데, 자칫 비릴 수 있는 생선이지만 산미와 함께 깔끔히 잘 표현해 더욱 맘에 들었다.\n참치도 굉장히 맛있었고, 성게알의 크리미함은 말할 필요도 없다.\n5월엔 특히 매니징에 대한 고민이 많았던 시기라 찬호형의 고민 상담과 맛있는 스시는 훈련소 가기 전 체증을 씻어 내리는 것만 같았다.\n훈련소에 다녀온 7월에 한 번 더 오마카세에 들리기로 하며 현실로 돌아갔다.\n21.07.11.스시 사토시\n7월엔 사토시에 들렀다. 여기는 처음에 받은 오징어 회부터 굉장한 이목을 끌었다. 해조류와 미소가 올라가 있었는데, 산뜻하면서도 미소의 고소함과 오징어의 식감이 잘 어우러져 있었다.\n아귀 간도 이날 처음 먹어봤는데, 성게알과는 또 다른 크리미함과 고소함이 만족도를 최상으로 끌어올렸다.\n청어, 고등어 회는 물론 솥밥까지 뭐 하나 놓칠 것이 없었다.\n돈 많이 벌어서 세상 맛있는건 다 먹고 살아야겠다고 생각했다.\n6월 훈련소\n머리를 밀고 훈련소에 다녀왔다.\n2월부터 산업기능요원으로 일하면서 한 번은 다녀와야 했다. 우리 회사는 일찍 갔다 오는 분위기였고, 나는 자리가 남는 가장 빠른 일정으로 6월에 다녀왔다.\n당시 훈련소는 코로나 이슈가 산재해 있었다. 4월에 다녀온 팀원은 2주간 샤워는커녕 양치질도 마음대로 못 했고, 손도 못 씻게 해 물티슈와 손 세정제 이후 식사를 했다고 했다.\n다행히 5월에 훈련소 배식과 함께 이 문제가 사회 문제로 대두되었고, 그래도 6월은 다르지 않겠냐며 걱정 아닌 걱정을 했던 것 같다.\n6월의 훈련소는 다행히 하루 한 번 샤워를 시켜줬고, 화장실은 자유, 하루 2회 세면과 양치질을 할 시간도 줬다.\n달라지지 않은 것은 10일 격리 기간 동안 아무것도 시키지 않는다는 것이다. 동기들은 둘째 날부터 말을 트고 친해지기 시작했고, 숫자 야구, 마피아 게임, 오목 별별 것을 다 하며 시간을 보낸 것 같다.\n10일이 지난 시점부터 매일같이 훈련이 시작되었다. 초여름인 만큼 기온은 높아져만 갔고, 구름 한 점 없는 운동장을 기어 다녔다.\n첫 10일은 시간이 안 갔는데, 이후 10일은 훈련만 하고 오면 피곤해 잠만 자기를 반복했다.\n3주가 지나고 느낀 점은 훈련보다는 인간관계가 피곤했던 것 같다. 정말 밖에서는 못 봤던 다양한 사람을 만났고, 많은 사회 현상을 이해할 수 있었다.\n한 번은 가도 두 번은 못 간다.\n9월 혼자 부산 여행\n나는 달을 주기로 텐션이 올라갔다 떨어지기를 반복했다. 월말이 되면 월간 목표 설립과 회고 과정에서 텐션이 떨어졌고, 중순이 되면 실험 결과에 대한 희망에 부풀어 있었다.\n이는 감정적으로 굉장히 피곤했고, 달에 한 번 정도 리프레시를 위한 여행을 다녔다.\n9월은 처음으로 혼자 여행을 기획해 다녀오기로 했다. 나는 바다를 그냥 멍하니 보기만 해도 좋아 대부분 바닷가로 여행을 다녔고, 혼자 가는 만큼 부담 없이 자주 가본 부산을 다녀오기로 했다.\n21.10.01.해목\n비행기를 타고 도착해 첫날 점심은 해운대 해목에서 장어덮밥을 먹었다. 운이 좋게 브레이크 타임 15분 전에 도착했고, 예전 그 맛 그대로의 덮밥에 만족스러운 한 끼를 가졌다.\n21.10.01.신라 호텔\n호텔은 오션뷰가 있는 신라 호텔로 예약했다. 점심을 먹고 들어선 호텔에 누워 저녁을 고민했다.\n원래는 보리문디라는 이자카야에서 회와 술을 마시는 게 목표였는데, 아쉽게도 당일 예약이 되지 않아 이자카야 나카요시라는 곳에서 모둠회를 시켜 먹었다.\n21.10.01.나카요시\n급하게 찾았지만, 만족도는 굉장히 높았다. 회 종류도 엄청 많았고, 굉장히 신선했다. 부산에 왔으니 대선 소주를 먹어야 한다며 한 병 놓고 혼자서 잘 먹은 것 같다.\n당시에는 행복에 대한 고민이 많았다.\n매니징을 시작하면서 연구에 집중할 수 없는 환경이 계속됐고, 매니저와 연구원 사이 R\u0026amp;R의 모호함, 더 이상 재미를 찾기 힘든 업무 환경에 이젠 퇴근 후에 취미를 찾자, 나는 무엇을 좋아할까 고민하고 있었다.\n그렇게 기획한 여행이었고, 그냥 간단히 파도 소리가 좋아서 부산으로 향했다.\n21.10.01.해운대\n해운대는 그런 배경에서 너무나도 만족스러운 공간이었다. 업무에서 멀어지고 자신에 집중할 수 있는 시간이었다.\n10월 비전팀 신설과 신입 사원 채용이 확정된 상황에서, 더 많은 매니징 리소스를 요구할 것이고, 연구원으로의 나는 잠시 멈출 것이란걸 알았기에 마지막 위안이라 생각하고 잠이 들었던 것 같다.\n21.10.02.광안리 키쉬미뇽, 톤쇼우\n둘째 날은 광안리를 찾았다. 키쉬미뇽에서 커피도 마시고, 톤쇼우에서 돈카츠도 먹었다. 후회하지 않을 만큼 보자고 해서 2시간 가까이 바다만 걸어 다닌 것 같다.\n많이 여행 다녔지만, 9월 말의 여행을 잊을 수 없다.\n10월 라로 - 첫 주니어 온보딩\n회사에 동영상 합성에 대한 니즈가 지속되면서 비전팀 신설을 고려하고 있었다. 그에 따라 음성, 영상 상관 없이 주니어 딥러닝 연구원을 채용하기로 했고, 9월에 산업기능요원 채용을 진행했다.\n그렇게 채용 인원이 확정된 후, 아쉽지만도 모두 비전팀을 희망하여 비전팀장 채용, 비전팀 임시 운영체계 확립, 주니어 온보딩이라는 막대한 매니징 리소스를 감당하게 되었다.\n그중 가장 부담으로 다가온 것은 주니어 온보딩이었다. 당시에는 내가 음성팀장으로 남고, 비전팀장을 따로 뽑는 분위기였기에, 비전팀장 채용은 인사팀장님이 도와주실 것이고, 임시 운영은 음성 연구팀 하던 데로 하면 됐다.\n이전까지는 경력직을 뽑기도 했고, 온보딩 없이 알아서 하는 분위기가 컸기에, 온보딩에 대한 필요성이나 교육 계획이 전혀 없는 상황이었다.\n급하게 딥러닝 연구원으로 있는 다른 친구들에게 연락을 돌렸다. 어떤 온보딩이 이뤄지고 있는지 레퍼런스가 필요했다.\n여러 이야기를 참고하여 논문 리뷰 기간, 토이 프로젝트 기간, 실제 배포 기간의 총 3개 정도의 경험을 만드는 것을 목표로 했다.\n논문 리뷰는 하루에 토픽을 하나 정하고, 논문을 골라 리뷰한 후 공유하는 방식이었다. 반응은 굉장히 좋았다. 이른 시간 안에 여러 토픽을 훑고, 학계의 전반적인 흐름을 공유한다는 것에 공감받을 수 있었다.\n문제는 토이 프로젝트였다. 현재 회사는 통합 음성 연구 개발 환경을 구축해서 활용 중인데, 주니어 온보딩 프로젝트로 비전 연구 개발 환경을 구축하자고 했다가 난이도 조절 실패로 많은 원망을 들었다.\n그래도 주니어분들이 적극적으로 도와주셔서 프로젝트는 1차적으로 마무리 지을 수 있었고, 현재도 이를 잘 활용하고 있다.\n온보딩이 끝난 후, 실제 연구부터 배포에 투입되어 현재도 잘 업무를 수행해 주시고 있다. 개인적으로 온보딩은 난이도 조절을 제외하면 성공적이었던 것 같다. 주니어를 채용하여 1달에 업무 투입까지 올 수 있었던건 개개인 모두의 노력과 나름의 온보딩 프로세스 덕이 아니었나 싶다.\n라로 - 비전팀 신설\n비전팀 온보딩의 1달 동안 비전 연구팀장을 채용하지 못했다. 비전 연구팀은 좌초될 것 같았고, 또다시 주니어들이 바닥에 나앉을 것 같았다.\n오랜 고민이 필요했다. 스피치팀 운영을 넘어 비전팀까지 내가 매니징할 수 있을지 확신이 들지 않았고, 연구에 손을 떼야 하는 상황이 올 것만 같았다.\n하지만 처음 연구팀장을 했던 이유가 생각이 났고, 결국 단일 연구팀을 운영하기로 했다. 나는 얼떨결에 7명의 팀원이 생겼고, 이젠 거의 PM에 가까운 R\u0026amp;R을 가지고 있다.\n비전팀 운영 초기에는 스트레스를 굉장히 많이 받았다.\n내가 전문으로 하지 않는 분야의 매니징을 해야 했고, 최대한 따라가기 위해서는 시간을 쪼개 영상 논문을 리뷰해야 했다. 피로감은 쌓여갔고, 결국 11월에 번아웃이 찾아왔다.\n그래도 생각보다 주니어부터 미들까지의 모든 팀원이 잘 따라줬다. 실험 계획이나 방향성 공유도 충분히 이뤄졌고, 점점 태스크에 능숙해지는 것이 눈에 보일 정도로 빠르게 성장하고 있다.\n가끔 실험 관리 부족으로 태스크에 지연이 생기거나, 연구 부채가 쌓인 실험을 보여주곤 하지만 이는 해결 가능한 문제로 보고 있다.\n근래에는 오히려 나를 걱정해주는 것 같아 괜히 헛헛해지기도 한다.\n간혹 그런 이야기를 듣는다. 공격적인 피드백은 꼭 필요하고, 이를 수용하지 못하면 무난하게 침몰하는 배가 될 수 있다고 말이다.\n나는 이 말에 반은 수긍한다. 특히 리더 그룹 내에서의 방향성 설정과 정렬은 필수적이고, 모든 판단이 치명적일 수 있기에 피드백을 통해 빠른 수정이 요구될 수 있고, 때론 이 과정이 공격적일 수 있다.\n하지만 반은 수긍하지 못한다. 모든 사람이 해당 피드백을 있는 그대로 수용할 수 있는 것은 아니다. toxic한 개발자의 말투가 오랜 논점이 된 것에는 충분히 그럴만한 이유가 있다. 사람에 따라 공격적이지 않게 피드백하더라도 충분히 받아들일 수 있고, 공격적인 피드백은 단지 빨라 보이는 길일 뿐이다.\n나는 이를 잘 조절 할 수 있는 사람이 되고 싶다. 외부에선 경쟁이 있더라도 내부에선 협업이 있었으면 좋겠다. 목표는 높게 잡되, 중간중간 만족할 수 있는 지점을 만들고 이를 통해 독해지지 않아도 될 동기가 충분했으면 좋겠다.\n물론 이 과정에는 외부의 경쟁을 이길 만큼의 성과가 필요함을 알고 있다. 이는 독해져야만 가능한 것이 아님을, 독해지지 않아도 가능하단 걸 보이고 싶다.\n그게 내가 팀장으로 남고 싶은 모습이다.\n11월 라로 - 이사\n내가 처음 본 라로의 모습은 19년 7월 학교 기숙사에 있던 3인의 창업 동아리였다. 그러다 20년 초 7명 정도의 초기 멤버와 함께 을지로의 공유 사무실로 이사를 왔다.\n직원은 21년을 기점으로 폭발적으로 늘었다. 이제 직원 수는 30명이 넘어갔고, 코로나로 직장 내 인원수 제한에 추가 공유 사무실을 임대해야 했다.\n21.10.25.라이언로켓 사무실\n21년 10월 말 드디어 회사는 공유 사무실을 벗어나, 한층 전체를 임대하는 전용 공간을 얻었다.\n21년 4월을 기점으로 회사에 좋은 감정도 많이 생기고, 적대감도 많이 줄어들다가 사무실까지 생기니 여러 복잡한 감정이 들었다. 4명이었던 회사가 30명이 넘어가고, 기숙사에서 시작하여 전용 공간이 생겼다. 팀원 7명을 책임지는 팀장이 되었고, 연구도 틈틈이 진행하며 기술에도 기여하고 있다.\n내 기여점이 얼마나 될지 모르겠지만, 같이 만들어간다는 것이 마냥 사기꾼의 단어는 아니구나 싶었다. 좋은 경험이든 싫은 경험이든 결국 스타트업이라 할 수 있었던 것 같다.\n맥주 일기\n이사도 오고, 비전팀도 신설되었다. 본격적인 통합 연구팀이 운영되며 매니징에 부담감을 느끼고 있었고, 근래에는 연구 태스크까지 추가되며 과중한 업무에 결국 11월 번아웃이 찾아왔다.\n집에 도착하면 아무것도 할 수 없었고, 그저 자다 깨다 자다 깨면 아침이 밝아 왔다.\n무언가 긴장을 이완할 취미를 찾아보고 싶었다. 7월에는 기타를 쳤었지만, 새로 배운다는 부담감에 2달 정도 치고 잠시 내려두었다.\n배워서 하지 않아도 좋고, 충분히 부담 없이 편하게 할 수 있는 것을 찾아보다가 편의점 맥주가 눈에 들어왔다.\n맥주로 무얼 할까 생각하다가, 맥주를 마시고 일기를 남겨보기로 했다. 맥주에 크게 관심이 있던 것이 아닌지라 맛 표현을 어떻게 해야 할지부터가 난관이었다.\n21.11. 맥주 일기\n20개 정도를 기록하다 보니 몇 가지 표현이 정리되었다. 탄산감이나 청량함이 어떤지, 목 넘김은 어떤지, 향이 추가된 맥주인지, 쓴맛은 어떤지 정도가 있다.\n그리고 내 기호에 대해서도 알게 되었다. 나는 호가든이나 블랑처럼 향이 추가된 벨기에식 맥주나, 파울러나 에딩거처럼 적당한 쓴맛과 곡물 향이 섞인 독일식 밀맥주를 좋아한다.\n실제로 번아웃에 도움이 되었다. 퇴근 후에 업무에 대한 고민 없이 오늘은 어떤 맥주를 마셔볼까 하는 설렘도 도움이 되었고, 내가 뭘 좋아하는지 찾는 과정도 좋았다. 농담 삼아 주류가 가진 이완의 힘도 있었던 것 같다.\n요즘도 종종 마시면 일기를 남기고 있다. 아무래도 주류인 만큼 자주 마시거나 주기적으로 마시는 것 보다는 마실 때마다 남기는 편이다.\n일기는 공개되어 있지만, 따로 링크를 남기지는 않는다.\n12월 크리스마스\n12월 크리스마스를 보냈다. 좋은 사람을 만나 좋은 곳에서 시간을 보내고 왔다.\n추운 날 목도리를 매고, 대학로의 극장을 찾았다.\n21.12.24. 쉬어매드니스\n쉬어매드니스는 참여형 추리극으로 관객이 사건을 보고 투표를 통해 범인을 밝혀나간다. 앞은 조금 지루할 수 있지만, 관객 참여가 시작되면 분위기가 바뀐다. 생각보다 관객 참여도 굉장히 좋았다. 나는 알리바이가 나온 배우님께 잘 들어가시라고 인사했다가 2층 인사남으로 찍히기도 했다.\n호텔은 명동으로 예약했고, 저녁은 매드포갈릭에서 먹었다.\n21.12.24. 칭찬왕 와인\n23일인 이브 전날 회사에서 farewell 파티가 있었는데, 이때 칭찬왕 선발대회의 2등으로 뽑혀 부상으로 샴페인을 받았었다.\n저녁을 먹고 돌아와 마신 와인도 굉장히 만족스러웠다.\n21.12.25. 조식\n아침은 조식을 먹으러 갔다. 코로나 여파로 뷔페식보다는 준비된 요리가 나왔고, 아메리칸 브랙퍼스트라는 이름에 맞게 적당한 식사가 나왔다.\n올해는 감정적으로 굉장히 유동적이었던 만큼, 9월의 여행과 크리스마스의 휴식이 더 달콤했던 것 같다.\n많은 일이 있던 21년도였다. 코로나로 비대면 생활이 이어지면서 20년도, 21년도의 경계가 모호했다고 느꼈다.\n하지만 이렇게 정리해보고 나니 꼭 그렇지만도 않은 것 같다. 나는 20년도와 21년도에 다른 사람이었고, 내년에 또 다른 사람일 것 같다. 무조건 긍정적으로 나아지는 것도 아니고, 후회도 여전히 있을 것이다.\n그렇다고 잘못되었다고 생각하진 않는다.\n내년엔 그저 좀 더 마음 편하게 먹고, 할 수 있는 일을 하며 더 만족하며 살아야겠다.\n","permalink":"https://revsic.github.io/blog/on2021/","tags":["Writing","2021th"],"title":"On 2021"},{"categories":["Bayesian"],"contents":" Variational Diffusion Models, Kingma et al., 2021, arXiv:2107.00630 Keyword: DDPM, Variational Lower Bounds Problem: Unstable noise scheduling, finite step diffusion process. Solution: Continuous-time diffusion process, joint training of noise scheduler. Benefits: Improved theoretical model understanding, faster optimization, better perceptual quality. Contribution: Simplifying model expression with variational lower bounds in terms of SNR. Introduction\n최근 Diffusion 모델은 이미지, 오디오 등 생성 분야에서 높은 perceptual quality를 보인다. [Ho et al., 2020]의 DDPM과 [Kong et al., 2020, Chen et al., 2020]의 DiffWave, WaveGrad의 경우, 일전 포스트에서 다룬 적이 있다. [post]\nVariational Diffusion Models, 이하 VDM에서는 이에 더 나아가 signal-to-noise ratio와 variational lower bounds를 통한 formulation의 단순화, infinite steps를 상정한 process의 유도와 noise scheduler의 joint training 가능성에 관한 이야기를 나눈다.\nDiffusion Models\n생성 모델의 가장 중요한 concept는 dataset과 관측치 $x$가 있을 때, marginal distribution $p(x)$를 추정하는 것이다. Diffusion 모델은 latent variable model로 latent의 hierarchy를 상정하고, variational lower bounds, 이하 VLB를 통해 marginal loglikelihood의 lower-bound를 maximize 하는 학습 방식을 취한다. 이러한 프로세스는 [Nielsen et al., 2020.]의 SurVAE Flows [post]에서 Stochastic transform을 활용한 flow의 일종으로 일반화되기도 한다.\nFigure 2: The directed graphical model considered in this work. (Ho et al., 2020)\n기존까지의 Diffusion 모델은 finite step의 markov chain을 가정하며, 매 transition 마다 noise를 더해가는 방식을 취한다. latent sequence $z_t$가 있다면, t=0 부터 t=1까지의 forward-time diffusion process를 정의할 수 있다.\n$$q(z_t|x) = \\mathcal N(\\alpha_t x, \\sigma_t^2 \\mathrm{I})$$\n이때 $\\alpha_t,\\ \\sigma_t^2: [0, 1] \\to \\mathbb R^+$의 실수 함수는 smooth하여 정의역에서 미분이 유한함을 가정한다. 또한 $\\alpha_t^2/\\sigma_t^2$의 비율이 단조 감소하여, t가 증가함에 따라 noise의 비율이 커지도록 구성한다. 이에 t=0에서 데이터 $x$에 가까울 것이고, t=1에서 gaussian noise에 가까워질 것이다.\n$0\\le s \\lt t \\lt u \\le 1$의 latent $z_s, z_t, z_u$와 joint distribution은 first-order Markov chain으로 가정하여 $q(z_u|z_t, z_s) = q(z_u|z_t)$를 상정한다. 이에 따른 conditional distribution은 다음과 같이 표기할 수 있다.\n$$q(z_t|z_s) = \\mathcal N(\\alpha_{t|s}z_s, \\sigma^2_{t|s}\\mathrm I), \\ \\ \\mathrm{where} \\ \\alpha_{t|s} = \\alpha_t / \\alpha_s \\ \\mathrm{and} \\ \\sigma^2_{t|s} = \\sigma^2_t - \\alpha^2_{t|s}\\sigma^2_s$$\nreverse time process의 경우에는 다음과 같다.\n$$q(z_s|z_t, x) = \\mathcal N(\\mu_Q(z_t, x; s, t), \\sigma^2_{Q, s, t}\\mathrm I) \\ \\ \\mathrm{with} \\ \\sigma^2_{Q, s, t} = \\sigma^2_{t|s}\\sigma^2_s/\\sigma^2_t \\\\ \\mathrm{and} \\ \\ \\mu_Q(z_t, x; s, t) = \\frac{1}{\\alpha_{t|s}}(z_t + \\sigma^2_{t|s}\\nabla_{z_t}\\log q(z_t|x)) = \\frac{\\alpha_{t|s}\\sigma^2_s}{\\sigma_t^2}z_t + \\frac{\\alpha_s\\sigma^2_{t|s}}{\\sigma_t^2}x$$\nReverse time process as Generative model\nDiffusion model은 reverse time process를 근사하는 방식의 생성 모델이며, 위 formulation에서 data 부분을 denoising model $\\hat x_\\theta(z_t, t)$로 대체하게 된다.\n$$p(z_s|z_t) = q(z_s|z_t, x = \\hat x_\\theta(z_t; t)) = \\mathcal N(z_s; \\mu_\\theta(z_t; s, t), \\sigma^2_{Q, s, t}\\mathrm{I})$$\n이에 따라 네트워크는 $\\mu_\\theta(z_t; s, t) \\approx \\mu_Q(z_t, x; s, t)$의 근사를 목표로 하게 된다.\n$$\\mu_\\theta(z_t; s, t) = \\frac{\\alpha_{t|s}\\sigma^2_s}{\\sigma^2_t}z_t + \\frac{\\alpha_s\\sigma^2_{t|s}}{\\sigma^2_t}\\hat x_\\theta(z_t; t) = \\frac{1}{\\alpha_{t|s}}z_t - \\frac{\\sigma^2_{t|s}}{\\alpha_{t|s}\\sigma_t}\\hat\\epsilon_\\theta(z_t; t) = \\frac{1}{\\alpha_{t|s}}z_t + \\frac{\\sigma^2_{t|s}}{\\alpha_{t|s}}s_\\theta(z_t; t)$$\n이는 model의 관점에 따라 3가지의 해석이 가능하다.\n$z_t$의 noised data로부터 원본을 복원하는 denoising model $\\hat x_\\theta(z_t; t)$ $z_t$에 포함된 noise를 추정하는 noise estimation model $\\epsilon_\\theta(z_t; t) = (z_t - \\alpha_t\\hat x_\\theta(z_t; t)) / \\sigma_t$ gradient를 추정하는 score matching model $s_\\theta(z_t; t) = (\\alpha_t \\hat x_\\theta(z_t; t) - z_t)\\sigma^2_t$ 3번의 경우 optimal model이 실제 scores를 추정하여, $s^*(z_t; t) = \\nabla_z\\log q(z_t)$, reverse time process의 최초 formulation과 일치해진다.\nVDM은 DDPM에서 제안한 noise estimation objective를 취할 것이고, 편의상 formulation은 denoising model을 상정할 것이다.\nRelation between prior works\n기존의 Diffusion model은 기본적으로 finite step T를 상정하므로, 위 formulation에서 segment size $\\tau = 1 / T$를 잡고, [0, 1]의 범위를 T개의 segment로 discretize한 형태로 볼 수 있다. 다음은 diffusion 모델에서 상정하는 marginal likelihood이다.\n$$p(x) = \\int_z p(x|z_0)\\left(\\prod^T_{i=1}p(z_{s(i)}|z_{t(i)})\\right)p(z_1) \\\\ \\mathrm{where} \\ \\ s(i) = (i - 1) / T, \\ t(i) = i / T$$\n각각의 diffusion 모델은 $\\alpha_t, \\sigma_t$를 적절히 구성하여 $q(z_1|x) \\approx \\mathcal N(z_1; 0, \\mathrm{I})$의 standard gaussian과 근사히 둔다. 마찬가지로 initial latent와 데이터의 reconstruction을 위해 $\\sigma_0$ 대비 $\\alpha_0$의 크기를 키움으로써 true distribution에 가깝게 근사하도록 구성한다.\nSignal-to-noise ratio\n위의 가정에서 중요한 점은 [$\\sigma_t$ 대비 $\\alpha_t$의 비율]을 적절히 가정함으로써 $p(z_1)$은 standard gaussian에, $p(z_0)$는 data distribution에 근사하고자 한다는 점이다.\n이때 $z_t = \\alpha_t x + \\sigma_t\\epsilon$에서 $\\alpha_t$는 실제 신호의 비, $\\sigma_t$는 noise의 비로, [$\\sigma_t$ 대비 $\\alpha_t$의 비율]은 신호 대 잡음의 비율이라 볼 수 있고, 이를 SNR, signal-to-noise ratio라고 한다.\n$$\\mathrm{SNR}(t) = \\alpha_t^2/\\sigma^2_t$$\n이 중 DDPM에서는 $\\alpha_t = \\sqrt{1 - \\sigma^2_t}$를 상정하여 variance-preserving diffusion process를 가정한다. 일부 모델에서는 $\\alpha_t=1$의 상수로 잡고 $\\sigma_t$를 늘리는 variance-exploding diffusion process를 상정하기도 한다. 이는 SNR(t)로도 재작성될 수 있다.\n$$\\alpha^2_t = \\mathrm{SNR}(t) / (1 + \\mathrm{SNR}(t)), \\ \\ \\sigma^2_t = 1 / (1 + \\mathrm{SNR}(t))$$\n일전의 가정에 따라 diffusion 모델에서 SNR 함수는 단조 감소 함수가 된다. 기존까지 모델에서는 이 SNR 함수가 well-engineered 함수로 가정되었다면, VDM에서는 SNR을 trainable한 component로 가정할 것이다.\nVariational Lower Bounds\nDDPM에서는 VLB를 통해 diffusion process로부터 KL-divergence 기반의 objective를 구성한다. 이때 $\\mathcal L_T(x)$는 diffusion loss이다.\n$$-\\log p(x) \\le D_\\mathrm{KL}(q(z_1|x)||p(z_1)) + \\mathrm E_{q(z_0|x)}[-\\log p(x|z_0)] + \\mathcal L_T(x) \\\\ \\mathcal L_T(x) = \\sum^T_{i=1}\\mathbb E_{q(z_{t(i)}|x)}D_\\mathrm{KL}[q(z_{s(i)}|z_{t(i)}, x)||p(z_{s(i)}|z_{t(i)})]$$\n그리고 이는 DDPM에서 weighted noise estimation loss의 형태로 reparametrized된다.\n$$\\mathcal L_{\\mathrm{simple}}(x) = \\mathbb E_{\\epsilon\\sim p(\\epsilon)}[||\\epsilon - \\hat\\epsilon_\\theta(\\alpha_t x + \\sigma_t \\epsilon; t)||_2^2]$$\nVDM에서는 denoising model을 formulation으로 활용한다.\n$$\\mathcal L_T(x) = \\frac{1}{2}\\mathbb E_{\\epsilon \\sim \\mathcal N(0, \\mathrm{I}), i \\sim U\\{1, T\\}}\\left[\\frac{(\\mathrm{SNR}(s) - \\mathrm{SNR}(t))}{1/T}||x - \\hat x_\\theta(z_t; t)||^2_2\\right]$$\nVariational Diffusion Models\nVDM의 contribution은 다음과 같다.\n$T \\to \\infty$를 상정하여 continuous-time loss를 유도한다. noise scheduler에 continuous-time loss가 invariant 함을 보인다. noise scheduler를 학습 가능한 네트워크로 구성하고, objective를 제안한다. Fourier feature를 통해 finer-scale에서의 perceptual quality를 높였다. 아래에서는 이에 대해 하나씩 풀어본다.\nWhy continuous time\n이전 실험들에서는 diffusion steps가 많아질수록 학습이 안정화되고 perceptual quality가 높아짐을 실험적으로 확인할 수 있었다.\n$$\\mathcal L_{2T}(x) - \\mathcal L_T(x) = \\mathbb E_{t, \\epsilon}\\left[c(t\u0026rsquo;)(||x - \\hat x _\\theta(z _{t\u0026rsquo;}; t\u0026rsquo;)||^2_2 - ||x - \\hat x _\\theta(z_t; t)||^2_2) \\right] \\\\ \\mathrm{where} \\ \\ t\u0026rsquo; = t - \\frac{1}{2T}, \\ \\ c(t) = \\mathrm{SNR}(t\u0026rsquo; - \\frac{1}{2T}) - \\mathrm{SNR}(t\u0026rsquo;)$$\ndiffusion step이 다른 두 loss를 빼게 되면, $t\u0026rsquo; \u0026lt; t$이므로 $z_{t\u0026rsquo;}$이 상대적으로 원본에 가까운 latent이고, $\\hat x_\\theta$가 충분히 학습된 모델이라면 원본 복원이 쉬운 latent 쪽의 loss가 작게 구성될 것이다.\n따라서 거의 항상 $\\mathcal L_{2T}(x) - \\mathcal L_T(x) \u0026lt; 0$을 상정할 수 있고, diffusion steps가 늘어날수록 VLB를 통해 더 높은 likelihood lower-bounds를 추정할 수 있게 된다.\nVDM에서는 $T\\to\\infty$의 극한을 취해 VLB의 하한을 높이고자 한다. 이렇게 되면 segment size $\\tau = 1 / T$는 0에 가까워지고, continuous time에 대한 loss로 취급할 수 있다. 그리고 실제로 이러한 concept가 perceptual quality의 향상에도 영향을 끼쳤음을 보였다.\nContinuous-time loss\n$T\\to\\infty$와 $\\tau = 1 / T\\to 0$를 상정한다면, $\\mathcal L_\\infty(x)$는 다음으로 유도할 수 있다.\n$$\\begin{align*} \\lim_{T\\to\\infty}\\mathcal L_T(x) \u0026amp;= \\lim_{T\\to\\infty}\\frac{1}{2}\\mathbb E_{\\epsilon\\sim\\mathcal N(0, \\mathrm{I}), i\\sim U\\{1, T\\}}\\left[\\frac{(\\mathrm{SNR}(s) - \\mathrm{SNR}(t))}{1/T}||(x - \\hat x_\\theta(z_t; t)||^2_2\\right]\\\\ \u0026amp;= \\lim_{T\\to\\infty}\\frac{1}{2}\\mathbb E_{\\epsilon\\sim\\mathcal N(0, \\mathrm{I}), i\\sim U\\{1, T\\}}\\left[\\frac{\\mathrm{SNR}(t - \\tau) - \\mathrm{SNR}(t)}{\\tau}||x - \\hat x_\\theta(z_t; t)||^2_2\\right] \\\\ \u0026amp;= -\\frac{1}{2}\\mathbb E_{\\epsilon\\sim\\mathcal N(0, \\mathrm{I}), t\\sim\\mathcal U(0, 1)}\\left[\\frac{d\\mathrm{SNR}(t)}{dt}||x - \\hat x_\\theta(z_t; t)||^2_2\\right] \\end{align*}$$\nepsilon estimation의 관점에서는 다음과 같이 쓸 수 있다.\n$$\\mathcal L_\\infty(x) = -\\frac{1}{2}\\mathbb E_{\\epsilon\\sim\\mathcal N(0, \\mathrm{I}), t\\sim\\mathcal U(0, 1)}\\left[\\log\\mathrm{SNR\u0026rsquo;}(t)||\\epsilon - \\hat\\epsilon_\\theta(z_t; t)||^2_2\\right]$$\n이 때 $\\log\\mathrm{SNR}\u0026rsquo;(t) = d\\log[\\mathrm{SNR}(t)]/dt = \\mathrm{SNR}\u0026rsquo;(t)/\\mathrm{SNR}(t)$이다.\nInvariance to the noise schedule in continuous time\nVDM은 continuous-time loss의 변수 t를 $v = \\mathrm{SNR}(t)$의 snr변수로 reparametrize하여 관찰한다. SNR이 단조 감수이므로 $dv = \\mathrm{SNR}\u0026rsquo;(t)dt$에 따라 치환하면 다음과 같다.\n$$\\begin{align*} \\mathcal L_\\infty(x) \u0026amp;= -\\frac{1}{2}\\mathbb E_{\\epsilon\\sim\\mathcal N(0, \\mathrm{I}), t\\sim\\mathcal U(0, 1)}\\left[\\mathrm{SNR}\u0026rsquo;(t)||x - \\hat x_\\theta(z_t; t)||^2_2\\right] \\\\ \u0026amp;= -\\frac{1}{2}\\mathbb E_{\\epsilon \\sim\\mathcal N(0, \\mathrm{I})}\\int_0^1 \\mathrm{SNR}\u0026rsquo;(t)||x - \\hat x_\\theta(z_t; t)||^2_2dt \\\\ \u0026amp;= \\frac{1}{2}\\mathbb E_{\\epsilon\\sim\\mathcal N(0, \\mathrm{I})}\\int_\\mathrm{SNR_{min}}^\\mathrm{SNR_{max}}||x - \\hat x_\\theta(z_v, v)||_2^2dv \\\\ \\mathrm{where} \\ \u0026amp;\\mathrm{SNR _{min}} = \\mathrm{SNR}(1), \\mathrm{SNR _{max}} = \\mathrm{SNR}(0) \\\\ \u0026amp;z_v = z _{\\mathrm{SNR}^{-1}(v)}, \\hat x _\\theta(z, v) = \\hat x _\\theta(z, \\mathrm{SNR}^{-1}(v)) \\end{align*} $$\n이 식에서 중요한 점은 $\\mathcal L_\\infty$를 결정하는 요소가 양단점인 $\\mathrm{SNR_{min}}$과 $\\mathrm{SNR_{max}}$ 뿐이란 것이고, SNR 함수가 어떻게 생겼는지와는 무관하다는 점이다. 즉 SNR의 양단이 같은 두 continuous-time loss는 equivalence임을 알 수 있다.\n또한 $v = \\alpha^2_v / \\sigma^2_v$에 따라 $\\sigma_v = \\alpha_v / \\sqrt v$로 정리할 수 있고, $z_v = \\alpha_v x + \\sigma_v \\epsilon = \\alpha_v(x + \\epsilon / \\sqrt v)$로 고정된 v에 대해 $\\alpha$와 $\\sigma$의 변인을 축약할 수 있다. 이는 서로 다른 variance policy에 대해 rescale 관계로 표현할 수 있다는 점이고, $z^A_v = (\\alpha^A_v / \\alpha^B_v)z^B_v$, 이에 따라 $\\hat x^B_\\theta(z^B_v, v) = \\hat x^A_\\theta((\\alpha^A_v/\\alpha^B_v)z^B_v, v)$의 model equivalence도 구성할 수 있다.\nWeighted continuous-time loss\nDDPM에서는 이를 noise estimation loss의 형태로 바꾸면서 reweighting을 진행했고, 이는 continuous-time loss에서도 적용할 수 있다.\n$$\\mathcal L_\\infty(x, w) = \\frac{1}{2}\\mathbb E_{\\epsilon \\sim \\mathcal N(0, \\mathrm{I})}\\int^\\mathrm{SNR_{max}}_\\mathrm{SNR _{min}} w(v)||x - \\hat x _\\theta(z _v, v)||^2 _2dv$$\nVLB는 아니지만 noisier data를 강조하는 등의 policy를 통해 실제 FID, IS 등 perceptual quality를 측정하는 metric에서 때에 따라 성과를 보이기도 한다.\nMonte-carlo estimation\n하지만 실상 적분을 하는 것은 intractable 하기 때문에 샘플링을 통한 estimation이 필요하다. 이에 VLB objective를 단순화하고, sampling과 batch stats를 활용한 monte-carlo estimation을 시행한다.\n$$\\mathcal L^{MC}_\\infty(x, w, \\gamma) = \\frac{1}{2}\\gamma\u0026rsquo;(t)w(\\gamma(t))||\\epsilon - \\hat\\epsilon _\\theta(z_t; \\gamma(t))||^2_2$$\n이때 $\\gamma$는 noise scheduler로 $\\gamma(t) = -\\log\\mathrm{SNR}(t) = \\log[\\sigma^2_t/\\alpha^2_t]$를 상정하고, $z_t = \\alpha_t x + \\sigma_t\\epsilon$, $\\epsilon \\sim \\mathcal N(0, \\mathrm{I}), t \\sim \\mathcal U(0, 1)$의 샘플링을 진행한다. 여기서는 reweighting 함수는 $w(\\cdot) = 1$의 상수 함수로 가정한다.\n또한 VDM은 보다 효율적인 시간축 샘플링을 위해 최초 시점 $u_0 \\sim \\mathcal U(0, 1)$을 잡고, batch size k에 대해 $t_i = \\mathrm{mod}(u_0 + i/k, 1)$의 선형 보간 방식을 취한다. 이렇게 하는 것이 [0, 1] 범주에서 더 uniform하게 분포한 시간점들을 샘플링 할 수 있고, 실제로 MC의 분산을 줄일 수 있었다고 한다.\nLearning noise scheduler\n기존까지의 모델들이 고정된 SNR 함수를 활용했다면, VDM은 파라미터 $\\eta$를 통해 학습 가능한 SNR 함수 $\\mathrm{SNR}(t) = \\exp(-\\gamma_\\eta(t))$를 상정한다. 이는 SNR 함수가 단조 감소 함수이기 때문에 $\\gamma_\\eta(t) = -\\log\\mathrm{SNR}(t)$로 두어 단조 증가 함수의 꼴로 네트워크를 모델링 하기 위함이다.\n실제로 VDM에서 제안하는 learnable noise scheduler는 다음과 같다.\n# t: [B]\rl1 = Linear(1, 1)(t)\rl2 = Linear(1, 1024)(l1)\rl3 = Linear(1024, 1)(sigmoid(l2))\rv = l1 + l3 여기서 projection weight가 모두 양수라면 t가 0에서 1로 증가함에 따라 $\\gamma_\\eta(t) = -\\log\\mathrm{SNR}(t)$도 단조 증가 하는 것이 보장된다.\n하지만 이렇게 학습된 noise scheduler는 실상 양단점을 제외하면 continuous-time loss에 영향을 미치지 않음을 앞서 보였다. 따라서 VDM은 noise scheduler 학습의 목적성을 다른 방향으로 잡는다.\nVDM은 Monte-carlo estimation의 분산을 줄이는 objective를 통해 $\\gamma$를 학습하며, $\\mathbb E[\\mathcal L^{MC} _\\infty(x, w, \\gamma)^2] = \\mathcal L _\\infty(x, w)^2 + \\mathrm{Var}[\\mathcal L^{MC} _\\infty(x, w, \\gamma)]$의 첫 번째 term $\\mathcal L _\\infty(x, w)^2$은 $\\eta$와 무관하므로 loss 제곱을 줄이는 방향으로 학습한다.\n$$\\mathbb E[\\nabla _\\eta \\mathcal L^{MC} _\\infty(x, w, \\gamma _\\eta)^2] = \\nabla _\\eta\\mathrm{Var}[\\mathcal L^{MC} _\\infty(x, w, \\gamma _\\eta)]$$\n이 경우 역전파를 두 번 해야 하는 문제가 있으며, 이를 효율적으로 처리하기 위해 $\\gamma$ 함수 이전에 역전파 함수를 hooking하는 방식을 제안한다.\n$$\\frac{d}{d\\eta}[\\mathcal L^{MC}_\\infty(x, \\gamma _\\eta)^2]=2\\frac{d}{d\\mathrm{SNR}}[\\mathcal L^{MC} _\\infty(x, \\mathrm{SNR})]\\odot\\mathcal L^{MC} _\\infty(x, \\mathrm{SNR})\\frac{d}{d\\eta}[\\mathrm{SNR}(\\eta)]$$\n앞선 식에서 $2\\mathcal L^{MC} _\\infty(x, \\mathrm{SNR})$를 제외하면 기존의 역전파 방식과 일치하므로, hooking을 통해 gradient에 loss를 곱하는 방식이다. 이 경우 불필요한 연산을 줄일 수 있다.\n이런 식으로 분산을 조절하는 방식은 실제로 학습 속도를 높이는데 도움을 주었다고 한다.\nFourier features\nVDM에서는 finer detail을 위해 fourier feature를 denoising model의 입력에 concat하여 넘겼다. 실제로 이 접근은 high frequency detail에 도움을 주었다고 한다. $n\\in\\{7, 8\\}$일 때 다음을 상정한다.\n$$f^n_{i, j, k} = \\sin(z_{i, j, k}2^n\\pi), \\ \\ g^n_{i, j, k} = \\cos(z_{i, j, k}2^n\\pi)$$\nExperiments\nTable 1: Summary of our findings for density modeling tasks. (Kingma et al., 2021)\n다음은 T에 따른 BPD이다. 실제로 train과 eval의 샘플링 수 모두에서 T가 증가할 수록 BPD가 줄어드는 것을 확인할 수 있었다.\nFigure 4: Our learned continuous-time variance-minimizing noise schedule SNR(t) for CIFAR-10, (Kingma et al., 2021)\nDiscussion\nContribution과 글의 전개가 무척 깔끔했다. Diffusion의 소개와 formulation 방식에 따른 해석 가능성을 정리하고, 품질 향상을 위한 지점으로 유한한 timestep을 상정, continuous-time으로 확장과 MCMC의 안정성 확보를 위한 learnable noise scheduler까지 문단 문단이 꽉 찬 느낌이었다.\nVDM을 활용해 DiffWave를 개선한 코드를 개인적으로 작성해 보았다. 아직 결과가 나오기엔 시간이 필요하지만, 좋은 결과를 기대하고 있다.\nrevsic/jax-variational-diffwave: Jax/Flax implementaton of Variational-DiffWave. Reference\n[1] Ho, J., Jain, A. and Abbeel, P. Denoising Diffusion Probabilistic Models. In NeurIPS 2020. [2] Kong, Z., Ping, W., Zhao, K. and Catanzaro, B. DiffWave: A Versatile Diffusion Model for Audio Synthesis. In ICLR 2021. [3] Chen, N., Zhang, Y., Zen, H., Weiss, R. J., Norouzi, M. and Chan, W. WaveGrad: Estimating Gradients for Waveform Generation. [4] Kingma, D. P., Salimans, T., Poole, B. and Ho, J. Variational Diffusion Models.\n","permalink":"https://revsic.github.io/blog/vdm/","tags":["Machine Learning","Deep Learning","Generative","Diffusion","DDPM","Variational Lower Bounds","VLB","Variational Diffusion Models"],"title":"Variational Diffusion Models"},{"categories":["Bayesian"],"contents":" SurVAE Flows: Surjections to Bridge the Gap between VAEs and Flows, Nielsen et al. In NeuRIPS 2020, arXiv. Keyword: Bayesian, Normalizing Flow, SurVAE Flows Problem: Specialized network architectures of normalizing flows Solution: Unifying several probabilistic models with surjections Benefits: Modulized, composable framework for probabilistic models Weakness or Future work: - Series: Normalizing flow\nNormalizing flow, Real NVP [link] Glow, Flow++ [link] ANF, VFlow [link] i-ResNet, CIF [link] SurVAE Flows [this] Normalizing Flows\nNormalizing flow, 이하 NF는 differentiable bijective를 활용하여 expressive한 확률 모델을 구성하는데 기여해 왔다. NF는 1) forward 2) inverse 3) likelihood의 크게 3가지 interface를 통해 composable 하고 modular 한 형태로 구성되며, Rezende and Mohamed, 2015[1]를 시작으로 꾸준히 발전해 왔다.\n이 과정에서 NF의 여러 가지 문제가 발견되었고, 그중 대표적으로 dimensionality problem은 ANF[5], VFlow[6]에서 augmentation을 도입하며 해결, misspecified prior의 문제는 CIF[7]에서 continuous index를 도입함으로써 해결하고자 했다.\n그 외의 확률 모델로는 VAE와 GAN 정도가 대표적이며, VAE의 경우에는 ANF[5]에서 일반화하고자 하는 시도가 있었다.\n이번에 소개하고자 하는 논문은 여러 확률 모델을 unifying 할 수 있는 composable하고 modular한 framework를 구성할 수 있는가에 대한 물음에서 시작한다. 그를 위해 저자들은 SurVAE Flows라는 framework를 제안하며, 여러 확률 모델을 unifying 하면서도 max pooling, absolute, sorting, stochastic permutation 등을 NF에 접목할 수 있게 구성하여, 더욱 expressive한 확률 모델 구성이 가능함을 보일 것이다.\nPreliminaries\n$x\\in\\mathcal X, \\ z \\in \\mathcal Z$의 두 개 변수와 각각의 prior distribution $x \\sim p(x), \\ z \\sim p(z)$을 상정한다. 이때 deterministic mapping $f: \\mathcal Z \\to \\mathcal X$가 bijective이기 위해서는 surjective하고 injective 해야 한다.\nsurjective: $\\forall x \\in \\mathcal X, \\exists z \\in \\mathcal Z: \\ x = f(z)$ injective: $\\forall z_1, z_2 \\in \\mathcal Z, \\ f(z_1) = f(z_2) \\Rightarrow z_1 = z_2$ 만약 mapping이 deterministic 하지 않다면, stochastic mapping이라 하고 $x \\sim p(x|z)$로 표기한다.\nNF는 기본적으로 bijective를 통한 change of variables $p(x) = p(z)|\\det \\nabla_x f^{-1}(x)|$를 근간으로 한다. VAE의 경우에는 stochastic transform을 차용하여 generative process $p(x) = p(z)p(x|z)$를 구성하고, variational posterior $z\\sim q(z|x)$를 통해 likelihood의 lower bound $\\mathbb E_{z\\sim q(z|x)}\\log [p(x, z)/q(z|x)]$ 를 추정한다.\nUnifying Stochastic Transform\n기본적으로 NF는 1) forward transform $f: \\mathcal Z \\to \\mathcal X$ 2) inverse transform $f^{-1}: \\mathcal X \\to \\mathcal Z$ 3) likelihood의 3가지 interface로 구성한다. SurVAE Flows[8]에서는 stochastic transform에 대해서도 이에 맞게 구성할 수 있도록 framework를 확장한다.\nForward Transform conditional distribution $x\\sim p(x|z)$를 상정한다. deterministic mapping에 대해서는 dirac delta를 통해 구성한다. $p(x|z) = \\delta(x - f(z))$\nInverse Transform 마찬가지로 deterministic mapping에 대해서는 $p(z|x) = \\delta(z - f^{-1}(x))$를 상정한다. 반면에 stochastic mapping에 대해서는 $p(z|x)$의 연산이 intractable 하므로 variational $q(z|x)$를 상정하고 lower bound를 추정하는 식으로 접근한다.\nLikelihood deterministic map과 stochastic map의 likelihood 구성은 다음과 같다.\n$$\\log p(x) = \\log p(z) + \\log|\\det J|, \\ \\ z = f^{-1}(x)\\\\ \\log p(x) = \\log p(z) + \\log \\frac{p(x|z)}{q(z|x)} + \\mathbb D_\\mathrm{KL}[q(z|x)||p(z|x)], \\ \\ z \\sim q(z|x)$$\n이때 $|\\det J|$는 $|\\det \\nabla_x f^{-1}(x)|$이다.\n여기서 중요한 것은 framework를 확장하는 과정에서 deterministic transform의 분포를 Dirac delta $\\delta(\\cdot)$를 통해 구성하였고, 이를 기반으로 한 ELBO가 NF의 change of variables formulation과 같아진다는 것이다.\n$$p(x|z) = \\delta(x - f(z)), \\ \\ p(z|x) = \\delta(z - f^{-1}(x)) \\\\ \\begin{align*}\\Rightarrow \\log p(x) \u0026amp;= \\log p(z) + \\log|\\det J| \\\\ \u0026amp;= \\log p(z) + \\log\\frac{p(x|z)}{q(z|x)}\\end{align*}\\\\ \\mathrm{where} \\ \\ q(z|x) = p(z|x)$$\n정리하면 Change of variables의 전개는 ELBO에서 deriving 할 수 있고, VAE와 NF는 동일한 formulation을 통해 구성되는 하나의 확률 모형이었단 것이다. 이에 따라 둘은 forward와 inverse를 모두 stochastic transform으로 상정한 경우(VAE)와 모두 deterministic transform으로 상정한 경우(NF)의 mapping 방식에 따른 special case가 된다.\nVAE와 NF가 precise 한 상관관계를 가진다는 것이 증명된 지점이다.\nTheorem. Change of variables formula는 ELBO에서 deriving 가능하다.\npf. Dirac $\\delta$-function을 통해 다음을 얻을 수 있다.\n$$\\int\\delta(g(z))f(g(z))\\left|\\det\\frac{\\partial g(z)}{\\partial z}\\right|dz = \\int\\delta(u)f(u)du, \\ \\ u = g(z) \\tag{1}$$ $$\\exists! z_0: g(z_0) = 0 \\Rightarrow \\delta(g(z)) = \\left|\\det\\frac{\\partial g(z)}{\\partial z}\\right|_{z=z_0}^{-1}\\delta(z-z_0) \\tag{2}$$\n(필자는 Eqn.1 좌항의 determinant term을 우항으로 옮기고, delta 함수가 trigging 되는 시점인 $z_0$의 determinant 값이 실체화되는 방식으로 이해함, dirac delta의 적분은 정의상 1이므로)\n위 유도는 g가 미분가능하고, f는 compact support를 가지며, root는 unique하고, jacobian은 가역 행렬임을 가정한다.\n$f: \\mathcal Z \\to \\mathcal X$가 $f$와 $f^{-1}$ 모두에서 미분가능일 때 (i.e. diffeomorphism), deterministic conditionals에 대해 다음의 유도가 가능하다.\n$$p(x|z) = \\delta(x - f(z)), \\ \\ p(z|x) = \\delta(z - f^{-1}(x)) \\tag{3}$$ $$p(x|z) = \\delta(z - f^{-1}(x))|\\det J| = p(z|x)|\\det J| \\tag{4}$$\n이때 jacobian은 $J^{-1} = \\left.\\partial f(z)/\\partial z\\right|_{z=f^{-1}(x)}$를 상정한다.\n또한 deterministic transform에 따른 true posterior $p(z|x)$를 알고 있으므로, $q(z|x) = p(z|x) = \\delta(z - f^{-1}(x))$에서 ELBO를 deriving 하면 다음과 같다.\n$$\\begin{align*}\\log p(x) \u0026amp;= \\mathbb E_{z\\sim q(z|x)}\\left[\\log p(z) + \\log\\frac{p(x|z)}{q(z|x)} + \\log\\frac{q(z|x)}{p(z|x)}\\right] \\\\ \u0026amp;= \\log p(z) + \\log|\\det J|\\end{align*}$$\n이 과정에서 두 likelihood의 tractable한 contribution은 $\\log[p(x|z)/q(z|x)] = \\log|\\det J|$에 따라 같아지고, variational posterior와 true posterior가 동치이므로 KL-term $\\log[q(z|x)/p(z|x)] = 0$으로 소거된다.\nLikelihood Contribution and Bound Gap\nSurVAE Flows[8]는 이렇게 unifying 된 framework의 likelihood 연산을 위해 전체 term을 likelihood contribution $\\mathcal V(x, z)$과 boundary gap $\\mathcal E(x, z)$으로 분리한다. expectation은 single monte carlo sample에 대한 evaluation으로 대체한다.\n$$\\log p(x) \\simeq \\log p(z) + \\mathcal V(x, z) + \\mathcal E(x, z), \\ \\ z \\sim q(z|x)$$\nlikelihood contribution은 전체 likelihood term 중에서 연산할 수 있고, 실제 gradient 기반의 optimization에 활용되는 부분이다. change of variables term $\\log|\\det J|$나 variational lower bound $\\log[p(x|z)/q(z|x)]$가 이에 해당한다.\nboundary gap은 lower bound estimation 과정에서 발생하는 true posterior와의 gap을 상정한다. VAE의 경우에는 $\\log[q(z|x)/p(z|x)]$의 variational gap이 존재하고, NF의 경우에는 true posterior를 그대로 사용 가능하므로 0으로 소거된다.\n이후 multiple layers에 대해서는 NF에서 compositional structure에 따라 각각의 log-determinant를 더해갔던 것처럼, stochastic map에 대해서도 동일하게 likelihood contribution을 더해가는 방식으로 일반화 가능할 것이다.\nAlgorithm 1: log-likelihood(x) (Nielsen et al., 2020)\nSurVAE Flows\n지금까지 framework 확장 과정에서 stochastic transform과 deterministic transform의 likelihood 연산 과정을 통합하고, 그를 위한 알고리즘을 구성해 보았다. 이 과정에서 NF는 forward, inverse가 모두 deterministic, VAE는 모두 stochastic 한 special case라는 것 또한 확인했다.\n그렇다면 forward는 deterministic, inverse는 stochastic 하거나, inverse는 deterministic, forward는 stochastic한 케이스도 존재 가능한 것인가에 대한 의문이 있을 수 있다.\n그리고 만약 위와 같은 구성이 가능하다면 bijective의 exact likelihood evaluation과 stochastic map의 dimension alternation 같은 이점들을 수집할 수 있는가에 대한 기대도 있을 것이다.\nSurVAE Flows[8]의 저자들은 surjective transform을 통해 bijective와 stochastic map 사이의 격차를 메꿔보고자 했다.\n우선 surjective이고 non-injective인 deterministic transform을 정의한다. 이는 이하 surjections 혹은 surjective transform으로 일컬을 것이다. 이렇게 surjections를 정의하게 되면 다수의 입력이 하나의 출력으로 매핑될 수 있고, 이 과정에서 inversion이 보장되지 않는다. 이에 저자들은 다음과 같은 interface를 구성한다.\nForward Transform bijective와 같이 dirac-delta를 통한 deterministic forward $p(x|z) = \\delta(x - f(z))$를 상정한다.\nInverse Transform bijective와 달리 surjective $f: \\mathcal Z \\to \\mathcal X$는 invertible 하지 않다. 이는 right inverse만 존재하고, left inverse는 존재하지 않기 때문이다. (i.e. $\\exists g: \\mathcal X \\to \\mathcal Z: \\ f\\circ g(x) = x \\ \\ \\forall x\\in \\mathcal X$)\nSurVAE Flows는 이에 stochastic right inverse를 inverse 대신 차용한다. $q(z|x)$의 stochastic posterior를 상정하고, $x$의 preimage 위에 support를 가지게 한다.\n이렇게 되면 위에서 언급한 forward는 deterministic, inverse는 stochastic 한 케이스가 된다. 이를 generative surjections라 하고, 반대로 $\\mathcal X \\to \\mathcal Z$ 방향에 surjections를 가정하면 forward는 stochastic, inverse는 deterministic 한 inference surjections가 된다.\nLikelihood Contribution continuous surjections에 대한 likelihood contribution term은 다음과 같다.\n$$\\mathbb E_{q(z|x)}\\left[\\log\\frac{p(x|z)}{q(z|x)}\\right], \\ \\mathrm{as} \\left\\{\\begin{matrix}\\begin{align*} \u0026amp;p(x|z) \\to \\delta(x - f(z)), \u0026amp; \\mathrm{for\\ gen.\\ surj} \\\\ \u0026amp;q(z|x) \\to \\delta(z - f^{-1}(x)), \u0026amp; \\mathrm{for\\ inf.\\ surj} \\end{align*}\\end{matrix}\\right.$$\ngenerative sujrections의 경우에는 stochastic posterior로 인해 likelihood의 lower bound를 추정해야 하지만, inference surjections의 경우에는 deterministic true posterior를 활용할 수 있으므로 exact likelihood evaluation이 가능하다.\n이에 SurVAE Flows에서는 forward/inverse의 두 가지 방향과 deterministic/stochastic의 두 가지 mapping 방식에 대해 총 4가지 composable building blocks를 구성할 수 있다.\nTable 1: Composable building blocks of SurVAE Flows (Nielsen et al., 2020)\nExamples\nTensor slicing $z = (z_1, z_2) \\in \\mathbb R^d$에 대해 slice $x = f(z) = z_1$을 상정하면, 이는 generative surjections이다. 우선 이에 따른 forward와 inverse의 stochastic transformation을 정의한다.\n$$p(x|z) = \\mathcal N(x|z_1, \\sigma^2I), \\ \\ q(z|x) = \\mathcal N(z_1|x, \\sigma^2I)q(z_2|x)$$\n이때 $\\sigma^2\\to 0$이면 $p(x|z) \\to \\delta(x - f(z))$의 deterministic transform으로 수렴하므로 likelihood contribution은 다음과 같아진다.\n$$\\mathcal V(x, z) = \\lim_{\\sigma^2\\to 0}\\mathbb E_{q(z|x)}\\left[\\log\\frac{p(x|z)}{q(z|x)}\\right] = \\mathbb E_{q(z_2|x)}[-\\log q(z_2|x)]$$\n그리고 이는 $q$의 entropy를 maximize 하는 방향으로 학습이 진행될 것이다. ANF[5]나 VFlow[6]에서 제안했던 augmentation과 동치이다.\n반대로 $x = (x_1, x_2) \\in \\mathbb R^d$에 대한 slice $z = f(x) = x_1$을 상정한다면, 다음과 같이 inference surjections가 정의될 것이고, likelihood contribution은 $p(x|z)$가 $z$로부터 나머지 $x_2$를 복원하기 위한 형태로 구성될 것이다.\n$$\\mathcal V(x, z) = \\mathbb E_{q(z|x)}\\left[\\log\\frac{p(x|z)}{q(z|x)}\\right] = \\mathbb E_{p(z|x)}[\\log p(x_2|z)]$$\nRounding rounding $x = \\lfloor z\\rfloor$를 상정하면, forward transform은 deterministic surjection으로 구성된다.\n$$p(x|z) = \\mathbb I(z \\in \\mathcal B(x)), \\ \\ \\mathcal B(x) = \\{x + u|u\\in [0, 1)^d\\}$$\ninverse를 variational posterior$q(z|x)$에 대한 stochastic transform으로 구성하면, Flow++[4]에서 언급되었던 variational dequantization과 동치가 된다.\n$$\\mathcal V(x, z) = \\mathbb E_{q(z|x)}[-\\log q(z|x)]$$\nAbsolute $z = |x|$의 절댓값 연산을 상정한다면 이는 inference surjections이고, sign s에 대한 bernoulli 분포를 다루는 방식으로 작동할 것이다.\n$$\\begin{align*}\u0026amp;p(x|z) = \\sum_{s\\in\\{-1, 1\\}}p(x|z, s)p(s|z) = \\sum_{s\\in\\{-1, 1\\}}\\delta(x - sz)p(s|z) \\\\\\ \u0026amp;q(z|x) = \\sum_{s\\in\\{-1, 1\\}}q(z|x, s)p(s|x) = \\sum_{s\\in\\{-1, 1\\}}\\delta(z - sx)\\delta_{x, \\mathrm{sign}(x)}\\end{align*}$$\nSurVAE Flows[8]는 그 외에도 flow framework에서 사용해볼 법한 몇 가지 layer를 더 제안한다. 이를 토대로 nonlinearities의 부재와 architecture의 constraint를 겪던 flow framework에 reasonable한 디자인을 추가할 수 있게 되었단 점에서 또 하나의 의의가 있을 것이다.\nConnection to previous works\nSurVAE Flows는 4가지 mapping 방식에 대한 generalized framework를 제안하면서 기존까지의 다양한 확률 모델과의 접점을 만들어 냈다.\nbijective를 통한 modeling 과정에서 dimensionality, discrete data, misspecified prior에 대한 여러 문제점이 제기되었었고, 이에 따른 individual solutions를 하나의 framework 내에서 구성할 수 있게 된 것이다.\nTable 3: SurVAE Flows as a unifying framework. (Nielsen et al., 2020)\nDiffusion[9]은 이전 post에서 다뤘던 주제로, inverse에 noise를 더해가는 diffusion steps를 두고, forward에서 denoising을 objective로 하는 모델을 구성하는 방식이다. forward와 inverse가 모두 stochastic 한 formulation으로 구성된다.\nDequantization의 경우에는 continuous flow를 discrete data에 모델링하는 과정에서 degenerate point에 density가 몰리는 현상을 방지하고자, rounding operation을 상정하고 variational posterior를 통한 dequantization을 구성하는 method이다. 이는 rounding에 대한 generative surjections으로 구성된다. (post: Glow, Flow++)\nANF[5]와 VFlow[6]는 dimensionality problem의 해결을 위해 channel axis에 부가적인 latent를 부여하는 augmentation을 제안한다. 이는 tensor slicing에 대한 generative surjections로 구성된다. 반대로 RealNVP[2]에서 제안한 multi-scale architecture는 연산의 효율성을 위해 각 resolution에 대한 latent를 slicing 함으로 inference surjection에 해당한다. (post: NF, RealNVP, ANF, VFlow)\nCIF[7]의 경우에는 misspecified prior를 활용한 상황에서의 real data fitting과 bi-Lipschitz constant에 대한 tradeoff를 보이며, 이에 대한 해결책으로 augmentation과 latent의 surjectivity를 통한 re-routing을 제안한다. 하지만 ANF[5], VFlow[6]와는 달리 hierarchy를 구성하므로 최종에서는 모든 latent를 사용하지 않고, re-routing에 해당하는 latent를 slicing 한다. (post: i-ResNet, CIF)\nExperiments\nFigure 4: Comparison of flows with and without absolute value surjections (Nielsen et al., 2020)\n가장 먼저 한 실험은 symmetric data에서 실제로 absolute value surjection이 유용한가에 대한 실험이다. 실제로 동일한 flow에 absolute surjections를 추가한 것만으로 bits/dim이 줄어든 것을 확인할 수 있다.\nFigure 5: Point cloud samples from permutation-invariant SurVAE Flows (Nielsen et al., 2020)\n두 번째 실험은 SpatialMNIST에 대한 실험이다. point cloud는 집합으로 permutation-invariant 한 특성을 가진다. SurVAE Flows에서는 sorting surjections나 stochastic permutation을 통해 입력에 순서 정보를 제거할 수 있다. 또한 stochastic permutation에 대해서는 coupling layer에 positional encoding을 사용하지 않는 transformer를 활용함으로서 permutation invariant 한 모델을 구성했다.\n실제로 PermuteFlow는 SortFlow에 비해 좋은 성능을 보였고, i.e. -5.30 vs -5.53 PPLL (per-point log-likelihood), 다른 non-autoregressive 모델에 비해서도 SOTA performance를 보였다.\nModeling image data with MaxPoolFlow (Nielsen et al., 2020)\n마지막은 이미지 데이터에 대해 max pooling을 활용하여 downsampling을 구성한 MaxPoolFlow이다. Baseline은 RealNVP[2]의 multi-scale architecture를 활용하였다.\n실험 결과 slicing surjection에 비해 maxpool이 더 높은 bits/dim를 보이긴 했으나, IS/FID 에서는 더 좋은 visual quality를 갖는다 평가받았다.\nDiscussion\n이로써 normalizing flow에 대해 기획했던 게시글을 모두 작성하였다.\nNF에 대한 소개와 연구 초기에 소개되었던 RealNVP 어떤 layer와 architecture를 구성할지에 대해 소개했던 Glow, Flow++ dimensionality problem에 대한 해결책을 제시한 ANF, VFlow residual network의 invertibility와 그 한계를 소개한 i-ResNet, CIF 마지막으로 모든 걸 unifying하고 NF의 새로운 지평을 연 SurVAE Flows\n시작은 SurVAE Flows[8]를 접한 뒤였다. 당시 NF에 관심이 있었고, surjection을 통해 기존까지의 확률 모델 전반을 통합한 논문은 굉장한 호기심으로 다가왔다.\n이를 위해 reference를 조사하고, 그렇게 하나둘 리뷰를 하던 중 연재물로써 NF의 글을 쓰고 다른 사람들과 공유할 수 있음 좋을 것 같다는 생각이 들었다.\n하지만 글을 잘 쓰는 편도 아니고, 거의 논문을 번역해둔 듯한 글에 큰 의미가 있을까 고민도 했던 것 같다.\n그래도 뭐라도 남겨두고, 한글로 되어 있음 참고할 사람은 참고할 수 있지 않을까 하는 생각이 들어 장장 5편의 NF 논문을 리뷰한 것 같다.\n공부하면서 flow처럼 문제 제기와 해결, 추상화와 통합이 자연스레 순차적으로 이루어진 분야는 처음 보았다. 굉장히 많은 양의 머신러닝/딥러닝 관련 논문이 쏟아져 나오는 요즘, 이 정도의 스토리 라인을 구성할 수 있다는 점에서도 연구자분들에 대한 큰 감사함을 느낀다.\n필자는 학부 휴학생 신분으로 음성 합성 연구를 시작하면서 연구는 어떻게 해야 하는지, 무엇을 만들어야 하는지에 대한 개념도 없이 일을 시작했던 것 같다. 그리고 1년 반, 2년 차가 되어가는 시점에서 flow를 공부한 것은 그 방향성을 잡는데에도 큰 도움을 준 것 같다.\n그 외에도 NF라는 주제가 가지는 다양한 발전 가능성과 현실 세계에서의 적용 가능성에 대해 긍정적으로 바라보고 있고, 다양한 분들이 이 글을 통해 조금이나마 도움을 받았음 좋겠다.\nReference\n[1] Rezende, D. J. and Mohamed, S. Variational inference with normalizing flows. In ICML 2015. [2] Dinh, L., Sohl-Dickstein, J. and Bengio, S. Density estimation using Real NVP. In ICLR 2017. [3] Kingma, D. P. and Dhariwal, P. Glow: Generative Flow with Invertible 1x1 Convolutions. In NIPS 2018. [4] Ho, J. et al. Flow++: Improving flow-based generative models with variational dequantization and architecture design. In ICML 2019. [5] Huang, C., Dinh, L. and Courville, A. Augmented Normalizing Flows: Bridging the Gap Between Generative Flows and Latent Variable models. 2020. [6] Chen, J., et al. VFlow: More Expressive Generative Flows with Variational Data Augmentation. In ICML 2020. [7] Cornish, R., Caterini, A., Deligiannidis, G., Doucet, A. Relaxing Bijectivity Constraints with Continuously Indexed Normalising Flows. In ICML 2020. [8] Nielsen, D., Jaini, P., Hoogeboom, E., Winther, O., Welling, M. SurVAE Flows: Surjections to Bridge the Gap between VAEs and Flows. In NeurIPS 2020. [9] Ho, J., Jain, A., Abbeel, P. Denoising Diffusion Probabilistic Models. In NeurIPS 2020. [10] Kingma, P, D. and Welling, M. Auto-Encoding Variational Bayes. In ICLR 2014.\n","permalink":"https://revsic.github.io/blog/survaeflow/","tags":["Machine Learning","Deep Learning","Bayesian","Normalizing Flow","SurVAE Flows"],"title":"SurVAE Flows"},{"categories":["Bayesian"],"contents":" Invertible Residual Networks, Behrmann et al. In ICML 2019, arXiv. Relaxing Bijectivity Constraints with Continuously Indexed Normalising Flows, Cornish et al. In ICML 2020, arXiv. Keyword: Bayesian, Normalizing Flow, i-ResNet, ResFlow, Invertibel ResNet, CIF, Continuously Index Flows. Problem: Bijective and misspecified prior, topological mismatch. Solution: Surjective, augmentation, hierarchical structure. Benefits: Correcting misspecified posterior. Weakness or Future work: Is Augmented Flow can correct misspecified prior? Series: Normalizing flow\nNormalizing flow, Real NVP [link] Glow, Flow++ [link] ANF, VFlow [link] i-ResNet, CIF [this] SurVAE Flows [link] Residual Network\nNeural network의 발전에 있어서 하나의 아키텍쳐로 여러 문제를 풀 수 있다는 것은 굉장한 이점으로 작용해 왔다. 하지만 근래에 들어서는 아키텍쳐의 발전이 domain-specific 하게 작용하고 있으며, 특히 VAE, Flow, GAN 등으로 나뉘어 발전한 generative task에서 이 점이 두드러진다.\n그 중 discriminative task와 generative task의 여러 architecture design은 서로 다른 방향성을 띄어 갔고, 다양한 tuning 방법론들이 등장하며 점점 그 구성은 복잡해져만 갔다.\n이에 저자들은 discriminative task와 generative task 모두에서 사용 가능한 어떤 universal architecture를 디자인하고자 했고, 그렇게 주목하게 된 구조가 invertible flow이다.\n이번 글에서는 residual network의 invertibility와 free-form jacobian의 연산에 관해 이야기하고, Lipschitz-constraint와 invertible flow의 관계성, 한계의 해결방안에 대해 알아본다.\nEnforcing Invertibility in ResNets\n$$x_{t+1} \\leftarrow x_t + g_{\\theta_t}(x_t) \\ \\ \\mathrm{where} \\ x_t \\in \\mathbb R^d$$\nresidual block은 입력과 연산의 결과를 더하는 방식으로 구성된다. 이에 invertibility를 부여하기 위해서는 $x_{t+1}$이 주어졌을 때, $x_t$를 연산해 낼 수 있어야 한다.\n$$x_t \\leftarrow x_{t+1} - g_{\\theta_t}(x_t)$$\nTheorem 1. (Sufficient condition for invertible ResNets). residual block은 Lipschitz-constant가 1보다 작을 때 invertible 하다.\n$$\\mathrm{Lip}(g_{\\theta_t}) \u0026lt; 1$$\nRemark. (Banach fixed point theorem)\ncomplete metric space $(X, d)$에서 $T: X \\to X$의 함수가 다음을 만족할 때 $T$를 contraction이라 한다.\n$$\\exists q \\in [0, 1) : d(T(x), T(y)) \\le qd(x, y) \\ \\forall x, y \\in X$$\nBanach fixed point theorem에 의해 contraction은 unique fixed point를 가지며, i.e. $\\exists ! x^* \\in X : T(x^) = x^$, 임의점 $x_0 \\in X$으로부터 iteration을 통해 fixed point $x^*$를 찾을 수 있다.\n$$\\{x_n = T(x_{n-1})\\}_{n\\ge 1} \\Rightarrow \\lim _{n\\to 1}{x_n} = x^*$$\npf.\nLipschitz-constant는 complete metric space $(X, d)$에서 어떤 함수 $T: X \\to X$에 대해 다음과 같이 정의한다.\n$$\\mathrm{Lip}(T) = \\inf \\{q: d(T(x), T(y)) \\le qd(x, y) \\ \\forall x, y \\in X\\}$$\n이때 residual block의 inverse 연산을 contraction으로 본다면, $\\mathrm{Lip}(x \\mapsto x_{t+1} - g_{\\theta_t}(x))$가 1보다 작아야 할 것이고, 이에 따라 unique fixed point $x^* = x_{t+1} - g_{\\theta_t}(x^*)$가 존재할 것이다. 그리고 이 값은 유일하므로, inverse solution과 $x_t = x^ *$의 unique fixed point가 동치가 된다.\n따라서 inverse 연산이 contraction이라면 fixed point iteration을 통해 이전 residual block의 출력값을 찾아낼 수 있고, l2-norm $||\\cdot||_2$과 euclidean distance $d(x, y) = ||x - y||_2$에 대해 Lipschitz-constant의 제약을 풀어내면 다음과 같다.\n$$\\begin{align*} \u0026amp;\\mathrm{Lip}(x \\mapsto x_{t+1} - g_{\\theta_t}(x)) \\\\ \u0026amp;= \\inf \\{q: d(x_{t+1} - g_{\\theta_t}(x), x_{t+1} - g_{\\theta_t}(y)) \\le qd(x, y) \\ \\forall x, y \\in X\\} \\\\ \u0026amp;= \\inf \\{q: ||(x_{t+1} - g_{\\theta_t}(x)) - (x_{t+1} - g_{\\theta_t}(y))||_2 \\le q||x - y||_2 \\ \\forall x, y \\in X\\} \\\\ \u0026amp;= \\inf \\{q: ||g _{\\theta_t}(x) - g _{\\theta_t}(y)||_2 \\le q||x - y||_2 \\ \\forall x, y \\in X\\} \\\\ \u0026amp;= \\inf \\{q: d(g _{\\theta_t}(x), g _{\\theta_t}(y)) \\le qd(x, y) \\ \\forall x, y \\in X\\} \\\\ \u0026amp;= \\mathrm{Lip}(g _{\\theta_t}) \\lt 1 \\end{align*}$$\n즉 $g_{\\theta_t}$의 Lipschitz-constant가 1보다 작을 때 residual block은 invertibility를 갖는다.\n또한 fixed point iteration은 exponential scale에 따라 수렴하게 되므로, Lipschitz-constant가 작아질수록 더 적은 연산으로 unique point를 찾아낼 수 있다.\n$$||x - x_n||_2 \\le \\frac{\\mathrm{Lip}(g)^n}{1 - \\mathrm{Lip}(g)}||x_1 - x_0||_2$$\nSatisfying the Lipschitz Constraint\ni-ResNet[1]에서는 residual block을 contractive nonlinearities (e.g. ReLU, ELU, tanh)와 convolution으로 구성한다.\nSN-GAN[3]에서는 정의에 따라 matrix A에 대한 spectral norm $\\sigma(\\cdot)$을 largest singular value of A로 연산하고, linear transform $g$의 Lipschitz norm $\\mathrm{Lip}(g) = ||g||_\\mathrm{Lip}$을 다음과 같이 보인다.\n$$||g||_\\mathrm{Lip} = \\sup_h \\sigma(\\nabla g(h)) = \\sup_h \\sigma(W) = \\sigma(W)$$\n이에 따라 convolution으로 구성된 residual block이 Lipschitz-constant를 만족하기 위해서는 각각의 convolutional weights에 spectral norm을 취해 1 이하로 둘 수 있어야 한다. contractive nonlinearities $\\phi$를 상정한다면 전개는 다음과 같다.\n$$\\mathrm{since} \\ ||g_1 \\circ g_2||_\\mathrm{Lip} \\le ||g_1|| _\\mathrm{Lip}||g_2|| _\\mathrm{Lip}, \\\\ ||W_2\\phi(W_1)|| _\\mathrm{Lip} \\le ||W_2|| _\\mathrm{Lip}||\\phi|| _\\mathrm{Lip}||W_1|| _\\mathrm{Lip} \\le ||W_2|| _\\mathrm{Lip}||W_1|| _\\mathrm{Lip} \\\\ \\Rightarrow \\mathrm{Lip}(g) \\le 1, \\ \\ \\mathrm{if} \\ ||W_i|| _\\mathrm{Lip} \\le 1$$\nSpectral norm은 power-iteration 방식으로 근사하여 취급한다.\nDeterminant of Free-form Jacobian\ninvertible resnet, 이하 i-ResNet[1]은 jacboian의 norm에 일정 constraint를 요구하지만, coupling layer와 같이 matrix의 form 자체에 제약을 걸지는 않는다. 따라서 기본적으로 determinant 연산까지 $\\mathcal O(d^3)$의 cubic complexity를 가정해야 하고, 이에 high-dimensional data에서는 intractable 하다는 문제를 가진다.\n이에 log-determinant term 자체를 효율적으로 근사하기 위한 방법론이 필요하다.\n우선 data $x$와 prior $z \\sim p_z(z)$에 대해 Lipschitz-constrained $F(x) = x + g(x)$를 상정한다. $F$는 invertible하고, $z = F(x)$로 둘 때 change of variables에 의한 likelihood 전개가 가능하다.\n$$\\ln p_x(x) = \\ln p_z(z) + \\ln|\\det J_F(x)|$$\n이때 eigen values $\\lambda_i$와 다음의 전개에 따라 determinants를 양수로 상정할 수 있다.\n$$\\begin{align*} \u0026amp; \\lambda_i(J_F) = \\lambda_i(J_g) + 1 \\land \\mathrm{Lip}(g) \u0026lt; 1 \\\\ \u0026amp; \\Rightarrow |\\lambda_i(J_g)| \u0026lt; 1 \\\\ \u0026amp; \\Rightarrow \\det J_F = \\Pi_i(\\lambda_i(J_g) + 1) \u0026gt; 0 \\end{align*}$$\n또한 non-singual matrix A에 대해 $\\ln\\det(A) = \\mathrm{tr}(\\ln(A))$ 이므로, trace of matrix logarithm의 power series에 의해 다음과 같은 전개가 가능하다.\n$$\\begin{align*} \\ln p_x(x) \u0026amp;= \\ln p_z(z) + \\mathrm{tr}(\\ln(I + J_g(x))) \\\\ \u0026amp;= \\ln p_z(z) + \\sum^\\infty_{k=1}(-1)^{k+1}\\frac{\\mathrm{tr}(J_g^k)}{k} \\end{align*}$$\n이에는 여전히 computational drawbacks가 존재하는데, 1) trace of jacobian을 square complexity로 상정하거나, d개 diagonal entry에 대해 g를 매번 연산하여 더해야 하고 2) matrix power가 필요하며 3) series가 무한하다는 것이다.\n이 중 1)은 automatic differentiation 과정에서 연산량을 줄일 수 있고, 2) matrix trace는 $v \\sim N(0, I)$를 통해 stochastic approximation이 가능하다고 한다.\n$$\\mathrm{tr}(A) = \\mathbb E_{p(v)}[v^TAv]$$\n지금까지는 unbiased estimation을 상정했지만, 3)의 해결을 위해 infinite series의 truncation이 불가피하고, approximation 과정에서 biased estimator로 변모한다.\nn-th truncation error는 다음에 의해 상한을 가진다.\n$$\\left|\\sum^\\infty_{k=n+1}(-1)^{k+1}\\frac{\\mathrm{tr}(J_g^k)}{k}\\right| \\le \\sum^\\infty_{k=n+1}\\left|\\frac{\\mathrm{tr}(J_g^k)}{k}\\right| \\le d\\sum^\\infty_{k=n+1}\\frac{\\mathrm{Lip}(g)^k}{k} \\\\ \\mathrm{since} \\ \\sum^\\infty_{k=1}\\frac{\\mathrm{Lip}(g)^k}{k} = -\\ln (1 - \\mathrm{Lip}(g)) \\\\ d\\sum^\\infty_{k=n+1}\\frac{\\mathrm{Lip}(g)^k}{k} = -d\\left(\\ln(1 - \\mathrm{Lip}(g)) + \\sum^n_{k=1}\\frac{\\mathrm{Lip}(g)^k}{k}\\right)$$\n이는 추후 ResFlow[2]라는 후속 논문에서 russian roullete estimation을 통해 unbiased estimation을 구현해 내고, softplus나 elu의 vanishing second order derivatives 현상과 training instability를 보완하기 위해 LipSwish를 제안하기도 한다.\nLipschitz Constraints and Pushforwards\n(이하는 개인의 이해보다는 논문의 표기를 그대로 따르며, 내용의 소개 정도를 목표로 한다.)\nNormalizing flow는 density estimation의 pushforward에 해당한다. 이는 prior measure $P_Z$와 bijective $f: \\mathcal Z \\to \\mathcal X$에 대해 measure $P_X := f \\# P_Z := P_Z\\circ f^{-1}$를 정의한다.\ntopological view에서 support of $P_Z$는 직관적으로 $P_Z$가 밀도를 할당하고 있는 region of $\\mathcal Z$를 의미한다. 따라서 target $P_X^*$와 pushforward $P_X$가 완벽히 일치하기 위해서는 두 support가 동치여야 한다. ($\\overline A$는 closure of A이다.)\n$$\\mathrm{supp} P_X^* = \\overline{f(\\mathrm{supp}P_Z)}$$\n이때 normalizing flow는 bijective f를 가정하므로, 두 support가 일치하기 위해서는 $P_X^*$와 $P_Z$의 support가 homeomorphic 해야 한다 (i.e. topological space에서의 isomorphic을 의미한다.).\n$$\\mathrm{supp}P_X = \\mathrm{supp}P_X^* \\ \\ \\mathrm{only \\ if} \\ \\mathrm{supp} P_Z \\simeq \\mathrm{supp} P_X^*$$\n이 의미는 $P_Z$와 $P_X^*$의 support가 같은 topological properties를 공유한다는 것인데, 예를 들면 holes, knots, connected components의 수가 같아야 한다.\n따라서 현재 단순 gaussian prior를 상정한 normalizing flow는 complex real-world densities를 학습하기에 topological mismatch의 불가항력이 존재한다.\n이 condition을 완화하기 위해서는 $P_X \\approx P_X^*$로 두어 topological misspecified prior를 사용할 수 있게 하거나, pushforward f의 bijectivity를 완화해야 할 수 있어야 한다.\nBehrmann et al. (2020)[4]에서는 numerical invertibility의 척도로 bi-Lipschitz constant를 상정한다. ([4]에서는 수학적으로 잘 정의된 inverse도 precision의 한계를 가지는 머신 위에서 numerical inverse가 명확하지 않을 수 있음을 보인다.)\n$$\\mathrm{BiLip} f = \\max \\left( \\mathrm{Lip}(f), \\mathrm{Lip}(f^{-1}) \\right)$$\nbi-Lipschitz constant는 $f$나 $f^{-1}$가 한 번에 jump 할 수 있는 정도를 의미한다. 이때 $f$가 injective하지 않으면 $\\mathrm{BiLip} f = \\infty$이고, $\\mathrm{BiLip} f \u0026lt; \\infty$이면 $f$는 homeomorphism이다.\n다음은 $P_Z$와 $P_X^*$가 homeomorphic하지 않을 때 $f$의 bi-Lipschitz constant가 근사를 위해 임의로 커질 수 있음을 의미한다.\nTheorem 2.1. $P_Z$와 $P_X^*$가 $\\mathbb R^{d_\\mathcal{Z}}$와 $\\mathbb R^{d_\\mathcal X}$의 measure이고, $\\mathrm{supp}P_Z \\not\\simeq \\mathrm{supp}P_X^ *$일 때, sequence of measurable $f_n: \\mathbb R^{d_\\mathcal{Z}} \\to \\mathbb R^{d_\\mathcal X}$에 대해 $\\lim_{n\\to\\infty}\\mathrm{BiLip}f_n = \\infty$이어야만 $f_n\\#P_Z \\overset{D}{\\to} P_X^ *$이 만족한다.\n이 때 $\\overset{D}{\\to}$는 weak convergence이며, 이는 KL, JS, Wasserstein metric과 같은 statistical divergence의 minimisation을 의미한다. Theorem2.1.은 다른 말로 bi-Lipschitz constant가 임의로 커질 수 있어야 pushforward가 원하는 measure에 수렴할 수 있음을 이야기한다. 또한 이 과정에서 $d_\\mathcal Z = d_\\mathcal X$를 가정하지 않으므로 GAN과 같은 injective pushforward를 포함한다.\nPractical Implication\n이 정리의 가장 직접적인 영향을 받는 것이 i-ResNet[1]과 ResFlow[2]이다. 이들은 invertibility를 위해 spectral normalization으로 residual layer의 Lipschitz-constant가 1 이하가 되도록 구성하였다.\n$$f^{-1}_l(x) = x + g_l(x), \\ \\ \\mathrm{Lip}(g_l) \\le \\kappa \u0026lt; 1$$\ni-ResNet[1]의 Lemma2에서는 이를 토대로 bi-Lipschitz constant의 upperbound를 구하게 되며, 이것이 Theorem 2.1.에 의해 non-homeomorphic prior $P_Z$의 근사에 제약이 발생함을 의미한다.\n$$\\mathrm{BiLip}f\\le\\max(1+\\kappa, (1 - \\kappa)^{-1})^L \u0026lt; \\infty$$\n이는 $\\kappa\\to1$을 통해 relax 할 수 있을 것으로 보이나, 반대로 russian roullete estimator의 variance를 높여 determinant의 수렴을 어렵게 한다. $L\\to\\infty$를 상정한다면, layer 수의 증가를 의미하므로 computational cost의 증대로 이어진다.\n그 외의 대부분 normalizing flow는 architecture에 bi-Lipschitz constraint를 걸지 않으므로, Theorem2.1.의 영향을 받지 않는다.\n반면 Behrmann et al. (2020)[4]에서는 well-defined inverse에서도 numerically noninvertible 할 수 있기에, 명시적으로 $\\mathrm{BiLip}f$를 제약하라고 제안하기도 한다. 즉 Theorem2.1.은 expressivity에 대한 numerical stability와 layer 수의 fundamental tradeoff를 시사한다.\nCIF: Continuously Indexed Flow\n이에 대해 CIF, Continuously Indexed Flow[7]는 ANF[5]와 VFlow[6] 때와 같이 augmentation을 그 해결책으로 제안한다.\nCIF[7]는 coninuous index $\\mathcal U \\subseteq \\mathbb R^{d_\\mathcal U}$와 bijective indexed family $\\{F(\\cdot;u): \\mathcal Z \\to \\mathcal X\\}_{u\\in \\mathcal U}$를 상정한다. 이에 대한 generative process는 다음과 같다.\n$$Z\\sim P_Z, \\ \\ U \\sim P_{U|Z}(\\cdot|Z), \\ \\ X := F(Z; U)$$\n저자들은 bijective f를 통해 $p_{U|Z}$와 $F$를 다음과 같이 모델링한다.\n$$p_{U|Z}(\\cdot|z) = \\mathrm{Normal}(\\mu^p(z), \\Sigma^p(z)) \\\\ F(z; u) = f(\\exp(-s(u)) \\odot z - t(u))$$\n여기서 $F^{-1}$를 활용해 likelihood를 구성하면 다음과 같다.\n$$z = F^{-1}(x; u) \\\\ p_{X, U}(x, u) = p_Z(z)p_{U|Z}(u|z)|\\det DF^{-1}(x; u)|$$\n이에 대한 marginal은 intractable 하므로 variational posterior $q_{U|X}$를 두어 lower bound를 추정한다.\n$$\\mathcal L(x):= \\mathbb E_{u\\sim q_{U|X}(\\cdot|x)}\\left[\\log\\frac{p_{X, U}(x, u)}{q_{U|X}(u|x)}\\right] \\\\ q_{U|X}(\\cdot|x) = \\mathrm{Normal}(\\mu^q(x), \\Sigma^q(x))$$\n이는 augmented flow로 추상화할 수 있는데, VFlow[6]에서는 latent u를 conditional flow로 모델링했다면, CIF[7]에서는 단순 gaussian으로 모델링 한 것이고, VFlow[6]에서 multiple coupling block을 두어 latent u와 data x사이의 정보 공유를 상정했다면, CIF[7]에서는 latent u만이 x의 모델링에 관여하는 single coupling block을 상정했다고 볼 수 있다.\n단 이렇게 되면 이전 augmented flow의 post에서도 이야기하였듯 u와 x 사이에 hierarchy가 발생하여 bottleneck problem의 해결로 이어지긴 어려울 듯하다.\n그럼에도 CIF[7]에서 hierarchy와 augmentation을 상정한 이유는 다음의 두 가지 정리 떄문이다.\nProposition 4.1. $\\phi \\in \\Theta$에 대해 $f: \\mathcal Z \\to \\mathcal X, F_\\phi(\\cdot; u) = f(\\cdot) \\ \\ \\forall u \\in \\mathcal U$를 가정한다. 그럼 density $r$ on $\\mathcal U$에 대해 trivial posterior $p^\\phi_{U|Z}(\\cdot|z) = q^\\phi_{U|X}(\\cdot|x) = r(\\cdot) \\ \\ \\forall z \\in \\mathcal Z, x \\in \\mathcal X$에도 다음이 만족한다.\n$$D_\\mathrm{KL}(P^*_X||P^\\theta_X) \\le D _\\mathrm{KL}(P^ *_X||f\\#P_Z) \\ \\ \\mathrm{if} \\ \\ \\mathbb E _{x\\sim P_X^ *}[\\mathcal L^\\theta(x)] \\ge \\mathbb E _{x\\sim P^ *_X}[\\mathcal L^\\phi(x)]$$\n이는 trivial posterior를 통해 likelihood의 lower-bound를 가정할 때, 학습된 모델이 KL divergence라는 measure에 대해 더 잘 작동한다는 것을 의미한다.\nCIF[7]에서는 이 현상을 $P_{U|Z}$를 통해 $P_X^*$의 support 외부에 존재할 수 있는 z를 rerounting 할 수 있었기 때문이라고 이야기한다. 예로 $z\\in \\mathcal Z$와 $f$에 대해 $f(x) \\in \\mathrm{supp} P_X^ *$라면 $F(z;u) = f(z) \\ \\ \\forall u \\in \\mathcal U$로, $f(z) \\not\\in \\mathrm{supp} P_X^ *$더라도 $F(z; U) \\in \\mathrm{supp}P_X^ *$를 구성할 수 있도록 $P_{U|Z}(\\cdot|z)$의 support가 $\\{u\\in \\mathcal U: F(z; u) \\in \\mathrm{supp}P_X^ *\\}$에 존재하게 하는 것이다.\n물론 이 과정에서 f가 충분히 단순하다면, $P_{U|Z}$는 굉장히 complex 해질 것이고, ELBO가 loose 해져 performance 역시 떨어질 것이다. 저자들은 이를 방지하기 위해 f를 10-layer ResFlow 같이 충분히 complex 한 모델을 상정하고, 일부 누수가 생기는 것을 $P_{U|Z}$가 보정하는 정도의 역할을 부여받을 수 있게 구성했다.\nProposition 4.3. $F(z;\\cdot): \\mathcal U \\to \\mathcal X$가 모든 $z\\in\\mathcal Z$에 대해 surjective이면 $P_{U|Z}$가 존재하여 $P_X=P_X^*$이다.\n물론 CIF[7]에서 제안한 component들이 위 조건을 필수적으로 만족하거나, variational posterior가 충분히 expressive 하지 않았을 수 있다. 하지만 최소한 misspecified prior를 수정하기 위한 mechanism을 제안한 점에서 의의가 있다.\nANF[5], VFlow[6]와의 차이가 있다면, 기존의 augmented flow는 마지막에 [z, u] 모두를 latent로 차용하지만, CIF[7]는 z만을 latent로 활용하여 u에 대한 slicing을 구성한다. hierarchy에 따라 bottleneck을 해결하지 못하더라도 surjectivity에 따른 misspecified prior의 수정을 수식적으로 증명했음에 또 다른 의의가 있다.\nExperiments\nTable 2. Comparison of i-ResNet to a ResNet-164 baseline architecture. (Behrmann et al., 2019)\nTable 4. MNIST and CIFAR10 bits/dim results. (Behrmann et al., 2019)\nTable 1: Mean ± standard error (over 3 seeds) of average test set log-likelihood (in nats). Higher is better. (Cornish et al., 2020)\nDiscussion\n(사견)\n꽤 긴 시간 공부해서 글을 쓰게 되었다. 정확한 이야기를 전달하고 싶었지만, 유난히 확신이 서지 않는다.\nNormalizing flow는 bijectivity를 근간으로 하기에, prior와 real data 사이의 topological mismatch를 bi-Lipschitz constant를 발산시킴으로써 해결해야 했다.\n이 과정에서 precision 상 한계를 가진 머신은 inversion에 numerical stability를 보장하지 못한다는 문제가 제기되었고, 이 해결책으로 bi-Lipschitz constant를 제한하자면서 trade-off의 관계가 발생했다.\nCIF[7]는 이를 위해 normalizing flow에 hierarchy를 구성하고, additional latent를 통해 misspecified prior의 보정이 가능함을 이야기하였다.\n개인적으로는 이러한 surjective의 전제와 증명이 ANF[5]나 VFlow[6]의 성능을 증명하는 것에도 활용될 수 있을 것으로 보인다.\n이렇게 Normalizing flow의 여러 문제와 해결안이 제기되고 있고, 그에 augmentation과 surjectivity가 종종 등장하고 있다. 추후 연구에서도 이를 통해 다른 확률 모델과의 연관성이나 universality 같은 이야기가 충분히 이뤄져 이제는 \u0026ldquo;왜 되는지 아는 모델\u0026quot;의 한 축이 되었음 좋겠다.\nReference\n[1] Behrmann, J., Grathwohl, W., Chen, T. Q., Duvenaud, D. and Jacobsen, J.-H. Invertible Residual Networks. In ICML 2019. [2] Chen, T. Q., Behrmann, J., Duvenaud, D. and Jacobsen, J.-H. Residual Flows for Invertible Generative Modeling. In NeurIPS 2019. [3] Miyato, T., Katoka, T., Koyama, M. and Yoshida, Y. Spectral Normalization for Generative Adversarial Networks. In ICLR 2018. [4] Behrmann, J., Vicol, P., Wang, K.-C., Grosse, R. B., Jacobsen, J.-H. On the Invertibility of Invertible Neural networks. 2019. [5] Huang, C., Dinh, L. and Courville, A. Augmented Normalizing Flows: Bridging the Gap Between Generative Flows and Latent Variable models. 2020. [6] Chen, J., et al. VFlow: More Expressive Generative Flows with Variational Data Augmentation. In ICML 2020. [7] Cornish, R., Caterini, A., Deligiannidis, G., Doucet, A. Relaxing Bijectivity Constraints with Continuously Indexed Normalising Flows. In ICML 2020.\n","permalink":"https://revsic.github.io/blog/resflow/","tags":["Machine Learning","Deep Learning","Bayesian","Normalizing Flow","i-ResNet","ResFlow","Invertible ResNet","Lipschitz constant","bi-Lipschitz constant","CIF","Continuously index flow"],"title":"Invertible ResNet and CIF"},{"categories":["Bayesian"],"contents":" ANF, Augmented Normalizing Flows: Bridging the Gap Between Generative Flows and Latent Variable Models, Huang et al., 2020, arXiv VFlow: More Expressive Generative Flows with Variational Data Augmentation, Chen et al., 2020, arXiv Keyword: Bayesian, Normalizing Flow, ANF, VFlow Problem: Dimensionality problem on normalizing flow Solution: Augmentation Benefits: Can propagate higher features to flow, better quality, bpd, etc. Weakness or Future work: - Series: Normalizing flow\nNormalizing flow, Real NVP [link] Glow, Flow++ [link] ANF, VFlow [this] i-ResNet, CIF [link] SurVAE Flows [link] Normalizing flow - Bottleneck problem\nNormalizing flow는 latent variable model의 한 축으로 자리 잡아 가고 있다. bijective를 통한 change of variables를 근간으로 하기에, 1) network의 inversion이 efficient 해야 하고, 2) log-determinant of jacobian 연산이 tractable 해야 하며, 3) 네트워크가 충분히 expressive 해야 한다.\n1)과 2)를 위해서는 기존과 같은 nonlinearity 기반의 레이어를 활용할 수 없었기에, 주로 jacobian의 형태를 제약하는 방식의 부가적인 engineering이 요구되었다.\n이 과정에서 mapping의 형태에 제약이 발생했고, 이에 따른 표현력 절감을 완화하기 위해 Glow[3], Flow++[4]과 같이 engineered bijective에 대한 연구가 등장했다.\nbijective로의 constraint는 tensor의 dimension도 바꿀 수 없게 하였다. 간단하게 tensor slice를 상정한다면, inverse 과정에서 유실된 slice를 복원해야 하고, 충분히 잘 구성된 상황을 가정하지 않은 이상, 이 과정은 analytic 하게 구성되지 않을 것이다.\n$$y = x_{1:d} \\ \\ \\mathrm{where} \\ x \\in \\mathbb R^D, \\ d \u0026lt; D \\\\ x_{1:d} = y, \\ \\ x_{d+1:D} = \\ ?$$\nUniversal approximation theorem에서부터 WideResNet[5]으로 이어져 오면서 network의 width는 성능에 중요한 factor가 되었다.\n이러한 상황에서 tensor의 dimension을 임의로 조작하지 못해 하위 flow에 internal hidden layers의 higher dimensional feature를 충분히 전달하지 못하면, flow는 매번 부족한 정보를 local-dependency부터 다시 추출해야 한다. 이렇게 개개 블럭의 표현력이 떨어진 flow는 block의 수를 늘림으로써 이를 해결해야 했고, computational inefficiency로 이어졌다.\n이 때문에 Flow++[4]에서는 global-dependency를 보다 효율적으로 탐색하기 위해 Transformer[6] 기반의 internal network를 제안하기도 한다.\nDimension problem, bottleneck problem의 요점은 high-resolution, low-dimension의 입력에서부터 high-dimension의 feature를 연산하고, 재사용할 수 있는지에 존재한다.\nAugmented Normalizing Flow, 이하 ANF[1]와 VFlow[2]는 서로 다른 논문이지만 normalizing flow의 dimension 문제에 대해 augmentation이라는 동일한 해결책을 제시한다.\nAugmentation\n흔히 Augmentation이라 하면 데이터의 양을 늘리거나, 모델의 robustness를 위한 preprocessing 작업 정도를 상상하겠지만, normalizing flow에서는 input에 추가적인 latent를 concat 하여 입출력 dimension을 직접 늘리는 행위를 이야기한다.\nFigure 1: Bottleneck problem in Flow++ and solution VFlow. (Chen et al., 2020)\nANF Perspective\nANF[1]는 dimension을 늘리기 위해 독립 변수 $e \\sim q(e) = \\mathcal N(0, I)$를 상정하고, family of joint density models $\\{ p_\\pi(x, e): \\ \\pi \\in \\mathfrak B\\mathcal{(X \\times E)} \\}$를 구성한다. 이 과정에서 $p_\\pi(x)$의 marginal likelihood 대신에 $p_\\pi(x, e)$의 joint likelihood를 다루게 되었다.\n$$\\hat\\pi_\\mathcal{A} := {\\arg\\max}_{\\pi \\in \\mathfrak B(\\mathcal{X\\times E})}\\mathbb E _{(x, e) \\sim \\hat q(x)q(e)}[\\log p _\\pi(x, e)]$$\n이렇게 확장된 estimator를 ANF[1]에서는 Augmented Maximum Likelihood Estimator (AMLE)라 명명하고, 학습에는 entropy $H(e)$를 활용한 maximizer $\\mathcal{L_A}(\\pi; x) := \\mathbb E_e[\\log p_\\pi(x, e)] + H(e)$를 정의하여 이용하게 된다. 이렇게 되면 marginal과의 차이는 KL divergence로 유도되고, 원문에서는 이를 augmentation gap이라 칭한다.\n$$\\begin{align*} \u0026amp;\\log p_\\pi(x) - \\mathcal{L_A}(\\pi; x) \\\\ \u0026amp;= \\log p_\\pi(x) - \\mathbb E_e[\\log p_\\pi(x) + \\log p_\\pi(e|x)] - H(e) \\\\ \u0026amp;= D_\\mathrm{KL}(q(e)||p_\\pi(e|x)) \\end{align*}$$\nexact marginal likelihood는 analytic 하게 연산할 수 없으므로, $q(e)$의 K개 i.i.d. sample을 통해 값을 추정해야 한다.\n$$\\hat{\\mathcal L_{A, K}} := \\log\\frac{1}{J}\\sum^K_{j=1}\\frac{p_\\pi(x, e_j)}{q(e_j)}$$\n네트워크는 affine coupling으로 구성하며, Glow[3]에서 split-concat을 활용했던 것과 유사하게 입력 데이터로 구성된 block $x$와 augmentation block $e$를 두고 coupling을 진행한다.\n$$\\begin{align*} \u0026amp;g_\\pi^\\mathrm{enc}(x, e) = \\mathrm{concat}(x, s_\\pi^\\mathrm{enc}(x) \\odot e + m_\\pi^\\mathrm{enc}(x)) \\\\ \u0026amp;g_\\pi^\\mathrm{dec}(x, e) = \\mathrm{concat}(s_\\pi^\\mathrm{dec}(e)\\odot x + m_\\pi^\\mathrm{dec}(e), e) \\end{align*} \\\\ G_\\pi = g_{\\pi_N}^\\mathrm{dec} \\circ g_{\\pi_N}^\\mathrm{enc} \\circ \u0026hellip; \\circ g_{\\pi_1}^\\mathrm{dec} \\circ g_{\\pi_1}^\\mathrm{enc}$$\nVFlow Perspective\nVFlow[2] 또한 마찬가지로 additional random variable $z \\in \\mathbb R^{D_z}$를 상정하고, data $x \\in \\mathbb R^{D_X}$와 augmented distribution $p(x, z; \\theta)$을 구성한다.\n$$e = f(x, z; \\theta) \\in \\mathbb R^{D_X + D_Z}$$\n이렇게 되면 marginal이 intractable 하기에, VFlow[2]에서는 variational $q(z|x; \\phi)$를 상정하고, lower bound를 objective로 구성한다.\n$$\\log p(x; \\theta) \\ge \\mathbb E_{q(x|z; \\phi)}[\\log p(x, z; \\theta) - \\log q(z|x; \\phi)]$$\n마찬가지로 density estimation은 sampling을 통해 진행한다.\n$$\\log p(x; \\theta) \\simeq \\log\\left(\\frac{1}{S}\\sum^S_{i=1}\\frac{p(x, z_i; \\theta)}{q(z_i|x; \\phi)}\\right) \\ \\ \\mathrm{where} \\ \\ z_1, \u0026hellip;, z_S \\sim q(z|x; \\phi)$$\n이 때 variational $q(z|x; \\phi)$는 보다 유연한 근사를 위해 또 다른 conditional flow로 구성한다.\n$$z = g^{-1}(e_q; x, \\phi) \\Rightarrow \\log q(z|x; \\phi) = \\log p_\\epsilon(e_q) - \\log\\left|\\frac{\\partial z}{\\partial e_q}\\right|$$\nBetween ANF and VFlow\n두 접근 모두 augmentation을 통해 bottleneck problem을 풀었다는 것에는 동일하나, formulation이 사뭇 다르게 보인다.\nANF의 경우에는 $q(e)$를 standard normal로 가정하여, entropy of e를 통해 lower bound를 산출해 낸다. 이 경우 augmentated gap $D_\\mathrm{KL}(q(e)||p_\\pi(e|x))$은 $x$에 독립인 marginal $q(e)$를 모델링하는 과정에서의 incapability에 의해 발생한다.\n하지만 VFlow의 경우에는 augmented distribution을 variational $q(z|x)$로 상정하여 intractable marginal의 lower bound에 접근하면서 augmented gap $D_\\mathrm{KL}(q_\\phi(z|x)||p(z|x))$을 줄일 가능성을 제시한다.\n이 두 formulation을 보면 언뜻 ANF는 joint를 VFlow는 marginal을 학습하는 차이가 있어 보이지만, entropy가 더해진 ANF의 maximizer $\\mathcal{L_A}(\\pi; x)$는 사실 variational distribution을 $q(z|x) = p(z) = \\mathcal N(0, I)$의 independent standard gaussian으로 상정한 VFlow의 marginal formulation과 동일하다.\n$$\\begin{align*} \u0026amp;\\log p(x; \\theta) \\\\ \u0026amp;\\ge \\mathbb E_{z\\sim q(z|x)}[\\log p(x, z; \\theta) - \\log q(z|x)]\\\\ \u0026amp;= \\mathbb E_{z \\sim p(z)}[\\log p(x, z; \\theta)] + \\mathbb E_{z \\sim p(z)}[- \\log p(z)] \\\\ \u0026amp;= \\mathbb E_{z \\sim p(z)}[\\log p(x, z; \\theta)] + H(z) \\\\ \u0026amp;= \\mathcal{L_A}(\\theta;x) \\end{align*}$$\n즉 ANF는 trivial distribution을, VFlow는 conditional flow를 기반으로 한 variational distribution을 상정한 것에 차이가 있다.\nConnection to Vanilla Generative Flows\n이렇게 bottleneck problem을 해결했다지만, 정말로 marginal likelihood의 향상에 도움이 있는지 VFlow[2]에서는 그 증명을 통해 알아본다.\n이론상 증명을 알아보기 이전에 notation을 정리한다.\nvanilla generative flow는 $p_x(\\mathbf x; \\theta_x), \\ \\theta_x \\in \\Theta_x$로 정의, $\\Theta_x$는 parameter space. $D_Z \u0026gt; 0$일 때, VFlow는 $p_a(\\mathbf x, \\mathbf z; \\theta_a), \\ z \\in \\mathbb R^{D_Z}, \\ \\theta_a \\in \\Theta_a$, 그리고 marginal $p_a(\\mathbf x; \\theta_a)$ $D_Z \u0026gt; 0$일 때, variational $q(z|x; \\phi), \\ z \\in \\mathbb R^{D_Z}, \\phi \\in \\Phi$ 이때의 maximum liklihood는 vanilla의 경우 $\\max_{\\theta_x}[\\log p_x(\\mathbf x; \\theta_x)]$, vflow의 경우 $\\max_{\\theta_a, \\phi}\\mathbb E_{\\hat p(x)q(z|x; \\phi)}[\\log p_a(\\mathbf x, \\mathbf z; \\theta_a) - \\log q(z|x; \\phi)]$로 구성될 것이다.\nVFlow[2]는 다음과 같은 가정을 한다.\nA1. (high-dimensional flow can emulate low-dimensional flow) 모든 $\\theta_x \\in \\Theta_x$와 $D_Z \u0026gt; 0$에 대해 다음을 만족하는 $\\theta_a \\in \\Theta_a$가 존재한다.\n$$p_a(\\mathbf x, \\mathbf z; \\theta_a) = p_x(\\mathbf x; \\theta_x)p_\\epsilon(z) \\ \\forall \\mathbf x, \\mathbf z$$\nA2. (the variational family has an identity transformation) 모든 $D_Z \u0026gt; 0$에 대해 $\\phi \\in \\Phi$가 존재하여, $q(\\mathbf z|\\mathbf x; \\phi) = p_\\epsilon(\\mathbf z) \\ \\forall \\mathbf x, \\mathbf z$를 만족한다.\n이는 RealNVP[8], Glow[3] 대부분의 invertible transformation에 성립한다고 한다.\n간단한 예로 orthonormal matrix $\\theta_x \\in \\Theta_x$에 대한 invertible linear flow $\\epsilon = \\mathbf x\\theta_x$를 상정한다면, $\\theta_a$를 적절히 취함으로써 A1을 만족시킬 수 있다.\n$$\\theta_a = \\left[\\begin{matrix}\\theta_x \u0026amp; 0 \\\\ 0 \u0026amp; I\\end{matrix}\\right] \\\\ p_a(\\mathbf x, \\mathbf z; \\theta_a) = p_\\epsilon\\left([\\mathbf x, \\mathbf z]\\left[\\begin{matrix}\\theta_x \u0026amp; 0 \\\\ 0 \u0026amp; I\\end{matrix}\\right]\\right) = p_\\epsilon(\\mathbf x \\theta_x)p_\\epsilon(\\mathbf z)$$\n또한 $q(\\mathbf z|\\mathbf x; I) = p_\\epsilon(\\mathbf z I) = p_\\epsilon(z)$이므로 A2도 만족한다. 추가적인 transform에 대한 증명은 VFlow[2]의 Appendix A.에서 확인 가능하다.\nTheorem. A1과 A2의 가정 하에 $D_Z \u0026gt; 0$을 취하면 다음을 얻을 수 있다.\n$$\\max_{\\theta_x \\in \\Theta_x}\\mathbb E_{\\hat p(\\mathbf x)}\\log p_x(\\mathbf x; \\theta_x)] \\le \\max_{\\theta_a \\in \\Theta_a, \\phi \\in \\Phi}\\mathbb E_{\\hat p(\\mathbf x)q(\\mathbf z|\\mathbf x; \\phi)}[\\log p_a(\\mathbf x, \\mathbf z; \\theta_a) - \\log q(\\mathbf z|\\mathbf x; \\phi)]$$\npf. vanilla $p_x(\\mathbf x; \\theta_x)$에 대해 A1과 A2를 가정하면 다음을 구성할 수 있다.\n$\\theta(\\theta_x) \\in \\Theta_a$에 대해 $p_a(\\mathbf x, \\mathbf z; \\theta(\\theta_x)) = p_x(\\mathbf x; \\theta_x)p_\\epsilon(\\mathbf z)$을 구성. 이는 z를 최소한으로 활용하는 경우를 가정한다. $\\phi \\in \\Phi$에 대해 $q(\\mathbf z|\\mathbf x; \\phi) = p_\\epsilon(\\mathbf z)$. 이는 posterior의 정보를 활용하지 않는 경우를 가정한다. 이의 lower bound는 vanilla와 동일해진다.\n$$\\log p_a(\\mathbf x, \\mathbf z; \\theta(\\theta_x)) - \\log q(\\mathbf z|\\mathbf x; \\theta_x) = \\log p_x(\\mathbf x; \\theta_x)$$\n이에 대해 다음과 같은 전개가 가능하다.\n$$\\begin{align*} \u0026amp;\\max_{\\theta_x \\in \\Theta_x} \\mathbb E_{\\hat p(\\mathbf x)}[\\log p_x(\\mathbf x; \\theta)] \\\\ \u0026amp;= \\max_{\\theta_a \\in \\Theta_a, \\phi \\in \\Phi} \\mathbb E_{\\hat p(\\mathbf x)p_\\epsilon(\\mathbf z)}[\\log p_x(\\mathbf x; \\theta) + \\log p_\\epsilon(\\mathbf z) - \\log p_\\epsilon(\\mathbf z)] \\\\ \u0026amp;= \\max_{\\theta_x \\in \\Theta_x} \\mathbb E_{\\hat p(\\mathbf x)}[\\log p_a(\\mathbf x, \\mathbf z; \\theta(\\theta_x)) - \\log p_\\epsilon(\\mathbf z)] \\\\ \u0026amp;\\le \\max_{\\theta_a \\in \\Theta_a} \\mathbb E_{\\hat p(x)}[\\log p_a(\\mathbf x, \\mathbf z; \\theta_a) - \\log p_\\epsilon(\\mathbf z)] \\tag 1\\\\ \u0026amp;= \\max_{\\theta_a \\in \\Theta_a} \\mathbb E_{\\hat p(x)}[\\log p_a(\\mathbf x, \\mathbf z; \\theta_a) - \\log q(\\mathbf z|\\mathbf x; \\phi)] \\\\ \u0026amp;\\le \\max_{\\theta_a \\in \\Theta_a, \\phi \\in \\Phi}\\mathbb E_{\\hat p(\\mathbf x)}[\\log p_a(\\mathbf x, \\mathbf z; \\theta_a) - \\log q(\\mathbf z|\\mathbf x; \\phi)] \\tag 2 \\end{align*}$$\n1번 식에서는 $\\theta_a$의 자율성에 의해, 2번 식에서는 variational $q(z|x;\\phi)$의 학습에 의해 부등호가 성립한다. 따라서 이는 ANF와 같이 trivial $q(\\mathbf z|\\mathbf x) = p_\\epsilon(\\mathbf z)$를 상정하더라도 기존보다 성능향상이 있음을 의미한다.\nVFlow[2]에서는 실험적으로도 channel 수에 따른 bpd 감소를 보였다.\nFigure 6. Bpd on training (light) and validation (dark) dataset of Flow++ and VFlow under a 4-million parameter budget (not fully converged) (Chen et al., 2020)\naugmentation의 문제를 parameter의 증가라 볼 수도 있는데, VFlow[2]는 hidden layers의 크기를 줄여 parameters 수를 일정 수준 유지하더라도, dimension 자체를 늘리는 것이 더욱 효율적이었음을 보인다.\nTable 3. Parameter efficiency on CIFAR-10. (Chen et al., 2020)\nConnection to VAE\nVAE[7]는 1-step augmented flow의 special case로 볼 수도 있다. joint distribution을 gaussian factorizing $p(x, z) = \\mathcal N(z; 0, I)\\mathcal N(x; \\mu(z), \\exp(\\sigma(z))^2)$을 통해 affine coupling의 1-step flow로 구성하면, vflow의 variational $q(z|x)$에 대해 Gaussian VAE와 동치이다.\n$$\\epsilon_Z \\sim q(z|x) \\ \\ \\epsilon_X \\sim \\mathcal N(0, I) \\\\ z = \\epsilon_Z, \\ \\ x = \\mu(\\epsilon_Z) + \\exp(s(\\epsilon_Z)) \\circ \\epsilon_X$$\nVFlow[2]는 $p(x, z) = p(z)p(x|z)$라는 hierarchy를 가정하지 않는다는 점에서 보다 일반화된 모델로 볼 수 있다. 또한 이렇게 hierarchy를 구성하면 여전히 $p(x|z)$의 dimension은 고정되고, 정보 공유가 없기에 bottleneck problem은 해결되지 않는다.\nVAE[7]는 또한 이러한 hierarchy에 의해 variational $q(z|x)$의 표현력이 중요해지는데, VFlow[2]에서는 이 역할이 $p(x, z)$로 분배되기 때문에 unconditional $q(z|x) = p(z)$를 가정하더라도 ANF[1]와 같이 충분히 좋은 성능을 보일 수 있었다.\nFigure 4: 5-step ANF on 1D MoG. (Huang et al., 2020)\n실제로 ANF[1]에서는 실험을 통해 step 수에 따른 latent의 gaussianize 여부를 plotting 해보았는데, step 수가 많아짐에 따라 latent가 gaussian prior에 더욱 근접했음을 확인할 수 있었다.\nFigure 4: Visualization of learnt transformation on toy data. (Chen et al., 2020)\nModeling Discrete Data\nFlow++[4]에서는 discrete data를 위해 variational dequantization을 이야기했었는데, VFlow[2]에서는 augmentation $\\mathbf z$와 dequantization $\\mathbf u$의 hierarchy를 두어 dicrete modeling을 구성하였다.\n$$\\log P(\\mathbf x) \\ge \\mathbb E_{r(\\mathbf u|\\mathbf x),q(\\mathbf z|\\mathbf x + \\mathbf u)}[\\log p(\\mathbf x + \\mathbf u, \\mathbf z) - \\log r(\\mathbf u|\\mathbf x) - \\log q(\\mathbf z | \\mathbf x + \\mathbf u)]$$\nHierarchical ANF\nANF[1]는 이를 한단계 더 일반화한 Hierarchical ANF를 제안한다. dequantization과 single augmentation이 아닌, augmentation latents $\\{z_i\\}_{l=1}^L$를 두고 각각의 latent에 hierarchy를 구성하는 방식이다.\n$$p(x, z-1, \u0026hellip;, z_L) = p(x|z_1, \u0026hellip;, z_L)\\prod^L_{l=1}p(z_l|z_{l+1}, \u0026hellip;, z_L) \\\\ q(z_1, \u0026hellip;, z_L|x) = \\prod^L_{l=1}q(z_l|z_1, \u0026hellip;, z_{l-1}, x)$$\nExperiments\nTable 1. Bits-per-dim estimates of standard benchmarks (the lower the better). (Huang et al., 2020)\nTable 1. Density modeling results in bits/dim (bpd). (Chen et al., 2020)\nTable 2. Evaluation on Inception Score (IS, the higher the better) and Fréchet Inception Distance (FID, the lower the better) (Huang et al., 2020)\nFigure 8. Left: comparison of linear and rescaled interpolations. Right: rescaled interpolation of input data (first and last columns). (Huang et al., 2020)\nANF[1]는 gaussian prior에서의 linear interpolation은 non-smooth transition을 포함하고 있다고 이야기한다. 이는 gaussian samples가 shell 근처에 중심적으로 분포해 있기 때문이기에, 이에 맞춘 rescaled interpolation이 필요하다는 것이다.\n$$h\u0026rsquo;(u, v, t) = \\frac{h(||u||, ||v||, t)}{||h(u, v, t)||}\\cdot h(u, v, t)$$\n이에 대한 비교는 ANF[1]의 Appendix A.에서 확인 가능하다.\nDiscusion\n사견:\n이번에는 augmented flow에 대해 알아보았다. 기존보다 정량적, 정성적 향상이 있었음을 확인했고, VAE와 동치인 case도 보였다. GAN, VAE, Flow라 불리던 stochastic model의 한 축이 통합된 현장이다.\n이 외에도 다음에 알아볼 논문에서는 diffusion, rad와 같은 접근까지 unifying 한 framework를 제안하기도 한다. 어쩌면 미래에는 GAN과의 연관성을 통해 major 확률 모델의 통합을 이뤄낼지도 모른다.\nrepresentation learning, unsupervised, probabilistic modeling 등 데이터의 표현에 대한 여러가지 연구가 있었지만, 그들을 엮어냈다는 점에서 특히 눈에 띄는 논문인 것 같다.\nReference\n[1] Huang, C., Dinh, L. and Courville, A. Augmented Normalizing Flows: Bridging the Gap Between Generative Flows and Latent Variable models. 2020. [2] Chen, J., et al. VFlow: More Expressive Generative Flows with Variational Data Augmentation. In ICML 2020. [3] Kingma, D. P. and Dhariwal, P. Glow: Generative Flow with Invertible 1x1 Convolutions. In NIPS 2018. [4] Ho, J. et al. Flow++: Improving flow-based generative models with variational dequantization and architecture design. In ICML 2019. [5] Zagoruyko, S. and Komodakis, N. Wide Residual Networks. 2016. [6] Vaswani, A., et al. Attention is all you need. In NeurIPS 2017. [7] Kingma, D. P. and Welling, M. Auto-encoding variational bayes. In ICLR 2014. [8] Dinh, L., Sohl-Dickstein, J. and Bengio, S. Density estimation using Real NVP. In ICLR 2017.\n","permalink":"https://revsic.github.io/blog/anfvf/","tags":["Machine Learning","Deep Learning","Bayesian","Normalizing Flow","Augmented Normalizing Flow","VFlow"],"title":"ANF, VFlow"},{"categories":["Bayesian"],"contents":" Glow: Generative Flow with Invertible 1x1 Convolutions, Kingma and Dhariwal, 2018, arXiv Flow++: Improving Flow-Based Generative Models with Variational Dequantization and Architecture Design, Jonathan Ho et al., 2019, arXiv Keyword: Bayesian, Normalizing Flow, Glow, Flow++ Problem: Inexpressiveness of engineered bijectives Solution: Invertible 1x1 convolution, variational dequantization, mixture of logistics Benefits: Lower bits/dim, better sample quality Weakness or Future work: - Series: Normalizing flow\nNormalizing flow, Real NVP [link] Glow, Flow++ [this] ANF, VFlow [link] i-ResNet, CIF [link] SurVAE Flows [link] Normalizing flow\nlatent variable model은 high-dimensional data로부터 내재된 패턴들을 축약한, 유의미한 latent space를 구성하고자 한다. 이는 주로 확률 모델로 구현되며, 크게 VAE, Flow와 같은 likelihood 기반의 모델과 GAN 부류의 모델로 구분할 수 있다.\nFlow의 경우 데이터 $x \\sim p_X^*(x)$에 대해 bijective sequence $\\{f_k\\}^L_{k=1}$를 통한 change of variables를 근간으로 한다. 자세한 정의는 이전 글을 따른다.\n$$z = f_L \\circ \\ \u0026hellip; \\ \\circ f_1(x) \\\\ \\log p_X(x) = \\log p_Z(z) + \\sum^L_{k=1}\\log\\left|\\det\\frac{\\partial f_k}{\\partial f_{k-1}}\\right| \\ \\ \\mathrm{where} \\ \\ f_0 = x$$\ntransform에 bijective라는 constraint가 붙은 만큼 몇 가지 이점을 갖는다.\nVAE의 경우 intractable posterior로 인해, variational inference를 통한 log-likelihood의 lower-bound 추정을 objective로 하지만, normalizing flow의 경우에는 change of variables를 통한 exact log-likelihood estimation과 inference가 가능하다.\n또한 그 과정에서 encoder, decoder가 별개의 네트워크가 아닌, 파라미터를 공유하는 하나의 네트워크로 구성되므로 memory efficient 한 모델링이 가능하다.\n이전 글에서 Rezende \u0026amp; Mohamed(2015)[1], RealNVP[2]로 물살을 탄 normalizing flow를 이번 글에서는 engineered bijective 관점에서 어떠한 발전이 있었는지 알아본다.\nGlow\nGlow[3]는 RealNVP[2]의 multi-scale architecture를 기반으로 더욱 풍부하고 다양한 engineered bijective를 하나의 flow block으로 구성한 모델이다.\n기존의 RealNVP[2]가 Affine coupling, Batchnorm의 두 개 layer를 하나의 flow block으로 구성했다면, Glow는 ActNorm, Invertible 1x1 convolution, Affine coupling 3개 layer를 하나의 flow block으로 구성한다.\nActNorm RealNVP[2]에서는 deep models가 학습 중 겪게 되는 여러 문제를 해결하고자 batch normalization을 도입하였다. 하지만 batch norm의 경우 batch size에 영향을 받고, 그 크기가 작아짐에 따라 성능이 절감된다. 특히나 image의 경우 tensor size가 커 memory에 많은 양의 batch를 구성하지 못할 때에 치명적일 수 있다.\n이에 Glow[3]에서는 activation normalization, 이하 actnorm을 제안한다. actnorm은 첫 번째 minibatch의 mean과 variance로 초기화한 parameter로 normalization을 진행한다. 이는 DDI(data-dependent initialization)을 따르고, 초기화된 이후에는 데이터와 독립된 일반적인 trainable parameter로 취급한다.\nBatchnorm이 data에서 연산한 running statistics를 통해 normalization을 진행했다면, actnorm은 첫 번째 batch에서 연산한 statistics로 초기화한 파라미터를, 이후에는 데이터에 독립적인 trainable parameter로 상정하고 normalization을 진행한다는 점에서 차이가 존재한다.\n물론 이렇게 학습된 parameter가 실제로 hidden state의 statistics를 따르지는 않는다.\n$[h\\times w \\times c]$의 image tensor가 주어진다면, actnorm은 channel dimension에서 작동한다.\n$$y \\leftarrow \\frac{x - \\hat\\mu}{\\sqrt{\\hat\\sigma^2 + \\epsilon}}, \\ \\ \\log\\left|\\det\\frac{\\partial y}{\\partial x}\\right| = -h \\cdot w \\cdot\\sum\\log\\sqrt{\\sigma^2 + \\epsilon}$$\nInvertible 1x1 convlution RealNVP[2]와 같은 기성 모델은 coupling layer의 활용으로 인해 일부 channel에 identity map이 적용되었고, 모든 channel에 transform을 적용하기 위해 고정된 permutation operation을 활용하였다.\nGlow[3]에서는 이 대체재로 invertible 1x1 convolution을 제안한다. invertible matrix를 근간으로 하는 linear projection은 어떤 basis로의 permutation으로 일반화되며, 1x1 conv는 이 과정에서 channel axis에 대한 일반화된 learnable permutation을 진행한다.\ninvertible 1x1 convolution의 log-determinant는 determinant of weight matrix로 귀결되며 다음과 같이 정리된다.\n$$\\log\\left|\\det\\frac{d \\mathrm{conv2D}(h; W)}{dh}\\right| = h \\cdot w \\cdot \\log\\left|\\det W\\right|$$\n문제는 weight matrix $W$의 determinant 연산은 $\\mathcal O(c^3)$의 cubic 연산이기 때문에 channel의 크기가 커짐에 따라 intractable 하다는 특성을 가진다.\nGlow[3]는 이를 위해 LU Decomposition을 제안한다. invertible matrix W를 두고, LDU factorized $L, D, U$를 trainable parameter로 가정한다. 그럼 non-zero diagonal matrix $D = \\mathrm{diag}(s)$에 대해 다음과 같이 weight matrix W를 재구성할 수 있다. (이 때 permutation P는 고정이다.)\n$$W = PL(U + \\mathrm{diag}(s))$$\n이에 log-determinant를 $\\mathcal O(c)$의 linear time에 연산해낼 수 있게 된다.\n$$\\log\\left|\\det W\\right| = \\sum \\log |s|$$\nAffine coupling 기존의 RealNVP[2]에서의 affine coupling에 몇 가지 trick을 제안한다.\n우선 zero initialization이다. coupling layer는 affine transform에 활용할 파라미터를 NN을 통해 연산해내는데, 이때 NN 이후 추가 convolution을 하나 더 두고, 이의 weight을 0으로 두어 학습 초기에 identity function이 되도록 강제한다. 이것이 very dep networks의 학습에 도움을 주었다고 한다.\n두 번째는 permutation에 관해서이다. Glow[3]는 invertible 1x1 convolution을 통해 permutation을 일반화하였으므로, RealNVP[2]와 같은 checkerboard pattern 형식의 mask가 큰 의미가 있지 않다. 따라서 Glow[3]에서는 단순히 절반의 channel을 split하고 concat하는 방식을 차용하였다고 한다.\nFlow++\nFlow++[4]의 저자는 Rezende \u0026amp; Mohamed, 2015[1], RealNVP[2], Glow[3]를 넘어선 여러 가지 normalizing flow에 관한 연구가 있었지만, 여전히 다른 generative model보다 표현력이 부족하다는 것을 느꼈다.\n그는 그 문제점으로 3가지를 들었다.\n1. uniform dequantization이 loss와 generalization의 suboptimal choice라는 것 2. affine coupling layer가 충분히 expressive 하지 않다는 것 3. coupling layer의 conditional network로 convolution은 충분히 powerful 하지 않다는 것\n그리고 다음에서 그 대체재를 소개하고자 한다.\nVariational dequantization 이미지나 음성 데이터의 경우에는 continuous signal을 discrete representation으로 바꿔 저장하고, 이를 모델링하게 되는데, 단순히 continuous density model을 이에 fitting 하면, 대부분의 probability mass가 discrete point에 치중되며 품질이 떨어지는 현상이 발생한다.\n이를 해결하기 위해 RNADE[5]에서는 dequantization을 제안했으며, 이는 uniform noise를 통해 data를 continous form으로 만들어 degenerate point로의 collapse를 방지하는 것이다.\n$$P_\\mathrm{model}(x) := \\int_{[0, 1)^D}p_\\mathrm{model}(x + u)du$$\n또한 다음 전개에 의해서 dequantized data $y = x + u$의 log-likelihood를 discrete data $x$의 lower-bound로 볼 수 있다.\n$$\\mathbb E_{y \\sim p_\\mathrm{data}}[\\log p_\\mathrm{model}(y)] \\\\ = \\sum_x P_\\mathrm{data}(x) \\int_{[0, 1)^D}\\log p_\\mathrm{model}(x+u)du \\\\ \\le \\sum_x P_\\mathrm{data}(x)\\log\\int_{[0, 1)^D}p_\\mathrm{model}(x+u)du \\\\ = \\mathbb E_{x\\sim P_\\mathrm{data}}[\\log P_\\mathrm{model}(x)]$$\n이를 통해 probability mass가 discrete point에 치중되고, degenerate mixture로 collapse 하는 현상을 막을 수 있었지만, 단순 unit hypercube $x + [0, 1)^D$로 모델링하기엔 uninformative 하고 unnatural 하다.\n따라서 variational dequantization에서는 dequantization noise distribution을 variational $q(u|x)$로 상정하고 lower bound를 objective로 학습시킨다.\n$$\\mathbb E_{x\\sim P_\\mathrm{data}}[\\log P_\\mathrm{model}(x)] \\\\ = \\mathbb E_{x\\sim P_\\mathrm{data}}\\left[\\log\\int_{[0, 1)^D}q(u|x)\\frac{p_\\mathrm{model}(x+u)}{q(u|x)}du\\right] \\\\ \\ge \\mathbb E_{x\\sim P_\\mathrm{data}}\\left[\\int_{[0, 1)^D}q(u|x)\\log\\frac{p_\\mathrm{model}(x+u)}{q(u|x)}du\\right] \\\\ = \\mathbb E_{x\\sim P_\\mathrm{data}, \\ u \\sim q(\\cdot|x)}\\left[\\log\\frac{p_\\mathrm{model}(x+u)}{q(u|x)}\\right]$$\n이때 variational distribution $q$는 flow-based model로 상정하여 $u = q_x(\\epsilon), \\ \\mathrm{where} \\ \\epsilon \\sim p(\\epsilon) = \\mathcal N(\\epsilon; 0, I)$로 둔다. 이후 likelihood는 change of variables로 estimation이 가능하고 $q(u|x) = p(q_x^{-1}(u))\\cdot|\\partial q_x^{-1}/\\partial u|$, lower bound objective는 다음과 같이 쓸 수 있다.\n$$\\mathbb E_{x \\sim P_\\mathrm{data}}[\\log P_\\mathrm{model}(x)] \\le \\mathbb E_{x \\sim P_\\mathrm{data}, \\ \\epsilon \\sim p}\\left[\\log \\frac{p_\\mathrm{model}(x + q_x(\\epsilon))}{p(\\epsilon)\\left|\\partial q_x/\\partial \\epsilon\\right|^{-1}}\\right]$$\n이에 발생하는 true likelihood와의 차는 $\\mathbb E_{x\\sim p_\\mathrm{data}}[D_{KL}(q(u|x)||p_\\mathrm{model}(u|x))]$이다. 이는 $q$를 uniform과 같은 inexpressive distribution을 상정했을 때 lower bound가 loose 해질 수 있음을 의미한다. 따라서 flow 기반의 $q$를 사용함으로써 더움 flexible 한 modeling이 가능하게 하였고, 실제로 train loss나 generalization에서 더 나은 성능을 보였다.\nImproved coupling layers 근래의 flow-based model은 대부분 affine coupling과 permutation layer을 활용했다. coupling layer의 경우 conditioning network $a_\\theta, b_\\theta$를 상정하여 입력 일부로부터 parameter를 설정, 이를 토대로 나머지 입력을 transform 한다.\n$$y_1 = x_1, \\ \\ y_2 = x_2 \\cdot \\exp(a_\\theta(x_1)) + b_\\theta(x_1)$$\nFlow++[4]의 저자들은 실험을 통해 더욱 expressive 한 coupling layer를 제안한다. 이는 mixture of logistics를 활용하여 invertible nonlinear transform을 가능케 한다.\n$$x \\mapsto \\sigma^{-1}(\\mathrm{MixLogCDF}(x;\\pi, \\mu, s)) \\cdot \\exp(a) + b \\\\ \\mathrm{where} \\ \\ \\mathrm{MixLogCDF}(x; \\pi, \\mu, s) := \\sum^K_{k=1}\\pi_i\\sigma((x - \\mu_i)\\cdot\\exp(-s_i))$$\n이 때 $\\{\\pi_i, \\mu_i, s_i\\}_{i=1}^K, a, b$는 모두 neural network로 parameterizing한다.\nExpressive conditioning architectures with self-attention 기존까지는 coupling layer에서 conditioning network로 convolutional layer를 주로 상정했다면, 이번에는 multihead self-attention 기반의 network(Vaswani et al., 2017[6])를 활용해본다.\nnetwork는 stack of blocks로 구성되고, 각 block은 아래와 같이 구성된 뒤 residual connection과 layer normalization을 통해 연결된다.\n$$\\mathrm{Attn = Input \\to Conv_{1x1} \\to MultiHeadSelfAttention \\to Gate}$$\n이때 $\\mathrm{Gate}$는 gated activation unit을 의미한다. network는 input tensor를 여러 개의 block에 forward하고, 마지막에 convolutional layer를 통해 coupling에 필요한 파라미터 수 만큼 channel을 늘리게 된다.\nExperiments\nTable 1: Unconditional image modeling results in bits/dim. (Ho et al., 2019)\nRealNVP[2], Glow[3], FlowW++[4]로 넘어오는 과정이 정량적으로 잘 나타났다.\nTable 2: CIFIAR10 ablation results after 400 epochs of training. (Ho et al., 2019)\n또한 실제로 ablation study를 통해 component별 향상치도 확인할 수 있다.\nFigure 6: Manipulation of attributes of a face. (Kingma \u0026amp; Dhariwal, 2018)\nDiscusion\n(사견)\nFlow는 bijective라는 constraint로 인해 기존의 nonlinearity를 근간으로 하는 expressiveness를 충분히 누리지 못했다. 그렇기 때문에 Flow 발전 초기에는 더욱 bijective block을 충분히 engineering 하여 표현력을 높이고자 하는 연구가 많았던 것 같다.\n그 과정에서 actnorm, invertible 1x1 convolution, logistic coupler, variational dequantization 등 다양한 블럭이 나왔고, 이번 기회에 이를 소개하고자 했다.\n이후에는 i-ResNet, ResFlow 등에서 residual network를 inversion 하는 시도 등을 통해 최대한 많은 feature에 nonlinearity를 활용하고자 하였고, 본격적으로 vae와의 통합을 위한 발판을 마련하기도 한다.\nReference\n[1] Rezende, D. J. and Mohamed, S. Variational inference with normalizing flows. In ICML 2015. [2] Dinh, L., Sohl-Dickstein, J. and Bengio, S. Density estimation using Real NVP. In ICLR 2017. [3] Kingma, D. P. and Dhariwal, P. Glow: Generative Flow with Invertible 1x1 Convolutions. In NIPS 2018. [4] Ho, J. et al. Flow++: Improving flow-based generative models with variational dequantization and architecture design. In ICML 2019. [5] Uria, B., Murray, I. and Larochelle, Hugo. RNADE: The real-valued neural autoregressive density-estimator. In NeurIPS 2013. [6] Vaswani, A. et al. Attention is all you need. In NeurIPS 2017.\n","permalink":"https://revsic.github.io/blog/glowflowpp/","tags":["Machine Learning","Deep Learning","Bayesian","Normalizing Flow","Glow","Flow++"],"title":"Glow, Flow++"},{"categories":["Bayesian"],"contents":" Variational Inference with Normalizing Flows, Rezende and Mohamed, 2015, arXiv Density Estimation using Real NVP, Dinh et al., 2017, arXiv Keyword: Bayesian, Normalizing Flow, Real NVP Problem: inflexibility of variational posterior Solution: probabilistic modeling with bijective and change of variables Benefits: simple sampling, exact log-likelihood estimation Weakness or Future work: determinant, inverse and architecutral constraint Series: Normalizing flow\nNormalizing flow, Real NVP [this] Glow, Flow++ [link] ANF, VFlow [link] i-ResNet, CIF [link] SurVAE Flows [link] Variational Inference\n우리는 데이터에 대한 insight를 얻고자 할 때 probabilistic modeling을 통해 데이터가 어떤 분포를 가지는지 추정한다. 그 과정에서 latent variable을 도입하기도 하고, marginalize 과정에서 발생하는 적분의 intractability로 인해 variational inference를 활용해 posterior를 known distribution으로 근사하기도 한다.\n$$\\log p_\\theta(x^{(i)}) = D_{KL}(q_\\phi(z|x^{(i)})||p_\\theta(z|x^{(i)})) + \\mathbb E_{q_\\phi}\\left[ \\log \\frac{p_\\theta(x, z)}{q_\\phi(z|x)} \\right]$$\n이 중 연산이 가능한 두번째 RHS term만을 발췌해 variational lower bound라 부른다.\n$$\\log p_\\theta(x^{(i)}) \\ge \\mathbb E_{q_\\phi}\\left[\\log\\frac{p_\\theta(x, z)}{q_\\phi(z|x)}\\right] = \\mathbb E_{q_\\phi(z|x^{(i)})}\\left[ \\log p_\\theta(x^{(i)}|z) \\right] - D_{KL}(q_\\phi(z|x^{(i)})||p_\\theta(z))$$\nRezende \u0026amp; Mohamed(2015)[1]에서는 성공적인 variational inference를 위해 1) derivatives of log-likelihood $\\nabla_\\phi\\mathbb E_{q_\\phi(z)}\\left[\\log p_\\theta(x|z)\\right]$ 연산의 효율성과 2) approximate posterior $q(\\cdot)$의 유연함이 필요하다 이야기한다.\n전자의 경우에는 VAE[2]에서와 같이 Monte carlo approximation과 reparametrization을 통해 gradient를 연산하는 방식을 취할 수 있다.\n$$z \\sim \\mathcal N(z|\\mu, \\sigma^2) \\Leftrightarrow z = \\mu + \\sigma \\epsilon, \\ \\ \\epsilon \\sim \\mathcal N(0, 1) $$\n하지만 이렇게 되면 variational posterior가 gaussian과 같은 분포로 한정되고, 이 경우 true posterior로의 근사가 어려울 수 있다.\n따라서 이상적인 variational distribution $q_\\phi(z|x)$는 true posterior의 근사를 위해 highly flexible해야 하고, 저자는 그 solution으로 normalizing flow를 제안한다.\nNormalizing Flow\nNormalizing flow는 invertible map을 통해 probability density를 순차적으로 변형시켜 나가는 모델이다. 각각의 invertible map은 change of variables를 통해 initial density를 변형시켜 나가고, density의 변환 흐름, \u0026lsquo;flow\u0026rsquo;를 표현하게 된다.\nChange of variables\n확률변수 $X \\in \\mathbb R^d$의 CDF $F_X$와 어떤 단조함수 $g: \\mathbb R^d \\to \\mathbb R^d$에 대해 $Y=g(X)$이면, 다음이 성립한다.\n$$F_Y(y) = P(Y \\le y) = P(g(X) \\le y) = P(X \\le g^{-1}(y)) = F_X(g^{-1}(y))$$\n이때 양변을 미분하면 $Y$에 대한 density를 구할 수 있게 되고, sample에 대한 exact log-likliehood의 연산이 가능해진다.\n$$f_Y(y) = f_X(g^{-1}(y))\\left|\\det\\frac{\\partial g^{-1}}{\\partial y}\\right| \\\\ \\log f_Y(y) = \\log f_X(g^{-1}(y)) + \\log\\left|\\det\\frac{\\partial g^{-1}}{\\partial y}\\right|$$\nFinite Flows\nNormalizing flow는 simple invertible map을 순차적으로 합성해 나가며 initial density를 임의의 complex distribution으로 만들어나간다.\ninitial random variable $z_0$와 distribution $q_0$에 대해 sequence of invertible map $f_1, \u0026hellip;, f_K$을 chain으로 구성하면 $x=z_k$의 sampling과 exact log-likelihood의 연산이 가능하다.\n$$z_K = f_K \\circ \\ \u0026hellip; \\ \\circ f_2 \\circ f_1(z_0) \\\\ \\ln q_K(z_K) = \\ln q_0(z_0) - \\sum^K_{k=1}\\ln\\left|\\det\\frac{\\partial f_k}{\\partial z_{k-1}}\\right|$$\n이때 initial distribution $q_0(z_0)$부터 $z_k = f_k(z_{k-1})$로 구성된 path를 flow라 한다.\n이는 LOTUS(law of unconscious statistician)으로도 불리며, 이 경우 $q_K$로 구성된 expectation을 분포에 대한 정보가 없이 연산 할 수 있게 된다. 이를 활용해 posterior를 모델링 하면 최종 분포상 제약이 없어 보다 유연한 근사가 가능하다.\n또한 기존의 확률 모델이 complexity를 높이기 위해 nonlinear transform을 활용하면서 invertibility를 포기하고, ELBO를 통해 log-likelihood의 lower bound를 추정했다면,\nnomarlizing flow는 NN을 활용한 engineered linear transform을 순차적으로 적용해 나가며 exact log-likelihood의 연산과 single forward-pass의 sampling이 가능하다는 것에 의의가 있다.\nReal NVP: Modeling bijectivity\nNormalizing flow는 여러가지 이점을 가지는 대신에 determinant와 inverse map이 tractable 해야 한다는 architecture의 constraint를 가진다.\nRealNVP[3]는 이러한 constraint에 대해 well-engineered transform을 제안한다.\nCoupling layers determinant와 jacobian을 고차원 데이터와 함수에 대해 연산한다는 것은 일반적으로 굉장히 computationally expensive하다. 이를 위해서 RealNVP[3]가 한 선택은 bijective에 제약을 가하여 jacobian을 triangular matrix로 구성하는 것이다.\nAffine coupling layer은 D-dimensional input $x \\in \\mathbb R^D$에서 $d \\lt D$의 일부 $x_{1:d}$를 활용하여 나머지 $x_{d+1:D}$를 affine transform한다.\n$$y_{1:d} = x_{1:d} \\\\ y_{d+1:D} = x_{d+1:D} \\cdot \\exp(s(x_{1:d})) + t(x_{1:d})$$\n이때 $s$와 $t$는 NN으로 구성한 scale과 translation function $\\mathbb R^d \\mapsto \\mathbb R^{D-d}$이다.\n이 경우 jacobian matrix는 lower-triangular matrix로 구성되고, log-determinant는 scale의 합으로 연산된다.\n$$\\frac{\\partial y}{\\partial x} = \\left[ \\begin{matrix} \\mathbb I_d \u0026amp; 0 \\\\ \\frac{\\partial y_{d+1:D}}{\\partial x_{1:d}} \u0026amp; \\mathrm{diag}(\\exp(s(x_{1:d}))) \\end{matrix} \\right] \\\\ \\log\\left|\\det\\frac{\\partial y}{\\partial x}\\right| = \\sum s(x_{1:d})$$\n이뿐만 아니라 coupling 기반의 layer는 inverse도 쉽게 연산해낼 수 있다.\n$$x_{1:d} = y_{1:d} \\\\ x_{d+1:D} = (y_{d+1:D} - t(y_{1:d})) \\cdot \\exp(-s(y_{1:d}))$$\n1.1. Masked Convolution\nRealNVP[3]에서는 partitioning을 binary mask를 통해 일반화 한다.\n$$y = b \\odot x + (1 - b) \\odot \\left( x \\odot \\exp(s(b \\odot x)) + t(b \\odot x) \\right)$$\ncoupling layer 특성상 input의 일부에는 transform이 이뤄지지 않기 때문에, 연속된 coupling layer를 구성할 때는 binary mask를 alternating 하면서 모든 feature가 transform 될 수 있도록 구성한다.\nFigure 3: Masking schemes for affine coupling layers. (Dinh et al., 2017)\nRealNVP[3]에서는 checkerboard pattern의 mask를 상정했으며 even index와 odd index를 번갈아 가며 trigging하는 방식으로 binary mask를 구성한다.\nMulti-scale architecture RealNVP[3]는 input의 spatial size와 channel size 사이의 tradeoff를 위해 squeezing을 활용한다. 2x2xC의 subsquare를 1x1x4C로 squeezing 한다면 channel을 4배가량 늘릴 수 있게 된다.\nRealNVP[3]는 multiple squeezing operation과 inter-coupling layer를 통해 여러 scale에서의 latent를 뽑고자 했다. 이때 전체 dimension이 유지되는 normalizing flow의 특성상 computational, memory cost는 고수준에서 유지되고, 부담을 줄이기 위해 각 scale에서 절반의 feature를 factorizing 한다.\n$$h^{(0)} = x \\\\ (z^{i+1}, h^{i+1}) = f^{(i+1)}(h^{(i)}) \\\\ z^{(L)} = f^{(L)}(h^{(L-1)}) \\\\ z = (z^{(1)}, \\ \u0026hellip; , z^{(L)})$$\n이 경우 latent z는 명시적으로 coarser scale의 정보와 finer scale의 정보를 분리하여 다룰 수 있게 된다. 이는 RealNVP[3]의 Appendix D.에서 확인 가능하다.\nFigure 4: Composition schemes for affine coupling layers. (Dinh et al., 2017)\n또한 intermediate representation을 직접 활용하기 때문에 gradient의 전달과 학습이 용이하다는 장점을 가진다.\nBatch normalization training signal의 효율적인 전파를 위해 여러 모델은 batch normalization을 활용한다. RealNVP[3]에서는 running statistics를 활용하여 normalization을 구성한다.\n$$x \\mapsto \\frac{x - \\tilde \\mu}{\\sqrt{\\tilde\\sigma^2 + \\epsilon}}$$\n이 경우 linear rescaling과 동일하므로 jacobian은 $\\sigma$의 곱으로 구성된다.\n$$J = \\left(\\prod_i(\\tilde\\sigma^2 + \\epsilon)\\right)$$\nTraining, Sampling\n이렇게 bijective를 활용한 invertible map $g: X \\to Z$을 구성했다면, $x \\in X$의 입력에 대해 forward pass로 latent $z = g(x) \\in Z$를 구하고, 해당 latent를 통해 log-likelihood를 추정한다.\n$$\\log p_X(x) = \\log p_Z(z) + \\log\\left|\\frac{\\partial g}{\\partial x}\\right|$$\n원문에서는 prior $p(z)$를 gaussian으로 상정하였고, 추정된 log-likelihood를 maximize 하는 방식으로 네트워크를 학습시킨다.\nsampling의 경우 prior에서 sampling한 noise $z \\in Z$를 inverse pass하여 $x = g^{-1}(z) \\in X$ 바로 사용할 수도 있고, 데이터로부터 latent를 구하여 interpolation 등 후처리 후 사용할 수도 있다.\n$$z \\sim p(z) \\mapsto g^{-1}(z) \\in X$$\nResults\nTable 1: Bits/dim results. (Dinh et al., 2017)\nFigure 6: Manifold generated from four examples in the dataset. (Dinh et al., 2017)\nDiscusion\n(사견)\nNormalizing flow의 시작이 Rezende \u0026amp; Mohamed (2015)[1]는 아니었다. density estimation을 위해 Tabak \u0026amp; Vanden-Eijnden (2010)[4], Tabak \u0026amp; Turner (2013)[5]에서 제안이 되었고, 딥러닝을 활용한 probabilistic modeling으로 Rezende \u0026amp; Mohamed (2015)[1]에서 크게 유명해졌다.\n비록 determinant와 inverse의 tractability로 인한 architectural constraint를 가지고 있지만, sampling이 single-forward pass로 가능하고, exact log-likelihood의 연산이 가능하다는 점에서 충분한 매력을 가진 모델이다.\n추후 bijective에 대한 연구, VAE와의 상관성, 통합 가능성이 연구됨에 따라 더 많은 이야기가 남은 모델이므로 관심 가지고 봐도 좋을 것 같다.\nReference\n[1] Rezende, D. J. and Mohamed, S. Variational inference with normalizing flows. In ICML 2015. [2] Kingma, D. P. and Welling, M. Auto-encoding variational bayes. In ICLR 2014. [3] Dinh, L., Sohl-Dickstein, J. and Bengio, S. Density estimation using Real NVP. In ICLR 2017. [4] Tabak, E. G. and Vanden-Eijnden, E. Density estimation by dual ascent of the log-likelihood. Communications in Mathematical Sciences, 2010. [5] Tabak, E. G. and Turner, C. V. A family of nonparametric density estimation algorithms. Communications on Pure and Applied Mathmatics, 2013.\n","permalink":"https://revsic.github.io/blog/realnvp/","tags":["Machine Learning","Deep Learning","Bayesian","Normalizing Flow","Real NVP"],"title":"Normalizing Flow, Real NVP"},{"categories":["Writing"],"contents":"올해로 1년 좀 넘게 음성 합성 리서치 업무를 보고 있다. 이번 글에선 19년 9월, 입사부터 20년 말까지 한 활동을 조심히 정리해보려 한다.\n[대학교 3학년의 2020] On 2020 as student [딥러닝 리서처의 2020] 현재 글\n입사 당시 입사 당시 우리 회사는 설립된 지 반년 정도 된 학부생 스타트업이었다.\n처음에는 대표님의 요청으로 비전 프로젝트 외주를 진행했었고, 9월에 입사하여 본격적으로 음성 업무를 보기 시작했다.\n당시 회사 인원은 나 포함 5명이었고, 각자 역할이 부여된 상황이었다. 그중 나는 TTS 리서처로 들어왔다.\n당연히 사수는 없었다. TTS 연구 개발 프레임워크는 리팩토링이 시급해 보였고, 그를 기반으로 딥러닝 리서치를 진행하는 과정이 확립되어 있지 않았다.\n모든 것을 처음부터 시작해야 하는 상황이었다. 하지만 이제 막 2학년이 끝난 학부생은 모든 게 패기로웠다.\n딥러닝 리서처 업무 음성 합성 리서치의 목표는 합성된 음성의 발음이 또렷해야 하고, 자연스러우면서, 음질이 좋아야 한다. 이후에는 다국어, 다화자, 감정 등 추가 기능 지원이 들어간다.\n논문 리뷰\n회사 들어와서 가장 먼저 한 리서치 업무는 음성 합성 논문 리스트를 만들고 쭉 리뷰 한 것이었다.\n처음 입사했을 때에는 푸리에 변환이 뭔지도 모르고 시작했다. 그냥 이렇게 저렇게 만든 스펙트로그램이란 피쳐가 있고, 딥러닝 모델이 텍스트에서 스펙트로그램으로의 매핑을 학습한다는 정도만 나이브하게 알고 있었다.\n신호처리 공부도 해야 했고, 딥러닝 모델 논문도 봐야 했다. 그렇게 1년 동안 대략 60편 정도의 논문을 보고 20개 가까이 구현해본 것 같다.\n입사 전에도 그랬지만, 시작부터 다독을 목표로 했다. 리뷰가 진행된 논문이던, 안 된 논문이던, 메이저 학회에 통과한 논문이던, 그저 arXiv에 올라온 글이던 가리지 않았다.\n논문 볼 때 정리했던 내용\n논문을 보면 항상 5가지 항목에 대해서 정리했다.\n어느 분야에서 이전 논문들에서 어떤 문제점을 발견했고 어떤 해결방법을 제시했으며 이때 생기는 이점과 발견되었거나 예상되는 약점은 무엇인지 그렇게 해서 학계의 흐름을 쫓고 있고, 올해 말부터는 이제 본인만의 실험을 기획하기 시작했다.\n딥러닝에 관심을 가지고 있던 적당한 학부생이었고, 어디서 연구하는 방법이란 것을 배워본 적이 없었기 때문에 모든 게 서툴렀다.\n논문을 볼 때 어느 것이 중요하고, 어떻게 쫓아야 하고, 무엇을 이야기하고 싶은건지, 저 5가지 질문을 확립하는데에도 꽤 시간이 걸렸던 것 같다.\n신호처리 관련 공부\n문제는 어느 시점부터, 음성 분야 논문이 단순 스펙트로그램을 넘어서 여러 가지 피쳐나 기성 신호처리 알고리즘들을 차용하여 성능을 높이는 시도가 등장했다는 것이다.\n따로 물리나 신호처리학을 공부해본 적이 없었기 때문에, 어디서부터 무엇을 공부해야 할지도 몰랐고, 처음부터 공부해서 이른 시일 안에 현업에 사용할 자신도 없었다.\n그래서 모르는 단어가 나오면, 탑다운 방식으로 구글에 단어를 검색하고, 대학 강의에 쓰인 pdf 파일을 보면서 공부했다.\n(생각보다 검색하면 잘 나옴)\n그러다 보니 틀리게 이해한 내용도 많았고, 이곳저곳 빈 곳도 많았다.\n하지만 탑다운도 결국 수렴한다고, 결국에는 틀린 이해를 정정하고, 꽤 많은 빈 곳을 채웠다는 생각이 든다.\n모델 구현\n기존에는 tensorflow를 많이 활용했었다. 하지만 회사에서는 pytorch를 사용하고 있었고, 이에 맞추기 위해 하루에서 이틀 정도는 파이토치에 적응을 좀 했던 거 같다.\n모델을 구현하기에 앞서 원저자가 구현한 오픈소스 코드가 있는지 확인했다.\n처음에는 하루 정도면 모델 하나 구현할 수 있다고, 오픈소스 찾아볼 게 있냐고 처음부터 짜는 객기를 부렸지만,\n딥러닝 코드는 버그를 잡기 어렵고, 이미 구현된 코드가 있으면 I/O 정도만 수정해서 바로 실험해볼 수 있으므로 오픈소스를 참고해서 회사 스타일에 맞게 정리하는 게 빠르다. 물론 라이센스 확인은 필수다.\n또한, 논문에 기재되지 않은 디자인 초이스나 휴리스틱이 존재할 수 있으므로 원작자의 코드 존재 여부를 우선 파악하는 것이 맞는 것 같다.\n만약 이해되지 않는 디자인이나, 기재되지 않은 하이퍼 파라미터 정보가 있다면 레딧에 물어보는 것도 괜찮은거 같다.\n(생각보다 관심을 많이 받아서 신기했음)\n실험, 문제점, 해결책\n이렇게 구현이 끝난 모델은 사전에 선정한 데이터셋으로 학습해 보고, 여러 지표를 통해 모델을 평가했다.\n문제는 생성된 음성은 원본과 1대1로 비교하는 것이 무의미하다. 음의 높낮이가 다르더라도 충분히 자연스러울 수 있고, 파형이 다르더라도 같은 발음 성분을 가지고 있을 수 있다.\n이러다 보니 1대1로 비교하는 것은 무의미하고, 길이가 다른 시퀀스의 유사도나, ASR 모델을 활용하여 의미 있는 평가를 자동화하기 위한 여러 추가 연구도 진행했었다.\n그렇게 모델을 평가하고 나면 문제점이 나타난다. 이 모델은 발음을 못 한다, 이 모델은 음질이 안 좋다. 등등 그럼 기존까지 관찰된 여러 모델의 현상을 통해 단점을 커버하기 위한 추가 실험을 진행한다.\n아직은 딥러닝이라는 분야가 특정된 데이터셋과 컴퍼넌트의 상호작용을 연역적으로 분석하기 어려우므로 현상과 실험적인 접근이 최선인 것 같다는 생각이 든다.\n그래서 조금 답답하기도 하다.\n연구하는 방법을 배운 기분\n위에 엄청 대단한 거 마냥 글을 썼지만, 사실 당연한 연구 루틴이었을지도 모른다.\n앞서 이야기했듯, 나는 그냥 딥러닝에 관심이 있던 학부생이었고, 연구라는 것을 해보거나 배워본 적이 없기 때문에 1년 동안은 정말 벽에 부딪치며 연구하는 방법을 배운 거 같다.\n실제로 처음에는 그냥 성능을 높이는 게 목적이니 닥치는 대로 논문을 읽고, 시간 되는 대로 구현하고, 뭐가 안되면 모델 잘못이네, 수정은 하이퍼 파라미터 튜닝하는 정도였다.\n그러다 이제 타임라인이 현재에 도달해서, 과거 논문을 구현하는 것이 아니면 추가로 볼 논문이나 모델이 없는 시점에 왔다. 이제는 모델 탓만 할 것이 아닌, 어떤 문제가 있고, 어떻게 해결해야 할지에 대한 고민을 해야 하는 상황이다.\n올해 말이 되어서야 나는 가설이라는 걸 세워보고, 실험을 통해 증명하고, 개선하는 일련의 프로세스를 확립해서 업무에 적용해 보고 있다.\n그 과정에서 평가 지표도 자동화했고, 컴퍼넌트랑 지표의 상관성, 현상과의 연관성도 하나씩 알아보고 있다.\n결과를 보는 그 과정이 재미로 다가왔다. 이제야 길이 환해진 느낌이 든다.\n엔지니어링 업무 입사해서 연구 관련 업무만을 볼 수는 없었다.\n딥러닝 프레임워크\n딥러닝 모델 개발은 생각보다 여러 가지 코드를 수반한다.\n단순 텍스트 파일과 wav 파일로 이뤄진 데이터를 전처리하여 저장하기 위한 코드도 필요하고,\n저장된 데이터를 불러와 모델에 전달, loss를 계산하여 업데이트하는 학습 과정,\n학습이 얼마나 잘 되어 가고 있는지, 모델이 어느 정도 수준을 성취했는지 기록하는 과정,\n마지막으로 모델을 통해 서비스를 작동시킬 수 있도록 캡슐화시키고 배포하는 과정 등이 있다.\n나는 개발, 학습, 기록, 캡슐화 정도의 과정을 맡았고, 전처리, 후처리, 서비스 개발 및 배포 과정은 다른 분이 맡았다.\n이 중에서 배포 과정을 뺀 모델 개발 전 과정을 하나의 구조로 엮은 프레임워크가 있었는데,\n코딩 컨벤션이나 문서화도 따로 되어 있지 않았고, 깃은 단순 코드 보관용, 모델 캡슐화는 코드 전체와 체크포인트를 복붙하여 압축파일(?)로 저장하는 구조로 되어 있었다.\n9월에 입사한 나는 회사 규모가 커졌을 때, 이 모든 코드가 레거시로 남을게 뻔히 보여 더 커지기 전에 갈아엎을 것을 제안했고, 팀장님도 이에 수긍하셔 11월까지 3개월간의 대규모 리팩토링에 들어간다.\n협업 약속\n가장 먼저 제안한 것은 브랜치, PR, 코드 리뷰의 3가지 과정이다.\n기존까지 모든 코드는 마스터로 들어가고 있었고, 혼자 개발하고 계셨기 때문에 브랜치나 PR의 개념이 없었다.\n이젠 둘이 개발해야 하는 상황이고, 마스터는 항상 stable한 상태로 두어야 한다는 전제를 깔았다. 그러고 나니 브랜치, PR, 코드 리뷰는 당연히 쫓아오는 과정이었다.\n또 하나는 문서화를 제안했다. 당장 리팩토링을 하려고 보니, 음성 합성 지식이 전무했던 나에겐 주석 하나 없는 코드가 어떤 역할을 하는지 몰랐다.\n당시에는 회사에 오래 있을지 모르는 상황이었기에, 다음 사람이 오면 똑같은 일이 일어날 것이고, 이제는 코딩 컨벤션과 주석을 의무적으로 달아야 한다고 전달했다.\n의견은 모두 받아들여졌고, 가장 근간이 되는 토대를 확립하고 나서야 리팩토링을 진행할 수 있었다.\n리팩토링\n가장 먼저 한 것은 각 과정에 맞게 레이어를 분리한 것이다.\n모델 클래스를 추상화하고, 이를 토대로 학습, 기록, 추론 과정을 어플리케이션 레이어로 분리했다.\n모델을 개발하면 더 이상 복사 붙여넣기 없이, hyper-parameter와 체크포인트만 가지고 모델을 작동시킬 수 있게 되었다.\n딥러닝 컴퍼넌트 중 중복된 코드는 분리하고, 어텐션 모듈같이 추상화가 요구되는 것들은 레이어를 하나 더 두었다.\n문제는 전처리 코드였는데, 이 부분은 음성 합성 지식이 전무한 나에겐 함부로 건드릴 수 없는 부분이었다. 결국 전처리 레이어를 두고, 어플리케이션에서 사용 가능하게 두되, 내용물은 레거시 코드에서 가져온 것을 래핑 해둔 정도로 놔둬야 했다.\n쓰다 보니 정말 당연한 리팩토링 수순을 밟았지만, 그렇게 만들어진 당시의 프레임워크는 정말 간결했고, 개발자 친화적이었다.\n돌고 돌아\n하지만 리팩토링된 프레임워크는 1년이 된 시점에서 망가지기 시작했다.\n회사는 바빴고, 코드 퀄리티가 떨어지더라도 당장에 작동하는 듯 보이는 코드가 필요했다.\n처음과 달리 코드 리뷰는 약식화 되어 갔고, 코드에 구멍이 나기 시작했다. 점점 핫픽스 브랜치가 늘어났고, 원인과 여파의 분석 없이 당장 필요한 부분만 작동하면 머지를 해야 했다.\n한 1년 즈음 까지는 나라도 붙잡고, 나라도 리뷰 열심히 해야지 하고 이런저런 리뷰를 남겼지만, 어느 순간부터 나도 포기했다.\n회사는 결국은 돈을 벌어와야 했고, 회사가 요구하는 연구 방향이나 개발 방향이 설정된다. 급하다는 이유로 언제 터질지 모르는 구멍을 보고도 모른 척 하게 된 것이다.\n이제는 프레임워크가 거의 제구실을 하지 못한다.\n작동하는 모델은 상용화된 것 몇 개 뿐이고, 연구용으로 남긴 모델은 작동하지도 않는다. 중간에 experimental feature라고 분리도 해봤지만, 이젠 마스터 브랜치의 모델도 돌아가는 것은 몇 개 없다.\n그 외에 학계의 움직임에도 영향을 받았다.\n이젠 기성 신호처리 기법들이 딥러닝과 연계되어 들어왔고, 프레임워크는 그에 필요한 새로운 피쳐나 출력물들까지 모두 처리할 수 없었다.\n입출력 파이프라인은 난잡해졌고, 결국 안 좋은 의미의 레거시로의 길을 걷고 있는 것 같았다.\n앞으로\n올 11월 즈음, 나는 더 이상 가면 되돌릴 수 없다는 걸 깨달았다.\n하지만 새로운 서비스를 준비하고 있던 팀에는 그걸 모두 뜯어고칠 시간이 없었다. 매일 새로운 실험을 통해 모델을 개선해야 했고, 모델 변형, 실험, 정리, 새 실험 기획만 하다가도 날이 저물었다.\n결국 이번 모델 개발이 끝나면, 기간을 잡고 리팩토링을 하거나 새로운 프레임워크를 구성하자는 이야기를 꺼냈다.\n이다음에 프레임워크를 재구성하게 된다면, 그때는 지금과 다를 수 있을지 의문이 들기는 한다.\nCUDA까지 내려갔다 오면 음성은 보통 초당 16k, 22k, 44k 정도의 프레임을 샘플링 하는데, 19년 말, 20년 초까지만 해도 이 프레임 수에 합성 시간이 비례했다.\n음성 길이가 길어지면 합성 시간도 길어졌고, 1초의 음성을 만드는데 대략 10초 정도 걸렸던 거 같다.\n당연히 실시간 서비스에 사용하기는 어려웠고, 프레임 수에 합성 시간이 비례하지 않는 모델을 찾아봤지만, 음질이 좋지 않아 결국 돌아오게 되었다.\n모델 가속화\n올해 초 모델을 가속화 하라는 특명이 떨어졌다. 대략 1초 합성에 1초 언저리 즈음 걸리도록\n여러 가지 찾아봤다. TensorRT, TorchScript JIT, ONNX 등등\n하지만 공통적인 문제가 있었다.\n기본적으로 당시 음성 합성 기술은 대부분이 하나의 프레임을 만들고, 해당 프레임을 토대로 새로운 프레임을 만드는 자기 회귀(autoregressive) 방식으로 작동하고 있었고, 언제 회귀를 끝낼지는 동적으로 판단하기 때문에\niteration 수가 정해져 있어야 하고, 자기 회귀 없이 forwarding만을 지원하는 가속화 도구 대부분을 사용할 수 없었다.\n모델을 분리하여, 병목이라도 가속화 해보려 했지만, 극적인 성능 향상 없이 대부분 1.7배, 2배 정도만 빨라졌다.\n목표는 10배이고, 상용 프레임워크는 불가능했기에, 결국 눈을 질끈 감고 CUDA 프레임워크를 개발하기로 했다.\n결국 CUDA\n팀 내에서 CUDA를 다룰 줄 아는 사람은 없었기에, 급하게 CUDA 서적을 구매해 예시 코드 몇개 적어보고 가속화 작업에 착수했다.\n결론부터 이야기하면, 대략 2주 만에 7배 빠른 추론 가속화용 CUDA C++ 프레임워크를 개발해냈다.\n내 손으로 텐서플로를 만들어 본다는 기분으로 시작했다.\nCUDA 메모리를 추상화하고, shape과 blob으로 구성된 텐서 구조체를 설정하고, 텐서에서 작동하는 여러 연산을 CUDA 커널로 구현했다.\n이후 문제의 모델을 C++에서 재구현하고, 파이토치 체크포인트에서 weight을 불러올 수 있는 기능을 추가했다.\n그렇게 만든 CUDA 프레임워크는 처음에 PyTorch보다 느렸다. 당시 야근을 하고 있었는데, 팀장님이랑 같이 한숨부터 쉰 기억이 있다.\n이제 하나씩 최적화를 시작했다. 그 중 몇 가지만을 소개하려 한다.\n가장 먼저 한 것은 TensorView를 만든 것이었다.\nreshape, transpose나 slice의 경우에는 값의 수정 없이 tensor를 보는 관점만 바뀐 것인데, 연산 과정에 매번 값을 복사하여 새로운 Tensor를 만드는 것은 비효율적이다. 따라서 같은 메모리를 공유하되, 값은 수정하지 못하고, stride나 shape만을 수정 가능한 view를 두는 것이 좋다.\n두 번째는 메모리 매니저를 따로 둔 것이다.\n자기 회귀(AR) 모델처럼 연산이 가볍지만, 반복이 많은 경우에는, 프로파일링을 해보면 연산보단 메모리의 할당과 해제에 병목이 걸리는 경우가 많았다.\n당시에 힙 메모리와 malloc 관련 공부를 하고 있었고, 메모리 관리 기법에서 영감을 얻었다.\nCUDA 에서 할당받은 메모리는 사용 직후 바로 반환하기보다는, 크기별로 분류해 두었다가, 메모리 요청이 왔을 때 적절한 메모리가 있으면 CUDA를 안 거치고 반환, 아니면 CUDA 에서 추가 할당받는 식으로 매니저를 구성해서 시간을 많이 줄일 수 있었다.\n그렇게 해서 총 7배 정도가 빨라졌고, 대략 1.5초에 1초 음성 정도를 만들었다.\n이후에 pybind11 활용해서 파이썬으로도 매핑하고, C++ 개발자 아니어도 쓸 수 있게 구성을 해놨지만\n여러 이유로 프로젝트는 폐기되고, 죽은 기술이 되었다.\n회사에 묶여서 공개하지 못하는 게 아쉽기도 하다.\nCUDA 개발 정리하면서\nCUDA 개발하면서 그래도 느낀 점이 좀 있었다.\n왜 torch에는 view와 reshape이 따로 있을지, contiguous가 필요한 이유가 뭘지, 왜 채널 크기는 32의 배수로 설정되는 것인지 등등 실상은 많은 디자인이 GPU와 CUDA 에 의해 결정되고 있었다.\n딥러닝 하는 분들한테 추천해볼 법한 프로젝트였던 것 같고, 죽은 기술로만 두는 것이 아쉬워 이번 겨울에 개인적으로 러스트와 rustacuda를 통해 재구현해 볼 생각이다.\n정리 다사다난한 한 해였다. TTS, 보코더 연구부터 프레임워크, CUDA 개발까지 여러 가지 해본 것도 많았다.\n회사 인원도 거진 20명에 가까워지고 있고, 팀과 역할도 더욱 세분되어 동아리처럼 시작했던 것이 더욱 회사 같아졌다.\n내년에 목표가 있다면, 지금 정리 중인 모델을 마무리 짓고 개인적으로 논문도 한 편 써 보고 싶다.\n한 해를 잘 정리한 거 같아 후회는 없다. 내년에도 딱 이만큼만 했으면 좋겠다.\n","permalink":"https://revsic.github.io/blog/on2020dev/","tags":["Writing","2020","Researcher","TTS"],"title":"On 2020 as researcher"},{"categories":["Writing"],"contents":"첫 회고 사실 작년 이맘때부터 회고를 써야겠다 고민을 했는데, 미루고 미루다 결국 올해 끝이 되어서야 회고를 쓰게 되었다.\n어떤 이야기를 써야 할까 고민을 하다가 올해를 정리하는 의미에서 큰 부담 없이 2020년에 한 일을 돌아보려 한다.\n첫 글에는 대학교 3학년으로의 2020년, 두 번째 글은 2년 차 딥러닝 리서처로의 2020년에 관해 쓸 것이다.\n[대학교 3학년의 2020] 현재 글 [딥러닝 리서처의 2020] On 2020 as researcher\n신종코로나 COVID-19 2020년 하면 당연히 코로나를 빼놓을 수 없는 거 같다.\n19년 12월 말, 중국 우한에서 원인 불명의 바이러스성 집단 폐렴이 발생했다. 이후 이는 신종코로나 바이러스, COVID-19라고 명명되었고 전 세계를 팬데믹에 몰아넣는다.\n당장 백신은 없고, 사망하는 사람은 생기고, 전염성마저 강하니 거리 두기와 마스크는 생활화되어 갔다.\n문제는 당장 내일 출근할 때 쓸 마스크를 구하기 어려울 정도로 마스크의 공급이 수요를 따르지 못했고, 사재기도 있었을 테지만, 직장 동료분이 막 급하게 \u0026ldquo;지금 ! 쿠팡 열렸어요 !\u0026rdquo; 하면 대기하다 알트탭 쳐서 마스크 사는 일도 있었다.\n마스크를 구하는 것만이 문제는 아니었다. 평소 황사 철 아니면 쓰지도 않던 마스크를 근무 내내 끼고 있으니 피부가 버티질 못해 트러블이 생기고, 마스크 쓰고 출퇴근을 하면 숨이 가빠 평소보다 더 힘든 기분이었다.\n(그래도 마스크 열심히 쓰고 다녔음)\n사회적 거리 두기는 그래도 할만했다. 어차피 책상에서 멀리 가는 성격도 아니고, 원래도 집에서 잘 안 나갔는데 합법적으로 집에 있는 기분이었다.\n이런 생활이 1년간 이어지다 보니, 이젠 지각할 거 같으면 마스크 쓰고도 역에서 회사까지 뛰어가고 그런다. 오히려 밖에서 담배를 피우거나 이런 사람도 많이 줄어든 거 같고, 중국발 황사도 줄어 봄철 피부염도 거의 없었다. 자택 근무도 너무 적응해버린 거 아닌가 싶을 때가 있다.\n이제 백신도 나왔고, 슬슬 줄어들 때가 된 거 같아 다행이다. 빨리 줄어들어서 맘 놓고 놀러 다니고 싶다.\n3학년 학교 생활 올해 한 가장 큰 실수는 역시 학교랑 회사랑 같이 다닌 거 같다.\n코로나라 자택 근무까지 하니까, 퇴근 시간 아끼는 만큼이라도 공부할 거 같았는데, 막상 시험 기간 아니면 잘 안 하게 되더라. 뭔가 한 가지에 집중한 것도 아니고, 이것저것 얕게 보는 느낌이었다.\n그래도 시험 기간이나, 회사 스퍼트 기간에는 한쪽에 집중하려 노력한 거 같다. 시험 기간에는 9시-6시 칼퇴근하고 남는 시간에 시험공부 하고, 스퍼트 때는 자기 전에 실험 결과 확인하고 추가 실험 기획해 놓기도 했다.\n뭔가 나이 대비 빠르게 경력이나 졸업을 당기는 데는 도움이 될 수 있어도, 내가 어떤 것에 숙련할 수 있는가를 보면 썩 좋은 선택은 아닌 거 같다.\n(500페이지 정도 분량 써가면서 공부함 그래도 ㅠ)\n컴공 3대장 - 컴퓨터구조론, 운영체제, 컴파일러\n개인적으로 컴공 3대장이 있다면 컴구, 운체, 컴파일러 3개이지 않을까 싶다. 이 중 운영체제와 컴파일러 과목을 각각 3-1, 3-2에 듣게 되었다.\n2학년 2학기에 C로 DB를 만드는 수업이 있었고, 이때 워낙 고생을 많이 했던 터라 같은 교수님이 운영체제를 맡으셨을 때는 고민을 좀 했던 것 같다.\n교수님은 정말 좋은 분이셨기에, 적당히 수업 들으면서 과목별 투자 시간에 대한 가성비 싸움을 할지, 아님 운체에 올인을 하고 다른 과목의 시간을 나눌지, 아니면 다른 교수님 강의를 들을지 고민했다.\n결국 수업을 포기할 수는 없었기에 전자를 골랐고, 그거랑 별개로 그냥 기한이 있는 줄 몰랐던 과제 OT 7개를 놓쳐서 성적은 반 토막 났다..ㅎ\n과제는 xv6에 MLFQ 기반의 CPU Scheduler, Thread 기능 추가, Filesystem 최대 크기 확장 등이 있었다. 이 중 MLFQ, Thread 정도를 선택과 집중했고, 성적과 별개로 만족스러운 수업이었다.\n컴파일러 역시 정말 좋은 교수님이 수업을 여셨고, 운체와 달리 과제가 많은 교수님은 아니셨기에, 과제 공지가 올라오면 하루 날 잡고 완성했던 것 같다.\n실제로 loucomp tiny C를 시작으로 컴파일러를 재구성하는 수업이었고, 언어 스펙에 따라 파싱을 위한 state machine을 구성하고, 타입을 체크하는 루틴을 추가하였다.\n[OS]: github HYU-ELE3021 [Compiler]: github HYU-ELE4029\n수학과 부전\n드디어 꿈꿔오던 수학과 수업을 정식으로 듣게 되었다.\n고등학교 때부터 수틀리면 컴퓨터 전공 때려치우고 수학과 가겠다고 담임 선생님한테 투정을 부렸었는데, 결국 돌고 돌아 컴퓨터 전공에 부전공을 수학으로 잡게 되었다.\n문제는 학교 정책상 부전공으로 이수해야 하는 과목 수가 정해져 있는데, 수학과는 학년당 3과목 정도가 책 한 권을 1년 동안 배우다 보니 (선대1, 선대2 등) 졸업을 위해서 무조건 들어야 하는 과목들이 몇 개 있다.\n그중 하나가 선형대수였는데, 나는 심지어 공대에서도 선형대수를 들어 총 3학기의 선형대수를 듣게 되었다. (1학년 2학기, 3학년 1,2학기)\n물론 조금 다르긴 하지만, 수강한 교수님 특성상 응용 파트가 많다 보니 실상은 크게 다르지 않았다. 오히려 대수를 많이 못 다뤄 아쉬웠다.\n그리고 또 하나는 해석학이었다. 일전에 해석학 공부하겠다고 혼자 책을 사 와서 폈는데, 첫 장부터 문제를 못 풀어 접었던 기억이 있다.\n실은 이것 때문에 더욱 수학과 부전에 대한 기대가 있었지만, 교수님이 증명 팁을 알려주시는 그런 건 없었고 그냥 연습 문제 풀다 보니 되더라 ! 가 정답인 거 같다.\n주변의 권유로 4학년 과목인 확률론도 들었다. 선이수 과목인 실해석학을 안 듣고 온 사람이 나 말고도 더 있어서, 수업 초반부는 그 설명으로 시간을 좀 쓴 것 같다.\n아무래도 딥러닝, 머신러닝 하면서 확률을 다루는 사람이다 보니, 그 기저에는 어떤 정의와 연역으로 구성되었을지에 대한 기대가 좀 있었다. 나는 딥러닝에서도 음성 응용을 다루다 보니, 직접적으로 도움이 되었다 ! 보다는, 학술적으로 이러한 의미와 가치가 있었구나에 대해 새로 알게 된게 컸다.\n그렇게 해서 3학년에 선형대수, 해석학, 확률론 3개 과목을 들었고, 2학기 해석학 확률론 성적이 1학기에 비해 반토막 난 걸 보니 눈물이 찔끔 났다.\n나름 올인했었는데.. 그래서 난 대수가 더 좋다.\n여행 올해 코로나로 여행도 잘 못 다녔다. 그러다 보니 무슨 일이 있지 않고서야 멀리 갈 엄두도 못 냈던 거 같다.\n부산 친구 군대 보내기\n3학년쯤 되니 친구들이 다 군대에 갔다. 남아 있는 친구들이 손에 꼽을 정도이다.\n나는 이유는 모르겠지만 경남 출신 친구들이 많았고, 군대 간다고 휴학한 친구 만나러 부산에 당일치기로 놀러 갔었다.\n부산에 도착했을 때는 정말 충격이었던 게 4월 당시 부산 확진자 수는 굉장히 적었고, 마스크를 쓰는 사람도 거의 없었다. 마스크를 쓰고 있으면 여행객인가 ? 싶을 정도였다.\n가서 텐동도 먹고, 장어덮밥도 먹고, 바닷가도 걸으며 이런저런 얘기를 했었다.\n(텐동 맛있엉)\n호캉스 - 시그니엘 서울\n여름이 되었고, 연차는 썼고, 뭐라도 하고 싶다는 생각이 강하게 들었다. 코로나라 돌아다니거나 멀리 가는 건 힘들 거 같아서, 간단히 호캉스나 1박 2일 다녀와야겠단 생각이 들었다.\n이곳저곳 알아보다가 자본주의를 좀 느껴보잔 생각에 롯데 시그니엘을 가기로 마음먹었다. 100층 가볼 일이 얼마나 있겠어~ 라는 생각으로 객실을 예약했다.\n(사진이 몇장 없음 ㅠ)\n호텔에 도착해서 100층까지 가는 엘리베이터를 처음 타봤다. 중간에 멈추는 구간은 몇 개 없었고, 부우우웅 하고 올라가더니 귀가 먹먹했다.\n도착해서는 라운지에서 샴페인도 마시며 즐거운 시간을 보내고 왔다.\n중간에 수영장도 갔는데, 초등학생 이후 수영을 해본 적이 없었기에 이게 되려나 ? 싶다가도 몸은 기억한다고 그새 또 막 돌아다니고 있는 게 신기했다.\n저녁은 룸서비스를 시켜 먹었고, 조식은 뷔페를 가서 먹었다.\n(진짜 후회 안할만큼 맛있었음)\n함께 사 온 와인이랑 룸서비스로 시킨 스테이크, 파스타 모두 잘 어울렸다. 조식 뷔페는 샐러드, 빵, 육류 3가지 정도로 구성된 파트가 있었고, 뭐 하나 빠짐없이 깔끔했다.\n잘 먹고, 잘 놀다 집에 돌아오니 이래서 호캉스, 호캉스 하는구나 싶었다.\n운전면허 드디어 운전면허를 땄다.\n작년 말부터 딸거다 딸거다, 말만 하다가, 이번 11월에 드디어 운전 연습 학원을 등록했다.\n10시간 강습, 거의 80만원 가까운 등록금에, 시험은 때마다 5만원씩 내야 하니 한 번에 합격해도 거진 100만 원 가까이 쓰게 된다.\n정말 한 번에 붙어야겠다는 일념으로 연습 열심히 했다.\n기능 때는 노란선 한 번 밟고 컷트라인에 걸쳐서 한 번에 붙고, 주행 때는 합격 했는데 점수를 안 알려줘서 뭘 실수했을지는 잘 모르겠다.\n면허가 발급되고, 가족이랑 같이 연습 삼아 운전을 좀 하고 돌아다녔는데, 확실히 10시간 교육받고 면허까지 따니 큰 문제 없이 잘 돌아 다녔다.\n정리 회사랑 학교랑 같이 다니다 보니, 일하다 공부하다 1년이 지나갔다. 코로나 때문에 금방 간 건가 싶기도 하다.\n그래도 사람 종종 만나고, 확진자 적을 때는 여행 아닌 여행도 다녀와서 만족스럽게 한 해를 보낸 거 같다.\n내년부터는 아마 휴학계를 내고, 회사 일에 전념할 것 같다.\n당분간은 얕고 넓게 보다는, 회사에서는 음성 딥러닝 쪽을, 개인적으로는 관심 있던 논문 리뷰, 구현하며 한 토픽에 대해 깊이 있는 공부를 해볼 예정이다.\n그 외의 부분에 대해서는 딱 올해만큼만 살았으면 좋겠다.\n다음 글 [딥러닝 리서처의 2020] On 2020 as researcher\n","permalink":"https://revsic.github.io/blog/on2020stud/","tags":["Writing","2020","Student","Undergraduate"],"title":"On 2020 as student"},{"categories":["Vocoder"],"contents":" Diffusion: Ho et al., 2020, arXiv:2006.11239 WaveGrad: Nanxin Chen et al., 2020, arXiv:2009.00713 DiffWave: Zhifeng Kong et al., 2020, arXiv:2009.09761 Keyword: Denoising, Diffusion, Vocoder Problem: Quality and generation speed trade off on mel-inversion procedure. Solution: Denoising and diffusion based raw audio sampling. Benefits: Explicit trade off between speed and quality in single framework. Contribution: First use of denoising \u0026amp; diffusion model on vocoder, high fidelity audio generation, explicit trade off, etc. Weakness or Future work: - Mel-inversion\nNeural Text-to-Speech (TTS) 분야는 WaveNet(Oord et al., 2016), Char2Wav(Sotelo et al., 2017), Tacotron(Wang et al., 2017)을 거쳐 발전해 왔다. 그 중 Tacotron의 경우 text에서 mel-spectrogram을 예측하여 vocoder를 통해 raw-audio signal로 mel-inversion 하는 방식을 취한다.\n현재는 많은 mel-inversion 모델들이 개발되었고, autoregressive 구조로 raw-audio와의 likelihood를 maximizing 하는 WaveNet(Oord et al., 2016), WaveRNN(Kalchbrenner et al., 2018), ExcitNet(Song et al., 2019a), LPCNet(Valin \u0026amp; Skoglund, 2019) 등의 모델이 있다.\n하지만 이 경우 high sample rate를 가진 음성을 생성할 때 방대한 양의 frame 수에 비례하는 샘플링 시간을 가진다는 점에서 autoregressive의 근본적인 한계를 가지고 있었다.\n이를 해결하고자 non-autoregressive vocoder의 연구가 활발해졌고, IAF를 기반으로 한 PWN(Oord et al., 2018), Glow를 기반으로 한 WaveGlow(Prenger et al., 2019), FloWaveNet(Kim et al., 2019), GAN을 기반으로 한 WaveGAN(Donahue et al., 2018), MelGAN(Kumar et al., 2019), PWG(Yamamoto et al., 2020), HooliGAN(McCarthy \u0026amp; Ahmed, 2020) 등이 발표되었다.\nWaveGrad는 non-autoregressive vocoder 연구의 연속으로 raw signal의 log-density에서 gradient를 estimation 하는 방식으로 작동한다. 이를 통해 모델은 refinement step의 수를 조절함으로써 inference speed와 sample quality 사이의 trade off를 직접적으로 조절할 수 있게 되었고, autoregressive와 non-autoregressive 사이의 격차를 잇는 역할을 한다.\nDenoising Diffusion Proabilistic Models, Jonathan Ho et al., 2020\nWaveGrad와 DiffWave의 모델링은 기본적으로 Denoising Diffusion Model(Ho et al., 2020)을 따른다.\nFigure 2: The directed graphical model considered in this work. (Ho et al., 2020)\nDiffusion 모델은 finite step의 markov chain을 가정하여, 매 transition마다 sample에 noise를 더해간다. 이후 denoising을 위한 NN 모델을 두고 Diffusion의 reverse process를 학습하여 gaussian noise로부터 sample을 순차적으로 denoising하는 방식이다. 학습은 analytic 하게 구한 diffusion의 posterior와 denoising process 사이의 KL-divergence를 줄이는 방식으로 작동한다.\nFormulation\nDenoising model은 gaussian $p(\\mathrm x_T) = \\mathcal N(\\mathrm x_T; 0, I)$을 시작으로, 동일한 dimension을 가지는 latent $\\mathrm x_{T-1}, \u0026hellip;, \\mathrm x_{1}$을 거쳐 sample $\\mathrm x_0 \\sim q(\\mathrm x_0)$로 향하는 latent variable model로 표현한다.\n$$p_\\theta(\\mathrm x_0) := \\int p_\\theta(\\mathrm x_{0:T})d\\mathrm x_{1:T}$$\n여기서 $p_\\theta(\\mathrm x_{0:T})$를 reverse process라 정의하고, markov chain으로 모델링하면 다음과 같다.\n$$p_\\theta(\\mathrm x_{0:T}) := p(\\mathrm x_T)\\prod^T_{t=1}p_\\theta(\\mathrm x_{t-1}|\\mathrm x_t)$$\n$$p_\\theta(\\mathrm x_{t-1}|\\mathrm x_t) := \\mathcal N(\\mathrm x_{t-1}; \\mu_\\theta(\\mathrm x_t; t), \\Sigma_\\theta(\\mathrm x_t; t))$$\ndenoising, diffusion 모델이 다른 latent variable model과 다른 점은, diffusion process를 analytic 하게 정의하여 posterior를 직접 approximate 한다는 것이다. End-to-End로 full transition을 학습하는 것이 아닌, state에 직접적인 constraint를 가한다.\nHo et al., 2020. 에서는 diffusion process를 모델에 noise를 더하는 markov chain으로 정의하고, 더해질 noise의 variance를 scheduler sequence $\\beta_1, \u0026hellip;, \\beta_T$로 두어 다음과 같이 정의한다.\n$$q(\\mathrm x_{1:T}|\\mathrm x_0) := \\prod^T_{t=1}q(\\mathrm x_t|\\mathrm x_{t-1})$$\n$$q(\\mathrm x_t | \\mathrm x_{t-1}) := \\mathcal N(\\mathrm x_t; \\sqrt{1 - \\beta_t}\\mathrm x_{t-1}, \\beta_t \\mathrm I)$$\n이는 autoregressive하게 정의하는 대신, $\\mathrm x_0$에 직접 condition 하는 방식으로 표현할 수 있다.\n$$q(\\mathrm x_t|\\mathrm x_0) = \\mathcal N(\\mathrm x_t; \\sqrt{\\bar \\alpha_t}\\mathrm x_0, (1 - \\bar \\alpha_t)\\mathrm I) \\\\ \\mathrm{where}\\ \\alpha_t = 1 - \\beta_t, \\ \\bar\\alpha_t = \\prod^t_{s=1}\\alpha_t$$\n이렇게 되면 nll에 대한 variational lower bound는 state 사이의 KL-divergence로 rewriting할 수 있다.\n$\\mathbb E[-\\log p_\\theta(\\mathrm x_0)] \\\\ \\le \\mathbb E_q\\left[-\\log \\frac{p_\\theta(\\mathrm x_{0:T})}{q(\\mathrm x_{1:T}|\\mathrm x_0)}\\right] \\\\= \\mathbb E_q\\left[ -\\log p(\\mathrm x_T) - \\sum_{t\\ge 1} \\log\\frac{p_\\theta(\\mathrm x_{t-1}|\\mathrm x_t)}{q(\\mathrm x_t|\\mathrm x_{t-1})} \\right] \\\\= \\mathbb E_q\\left[ -\\log p(\\mathrm x_T) - \\sum_{t\\ge 1} \\log\\frac{p_\\theta(\\mathrm x_{t-1}|\\mathrm x_t)}{q(\\mathrm x_{t-1}|x_t)} \\cdot \\frac{q(\\mathrm x_{t-1})}{q(\\mathrm x_t)} \\right] \\\\=\\mathbb E_q\\left[ -\\log\\frac{p(\\mathrm x_T)}{q(\\mathrm x_T)} - \\sum_{t\\ge 1} \\log \\frac{p_\\theta(\\mathrm x_{t-1}|\\mathrm x_t)}{q(\\mathrm x_{t-1}|\\mathrm x_t)} - \\log q(\\mathrm x_0) \\right] \\\\=D_{\\mathrm{KL}}(q(\\mathrm x_T)||p(\\mathrm x_T)) + \\mathbb \\sum_{t\\ge 1} D_\\mathrm{KL}(q(\\mathrm x_{t-1}|\\mathrm x_t)||p_\\theta(\\mathrm x_{t-1}|\\mathrm x_t)) + H(\\mathrm x_0)$ 이 때 $q(\\mathrm x_{t-1}|\\mathrm x_t, \\mathrm x_0)$의 analytic form은 다음과 같다.\n$$q(\\mathrm x_{t-1}|\\mathrm x_t, \\mathrm x_0) = \\frac{q(\\mathrm x_t|\\mathrm x_{t-1})q(\\mathrm x_{t-1}|\\mathrm x_0)}{q(\\mathrm x_t|\\mathrm x_0)} = \\mathcal N(\\mathrm x_{t-1}; \\tilde \\mu_t(\\mathrm x_t, \\mathrm x_0), \\tilde \\beta_t \\mathrm I) \\\\ \\mathrm{where} \\ \\tilde\\mu_t(\\mathrm x_t, \\mathrm x_0) := \\frac{\\sqrt{\\bar a_{t-1}}\\beta_t}{1 - \\bar a_t}\\mathrm x_0 + \\frac{\\sqrt{\\alpha_t}(1 - \\bar\\alpha_{t-1})}{1 - \\bar\\alpha_t}\\mathrm x_t \\ \\ \\mathrm{and} \\ \\ \\tilde\\beta_t := \\frac{1 - \\bar\\alpha_{t-1}}{1 - \\bar\\alpha_t}\\beta_t$$\nReparametrization\n각각의 Dkl term을 순서대로 $L_T, L_{1:T-1}, L_0$로 정의하면, $L_T$는 beta를 learnable 하지 않은 constant로 가정할 때 상수로 고정되기 때문에 연산에서 제외한다.\n$L_{1:T-1}$은 $\\Sigma_\\theta(\\mathrm x_t, t) = \\sigma^2_t\\mathrm I$의 경우 untrained constants로 제외하고, $\\mu_t$에 대해서만 학습을 진행한다. $\\sigma_t$는 $\\sigma_t^2 = \\beta_t$나 $\\sigma^2_t = \\tilde\\beta_t = \\frac{1 - \\bar\\alpha_{t-1}}{1 - \\bar\\alpha_t}\\beta_t$로 실험적으로 설정하였다. 이는 data에 대한 reverse process entropy의 upper, lower bound라고 한다.\n$\\mu_\\theta(x_t, t)$는 KL에서 trainable term을 구축한다.\n$$L_{t-1} = \\mathbb E_q\\left[ \\frac{1}{2\\sigma^2_t}||\\tilde\\mu_t(\\mathrm x_t, \\mathrm x_0) - \\mu_\\theta(\\mathrm x_t, t)||^2 \\right] + C$$\n이를 previous term을 통해 다시 써보면 다음과 같다.\n$L_{t-1} - C \\\\=\\mathbb E_q\\left[ \\frac{1}{2\\sigma^2_t} \\left|\\left| \\frac{\\sqrt{\\bar\\alpha_{t-1}}\\beta_t}{1 - \\bar\\alpha_t}\\mathrm x_0 + \\frac{\\sqrt{\\alpha_t}(1 - \\bar\\alpha_{t-1})}{1 - \\bar\\alpha_t}\\mathrm x_t - \\mu_\\theta(\\mathrm x_t, t) \\right|\\right|^2 \\right] \\\\=\\mathbb E_q\\left[ \\frac{1}{2\\sigma^2_t} \\left|\\left| \\frac{\\sqrt{\\bar\\alpha_{t-1}}\\beta_t}{1 - \\bar\\alpha_t}\\frac{1}{\\sqrt{\\bar\\alpha_t}}(x_t - \\sqrt{1 - \\bar\\alpha_t}\\epsilon) + \\frac{\\sqrt\\alpha_t(1 - \\bar\\alpha_{t-1})}{1 - \\bar\\alpha_t}x_t - \\mu_\\theta(x_t, t) \\right|\\right|^2 \\right] \\\\=\\mathbb E_q\\left[ \\frac{1}{2\\sigma^2_t} \\left|\\left| \\frac{1}{\\sqrt{\\alpha_t}}\\left( \\frac{\\beta_t + \\alpha_t(1 - \\bar\\alpha_{t-1})}{1 - \\bar\\alpha_t}x_t - \\frac{\\beta_t}{\\sqrt{1 - \\bar\\alpha_t}}\\epsilon \\right) - \\mu_\\theta(x_t, t) \\right|\\right|^2 \\right] \\\\=\\mathbb E_q\\left[ \\frac{1}{2\\sigma^2_t} \\left|\\left| \\frac{1}{\\sqrt{\\alpha_t}}\\left( x_t - \\frac{\\beta_t}{\\sqrt{1 - \\bar\\alpha_t}}\\epsilon \\right) - \\mu_\\theta(x_t, t)\\right|\\right|^2 \\right] \\\\\\mathrm{where} \\ \\ \\mathrm x_t = \\sqrt{\\bar\\alpha_t}\\mathrm x_0 + \\sqrt{1 - \\bar\\alpha_t}\\epsilon$ 위 정리에서 $\\mu_\\theta$는 $\\epsilon_\\theta$를 통해 reparametrizing 할 수 있다.\n$$\\mu_\\theta(\\mathrm x_t, t) = \\frac{1}{\\sqrt\\alpha_t}\\left( \\mathrm x_t - \\frac{\\beta_t}{\\sqrt{1 - \\bar\\alpha_t}}\\epsilon_\\theta(\\mathrm x_t, t) \\right) \\\\\\mathbb E_{\\mathrm x_0, \\epsilon}\\left[ \\frac{\\beta^2_t}{2\\sigma^2_t\\alpha_t(1 - \\bar\\alpha_t)}||\\epsilon - \\epsilon_\\theta(\\sqrt{\\bar\\alpha_t}\\mathrm x_0 + \\sqrt{1 - \\bar\\alpha_t}\\epsilon, t)||^2 \\right]$$\n최종 objective는 scale term을 생략한 weighted variational bound로 나타낸다.\n$$L_\\mathrm{simple}(\\theta) := \\mathbb E_{t, \\mathrm x_0, \\epsilon}\\left[ || \\epsilon - \\epsilon_\\theta(\\sqrt{\\bar\\alpha_t}\\mathrm x_0 + \\sqrt{1 - \\bar\\alpha_t}\\epsilon, t)||^2\\right]$$\n원문에서는 실제로 이렇게 formulation 된 objective가 성능이 더 좋았음을 실험으로 보였다.\nTable 2: Unconditional CIFAR10 reverse process parameterization and training objective ablation. (Ho et al., 2020)\n정리하면 $L_\\mathrm{simple}$은 두 process 사이의 Kl-divergence를 재구성한 것이고, 이는 single NN을 통해 현재 input에 존재하는 noise를 noise-level에 따라 직접 예측하여 denoising하는 방식으로 다음 state로의 transition을 진행한다.\nAlgorithms from Ho et al., 2020.\n따라서 state의 수가 늘어나면 더 정교하고, 더 많은 noise를 제거하여 sample quality를 높일 수 있지만 sampling 시간이 길어지고, state 수가 줄어들면 sample에 noise가 낄 수 있지만 이른 시간 안에 결과를 얻을 수 있다.\nWaveGrad: Estimating Gradients for WaveForm Generation, Nanxin Chen et al., 2020.\nWaveGrad는 위 formulation을 통해서 mel-spectrogram에 condition 한 raw signal을 생성하는 방법론을 제시한다.\nFigure 3, 4: WaveGrad network architecture, upsampling block.\nDownsampling block(DBlock)에서 noised signal의 feature를 추출하고, Upsampling block(UBlock)에 feature과 mel-spectrogram을 입력으로 주어 noise를 예측한다.\n원문에서는 24kHz의 raw audio에서 80Hz의 mel을 연산하여, mel-frame 하나당 300개의 audio frame으로 확장하는데, 이는 5개의 UBlock에서 각각 [5, 5, 3, 2, 2] factor에 맞게 upsampling하는 방식으로 구성하고, DBlock에서는 반대로 noised signal을 [2, 2, 3, 5]로 downsampling하여 각각의 intermediate representation의 resolution을 matching 할 수 있도록 두었다.\nFigure 5, 6: Block diagrams of the downsampling, feature-wise linear modulation (FiLM) blocks.\n각각의 convolution은 receptive field를 넓히기 위해서 dilation factor를 가지고, UBlock의 4개 conv는 [1, 2, 1, 2]와 [1, 2, 4, 8], DBlock의 3개 conv는 [1, 2, 4]로 구성된다.\nupsample과 downsample 과정에 정보전달을 위해 wavegrad에서는 Feature-wise linear modulation (FiLM)모델을 통해 noise-level과 positional encoding, DBlock의 feature를 affine parameter로 바꿔 UBlock에서 feature-wise affine transform을 진행한다.\n이외에 batch normalization의 경우 batch에 여러 개의 noise-level을 가진 sample 들이 존재하기 때문에 batch statistics가 정확하지 않아 sample quality에 악영향을 미쳤다고 한다.\nNoise Scheduling\nobjective를 구성하기 위해서는 noise level $\\sqrt{\\bar\\alpha_t}$에 대한 설정이 필요하다. learnable한 parameter로 둘 것이 아니므로 noise distribution에 직접 영향을 줄 수 있어 sample quality와 긴밀한 연관성을 가진다. WaveGrad에서는 noise level에 대한 설정이 음질과 직접적인 연관이 있었음을 실험으로 보였다.\nFigure 7: A plot of different noise schedules\n원문에서는 iteration의 수에 따라 noise level scheduling method를 따로 두었는데, 1000회의 경우 $\\beta_t$를 1e-4에서 0.005를 linear 하게 1000개, 50의 경우 1e-4에서 0.05를 linear 하게 50개 sample 하였다. 25회의 경우에는 $\\beta_0 = 1\\times 10^{-6}, \\ \\beta_1 = 2\\times 10^{-6}$을 시작으로 하는 fibonacci sequence를 구축하였고, 6회의 경우에는 manual 하게 [1e-6, 1e-5, .., 1e-1]로 exponential scale에서 linear 하게 구현하였다.\n이후 이를 통해 partition $l_0 = 1, \\ l_s = \\sqrt{\\prod^s_{i=1}(1 - \\beta_s)}$을 설정하고, $(l_{s-1}, l_s)$에서 uniform 하게 $\\sqrt{\\bar\\alpha}$를 sampling 하여 사용한다. 이렇게 되면 discrete index가 아닌 continuous segment에서 noise level을 sampling 할 수 있고, 6iter과 같이 sparse 한 scheduling 수준에서 괜찮은 성능을 보였다고 한다.\nExperiments, Discussion\nTable 1: Mean opinion scores (MOS) of various models and their confidence intervals.\n원문에서는 이 외에도 iteration 수를 줄이기 위해 여러 가지 noise schedule을 시도했으며, 잘 작동하는 schedule은 $D_\\mathrm{KL}(q(y_N|y_0)||\\mathcal N(0, I))$을 작게 두어 train-inference의 격차가 거의 없게 두었고, $\\beta$를 작은 값으로 시작하여 fine granuality details에 따라 background noise를 줄여야 했다고 한다.\nDiffWave: A Versatile Diffusion Model for Audio Synthesis, Zhifeng Kong et al., 2020\n(2020.09.24. update)\nDiffWave는 WaveGrad와 같은 시기에 나온 또 다른 Diffusion denoising 기반의 mel-inversion vocoder이다.\nFigure 2: The network architecture of DiffWave\nDiffWave는 기본적으로 WaveNet 아키텍쳐를 차용한다. kernel-size=3과 dilation-factor=2의 기본적인 noncausal dilated convolution을 기반으로 [1, 2, \u0026hellip;, 512]의 10개 레이어를 3개 cycle로 구성한다.\nNoise schedule에 대한 embedding을 $\\sqrt{\\bar\\alpha}$에 직접 condition 하던 WaveGrad와 달리 DiffWave에서는 timestep을 기반으로 한 modified positional encoding에 FC-swish layer를 덧붙여 활용한다.\n$$t_\\mathrm{embedding} = \\left[ \\sin(10^{\\frac{0\\times 4}{63}}t), \\cdot\\cdot\\cdot, \\sin(10^{\\frac{63\\times 4}{63}}t), \\cos(10^{\\frac{0\\times 4}{63}}t), \\cdot\\cdot\\cdot, \\cos(10^{\\frac{63\\times 4}{63}}t) \\right]$$\nmel-spectrogram은 channel이 1개인 2D tensor로 가정하여 2D transposed convolution에 의해 22kHz의 signal resolution으로 upsample 되고, WaveNet block에서 dilated convolution 이후에 bias term으로 더해진다.\nnoise scheduling의 경우 [20, 40, 50] iteration에서 $\\beta_t$를 [1e-4, 0.02]를 linear sampling, 200 iteration의 경우 [1e-4, 0.05]를 linear sampling 하였다고 한다.\nDiffWave는 특이하게도 Vocoder purpose 외에 unconditional generation을 시도하였다. 이 경우 보통의 wavenet이라면 single model이 음성의 길이를 모두 커버할 수 있는 receptive field를 구축해야 하지만, DiffWave의 경우 denoising 과정에 발생하는 iteration으로 이에 비례하는 추가 receptive field를 쉽게 얻을 수 있었다.\nExperiments, Discussion\nTable 1: The model hyperparameters, model foot print, and 5-scale MOS with 95% confidence intervals\nVocoder task의 경우 DiffWave는 다른 Flow-based SOTA 모델보다는 조금 느리지만, sample quality는 더 좋았다고 한다. 이는 Flow-based Model이 가지는 architectural constraint에 의한 것으로 추측하였고, inference 속도는 추가 engineering에 의해 일정 부분 빨라질 수 있을 것으로 보인다.\nTable 2: The automatic evaluation metrics and 5-scale MOS with 95% confidence intervals.\nUnconditional generation task의 경우에는 Speech Commands Dataset 에서 spoken digits (0~9) 부분만을 발췌하여 사용했다고 한다. 길이는 16kHz의 1초 미만으로 활용하여 여러 가지 evaluation metric을 측정하였다.\nImplementation\nofficial, Jonathan Ho, tf: diffusion official sample: wavegrad.github.io unofficial, Ivan Vovk, pytorch: WaveGrad official sample: diffwave-demo.github.io unofficial, revsic, tensorflow2: tf-diffwave Reference\nWaveNet: A Generative Model for Raw Audio, Oord et al., 2016. Char2Wav: End-to-End Speech Synthesis, Sotelo et al., 2017. Tacotron: Towards End-to-End Speech Synthesis, Wang et al., 2017. WaveRNN: Efficient Neural Audio Synthesis, Kalchbrenner et al., 2018. ExcitNet Vocoder: A Neural Excitation Model for Parametric Speech Synthesis, Song et al., 2019a. LPCNet: Improving Neural Speech Synthesis through Linear Prediction, Valin \u0026amp; Skoglund, 2019. Parallel WaveNet: Fast High-Fidelity Speech Synthesis, Oord et al., 2018. WaveGlow: A Flow-based Generative Network for Speech Synthesis, Prenger et al., 2019. FloWaveNet: A generative flow for raw audio, Kim et al., 2019. WaveGAN: Adversarial Audio Synthesis, Donahue et al., 2018. MelGAN: Generative Adversarial Networks for Conditional Waveform Synthesis, Kumar et al., 2019. Parallel WaveGAN: A Fast Waveform Generation Model based on Generative Adversarial Networks, Yamamoto et al., 2020. HooliGAN: Robust, High Quality Neural Vocoding, McCarthy \u0026amp; Ahmed, 2020. Denoising Diffusion Proabilistic Models, Ho et al., 2020. ","permalink":"https://revsic.github.io/blog/diffusion/","tags":["Machine Learning","Deep Learning","Generative","Vocoder","Mel Inversion","Denoising Diffusion"],"title":"Diffusion, WaveGrad and DiffWave"},{"categories":["Generative"],"contents":" David Bau et al., 2020, arXiv Keyword: Generative, Adversarial learning Problem: How to manipulate specific rules encoded by a deep generative model. Solution: Projected gradient descent for adding rules to convolution of associative memory. Benefits: Enable users to synthesize edited new images by manipulating model only once. Contribution: Providing a new perspective of associative memory, rule manipulating method of projected gradient descent. Weakness or Future work: - Generative model\n생성 모델은 데이터의 분포를 학습하면서 여러 가지 규칙이나 관계를 만들어 나간다. 간단한 예로 ProgressiveGAN[1]이 만든 주방 이미지에서는 창문에서 오는 빛을 테이블에 반사시키는 경향이 있다.\nFig. 6: Inverting a single semantic rule within a model\n저자는 만약 이러한 규칙들을 직접 분석하여 수정할 수 있다면, 생성 모델 자체를 manipulating 하는 것이고, 이는 생성된 이미지를 각각 수정하는 것보다 효율적으로 수정된 이미지를 생성할 수 있다고 이야기 한다.\n이를 위해서 우리는 생성 모델이 어떤 정보를 캡처하고 있고, 어떻게 unseen scenario에 대해 일반화 하고 있는지 알아야 한다.\n현재 생성 모델들은 인간이 직접 라벨링 한 대규모의 데이터셋에 기반을 두고 있는데, 만약 manipulating 과정에서도 이러한 다량의 데이터와 학습이 추가로 필요하다면, 이는 손으로 생성된 이미지를 직접 수정하는 것과 큰 차이가 없을 것이다.\n이에 우리는 단 몇 개의 샘플 데이터와 간단한 optimization을 통해 모델을 manipulation 할 수 있어야 하고, 이 모델은 우리가 원하는 rule을 캡처하여 unseen data에 대한 일반화를 할 수 있어야 한다.\n저자는 이를 위해 sequential 하게 구성된 nonlinear convolutional generator를 associative memory라는 관점으로 해석하고, 전체 레이어가 아닌 단 하나의 레이어에 constrained optimization을 진행하여 기존의 semantic rule을 보존하면서, 우리가 원하는 rule을 추가할 수 있는 방법론을 제시한다.\nPreview\npretrain된 generator $G(\\cdot; \\theta_0)$가 주어질 때, 모델은 각각의 latent $z_i$에 대해 $x_i = G(z_i; \\theta_0)$의 output을 만들어 낸다. 만약 우리가 copy\u0026amp;paste 방식으로 변화를 준 output $x_{*i}$을 통해 새로운 rule을 표현한다면, rule의 표현 중 가장 직관적인 방법일 것이다.\nFig. 3: The Copy-Paste-Context interface for rewriting a model.\n이때 하고자 하는 것은 새로운 rule을 따르는 $\\theta_1$을 만드는 것이고, 이는 $x_{*i} \\approx G(z_i; \\theta_1)$을 만족할 것이다.\n$\\theta_1 = \\arg\\min_\\theta \\mathcal L_{\\mathrm{smooth}}(\\theta) + \\lambda \\mathcal L_\\mathrm{constraint}(\\theta)$\n$\\mathcal L_\\mathrm{smooth}(\\theta) \\overset{\\Delta}{=} \\mathbb E_z[\\mathcal l(G(z; \\theta_0), G(z; \\theta))]$\n$\\mathcal L_\\mathrm{constraint}(\\theta) \\overset{\\Delta}{=} \\sum_i \\mathcal l(x_{*i}, G(z_i; \\theta))$\n고전적인 해결책은 generator의 전체 parameter set $\\theta_0$를 두 가지 constraint에 맞게 gradient 기반의 optimization을 진행하는 것이다. 이때 $\\mathcal l(\\cdot)$은 perceptual distance를 의미한다.\n하지만 이 경우 몇 개 되지 않는 sample에 overfit될 가능성이 농후하며 다른 데이터에 대해 일반화되지 않을 수 있다.\n이에 저자는 두 가지 방법론을 제안한다. 하나는 전체 parameter set이 아닌 특정 한 layer의 weight만을 update하는 것이고, 하나는 optimization을 특정 constraint 내에서 진행하는 것이다.\n특정 layer L과 L-1 layer까지의 feature map k를 가정할 때 L의 output은 $v = f(k; W_0)$가 된다. 원본 이미지의 latent $z_{i}$가 feature $k_{*i}$를 만들 때 $v_i = f(k_{*i}; W_0)$를 가정하고, 직접 수정한 output에 대응하는 feature map $v_{*i}$를 구할 수 있으면 objective는 다음과 같다.\n$W_1 = \\arg\\min_W \\mathcal L_{\\mathrm{smooth}}(W) + \\lambda \\mathcal L_\\mathrm{constraint}(W)$\n$\\mathcal L_\\mathrm{smooth}(W) \\overset{\\Delta}{=} \\mathbb E_z[|| f(k; W_0) - f(k; W)||^2]$\n$\\mathcal L_\\mathrm{constraint}(W) \\overset{\\Delta}{=} \\sum_i ||v_{*i} - f(k_{*i}; W)||^2$\nperceptual distance는 higher semantic을 표현하는 feature map 사이의 l2-distance를 상정한다. 이때 W만으로도 parameter의 양이 충분히 많을 수 있기에, overfit을 제한하면서 더 나은 일반화를 위해 학습 방향을 고정할 필요가 있었고, 특정 direction으로만 optimization 되도록 constraint를 추가한 gradient descent를 사용하였다.\nAssociative Memory\n저자는 preview의 방법론을 associative memory로부터 유도해 낸다.\n어떤 key $k_i \\in \\mathbb R^N$와 value $v_i \\in \\mathbb R^M$의 mapping $\\{ k_i \\to v_i \\}_{i \\in I}$을 가정하자. 이때 $k_i$가 mutually orthonormal 하면 i와 j가 다를 때 $k_i^T k_j = 0$를 만족한다. matrix W를 $W = \\sum_i v_i k_i^T \\in \\mathbb R^{M \\times N}$ 로 정의하면 orthogonality에 의해 $Wk_i = v_i$가 성립한다. 이를 key-value association을 기록한 memory라 하여 associative memory라고 부르며, linear operation으로 구성되므로 linear associative memory라 할 수 있다.\n저자의 이야기는 Convolution 또한 associative memory의 일종으로 볼 수 있다는 것이다. 흔히 생각하는 convolution은 window에 대해 pixel-wise weighted sum을 한 결과를 나열하는 operation이다. 이는 output의 한 pixel을 관점으로 convolution을 해석한 것이다.\n반대로 input feature에 대해 해석하면 single feature $k \\in \\mathbb R^{B\\times N}$에 weight matrix $W \\in \\mathbb R^{N \\times (MHW)}$를 곱하고, BxMxHxW의 2D tensor로 reshape 하여 location-aware summation 한 것으로도 볼 수 있다.\n이렇게 되면 convolution은 kernel을 matrix로 보고 key가 orthogonal 할 때 linear associative memory로 해석될 수 있다.\nNonorthogonal Keys\nkey는 $\\mathbb R^N$의 vector이므로 최대 N개까지 orthogonal 할 수 있고, 더 많은 key-value pair를 기록하기 위해서는 $v_i \\approx Wk_i$를 approximately equal한 조건을 취하여 error를 minimizing 하는 방식으로 구성한다.\n$W_0 \\overset{\\Delta}{=} \\arg \\min_W \\sum_i ||v_i - Wk_i||^2$\n이때 $K \\overset\\Delta= [k_1|\u0026hellip;|k_S] \\in \\mathbb R^{N\\times S}$ 와 $V \\overset\\Delta= [v_1|\u0026hellip;|v_S] \\in \\mathbb R^{M\\times S}$ 로 가정하면 multiple nonorthogonal key, value pair에 대한 associative memory를 구성할 수 있다.\n$W_0 = \\arg\\min_W \\sum_i||V - WK||^2$\n그리고 이는 least square solution $W_0KK^T = VK^T$와 pseudo-inverse $K^+$에 대해 $W_0 = VK^+$로 표현된다.\nWhat we want\n즉 pretrain을 통해 구한 $W_0$는 trainset에서 연산한 L-1까지의 feature map과 그에 대한 response를 key-value로 가정한 associative memory가 된다.\n여기서 우리가 하고 싶은 것은 다음과 같다.\nuser가 copy한 value와 paste한 지점의 key를 가져와 새로운 pair로 memory에 추가\n이렇게 되면 L-1까지의 feature map에서 key가 관측되었을 때 memory에서 새로운 value가 mapping 되어 해당 부분에 copy한 context가 이미지에 발현된다. Model manipulation을 하는 주요한 근거가 되는 것이다.\n이를 표현하면 $W_1 = \\arg\\min_W ||V - WK||^2$와 $v_* = W_1k_*$를 만족 시키는 constrained least-square (CLS) problem으로 구성되고, 이의 해는 다음과 같이 정리된다.\n$W_1KK^T = VK^T + \\Lambda k_*^T$\n$W_1KK^T = W_0KK^T + \\Lambda k_*^T$\n$W_1 = W_0 + \\Lambda(C^{-1}k_*)^T$\n이 때 $C \\overset\\Delta= KK^T$로 구성하면 key가 zero-mean일 때 covariance로 해석될 수 있다. 결국 $\\Lambda \\in \\mathbb R^M$를 구하는 문제로 귀결된다. 여기서 $d \\overset\\Delta= C^{-1}k_*$로 가정하면 $W_1 = W_0 + \\Lambda d^T$로 볼 수 있고, 풀이는 다음과 같다.\n$\\left[ \\begin{array}{c|c} W_1 \u0026amp; \\Lambda \\end{array} \\right] \\left[ \\begin{array}{c|c} I \u0026amp; k_* \\\\ \\hline -d^T \u0026amp; 0 \\end{array} \\right] = \\left[ \\begin{array}{c|c} W_0 \u0026amp; v_* \\end{array}\\right]$\n$\\left[ \\begin{array}{c|c} W_1 \u0026amp; \\Lambda \\end{array} \\right] = \\left[ \\begin{array}{c|c} W_0 \u0026amp; v_* \\end{array} \\right] \\left[ \\begin{array}{c|c} I \u0026amp; k_* \\\\ \\hline -d^T \u0026amp; 0 \\end{array} \\right]^{-1}$\n여기서 주목할 점은 2가지이다.\nuser requested mapping $k_* \\to v_*$의 soft error-minimization objective가 d라는 straight-line을 따라 update해야 하는 hard constraint로 바뀜 direction d가 key에 의해서만 결정되고 value는 오직 user requested $v_*$가 $\\Lambda$에 영향을 주는 방식 정도로만 작용함 결국 구현체에서는 covariance C 정도를 미리 연산하여 caching 해두고, request가 올 때 direction과 $\\Lambda$를 계산하는 방식으로 작동할 것이다.\npreview의 수식을 다시 들고오면, $W_1 = \\arg\\min_W ||V-WK||^2$는 smoothness를 위한 loss, $v_* = W_1k_*$는 constraint를 위한 loss로 볼 수 있다. 그리고 이 둘의 solution이 d라는 direction으로 update된 $W_1$로 나온 것이다.\nGeneralization\n위까지의 정리는 copy\u0026amp;paste로 수정된 이미지에 대한 해당 layer와 그 전 layer의 response를 얻어와 key-value mapping을 구성할 수 있어야 한다. 하지만 SOTA를 이루고 있는 generative model들은 주로 gaussian noise에서 image로의 mapping을 확률적으로 학습하고 있기에, 수정된 이미지의 latent를 z-optimization을 통해 얻을 수 있어야 하고, 이 또한 rule이 크게 바뀐 경우에는 정확하지 않을 수 있다.\n원문에서는 이 부분을 위해 feature independency를 보였는데, 일례로 stylegan과 progressive gan은 특정 레이어의 response를 patch로 나눠 주변 정보 없이 각각을 inference 했을 때도 원본과 유사한 object가 복원되었다는 것이다. 이는 feature map을 low resolution의 image로 보고 각 key가 해당 위치에 존재하는 object를 encoding 하고 있기에 가능하다는 가설을 세울 수 있다.\nFig. 17: Comparison of rendered cropped activations at various layers of Progres- sive GAN generated LSUN church images.\n이렇게 되면 z-known image에서 복사하고자 하는 patch의 위치를 특정할 수 있을 때, low-resolution의 feature map에서 동일한 위치의 value를 가져와 대상에 위치만 맞춰 붙여넣으면 되고, feature map 수준에서 보다 perceptual 한 distance를 측정할 수 있게 된다.\n만약 z와 convolutional response를 얻을 수 없어 image-level에서 distance를 측정해야 하거나, activation을 거친 response를 가정할 때에는 neural net의 nonlinearity에 의해 선형성 가정이 깨지게 된다. 이에 neural generator를 다루는 입장이라면 위 방법론이 nonlinear 환경에서 일반화될 수 있어야 한다.\n원문에서는 nonlinear mapping $f(k; W)$가 있을 떄 update policy가 W의 row-space에 sensitive하고, column-space에 insensitive 하므로 동일한 rank-1 update를 $f(k_; W) \\approx v_$의 optimization constraint로 쓸 수 있다고 한다.\nlinear phase에서는 $\\Lambda$를 linear system을 통해 풀었다면, nonlinear phase에서는 gradient 기반의 optimization이 필요하다. 이때 $\\Lambda$는 requested value와 direction에 의존하는 변수이기 때문에 이를 objective로 하는 optimization을 진행한다.\n$\\Lambda_1 = \\arg\\min_{\\Lambda \\in \\mathbb R^M}||v_* - f(k_*; W_0 + \\Lambda d^T)||$\n만약 requested key-value pair가 하나가 아닌 여럿이라면, rank-1 대신 low-rank optimization이 될 것이고, S개 pair에 대해 다음과 같이 표현할 수 있다.\n$d_i = C^{-1}K_{*i}$\n$D_S \\overset\\Delta= [d_1|\u0026hellip;|d_S]$\n$\\Lambda_S = \\arg\\min_{\\Lambda \\in \\mathrm R^{M \\times S}} || V_* - f(K_*; W_0 + \\Lambda D_S^T)||$\n그리고 update는 $W_S = W_0 + \\Lambda_S D_S^T$로 이뤄질 것이다.\n마지막으로 이 조건을 좀 더 relax하면 $\\arg\\min_W ||V_* - f(K_*; W)||$를 optimizing하고, 대신 매 step 마다 W를 $W_0 + \\Lambda_S D_S^T$의 subspace로 projection 하는 projected gradient descent를 취한다.\nDetail\noriginal repository rewriting에서는 L-1까지의 feature map을 BHWxC로 reshape하여 collect_2nd_moment에서 z-dataset을 기반으로 CxC의 covariance를 미리 구해 놓는다.\n이후 edit 요청이 들어오면 covariance_adjusted_query_key에서 direction을 구하는데, C의 pseudoinverse를 구하는 대신 $CD_S = K_S$의 least square solution (torch.lstsq)을 풀어 computational stability를 얻었다고 한다.\n이때 전체 이미지에서 desired key만을 가져오기 위해 multi_key_from_selection에서는 target layer의 resolution에 맞게 image-level의 mask를 bilinear interpolation한 후, key matrix에 직접 곱하여 non-zero key만을 선별한다. feature independency에 따라 가능하다.\n이후 $D_{S}$를 직접 이용하는 것이 아닌 low-rank subspace의 basis를 구해 활용하며, 원문에서는 SVD를 통해 eigen-value가 큰 eigen-vector를 선출하여 동일한 subspace를 구성하는 orthogonal basis로 활용했다.\n이후 insert에서 parameter optimization을 진행한다.\nweight은 subspace에 orthogonal 하게 변환하여 ortho_weight 변수에 저장해 둔다. 이는 projected_conv을 활용하는데, 흔히 gram-schmidt orthogonalization에서 하는 것과 같이 basis에 정사형한 벡터를 원본에서 빼는 방식으로 진행한다.\n$W_\\mathrm{ortho} = W - (WU_{1:R})U_{1:R}^T \\ \\mathrm{where} \\ C^{-1}K_S = U\\Sigma V^T, \\ \\mathrm{lowrank} \\ R$\n이후 feature-level distance를 L1으로 하는 optimization을 진행하고, 특정 스텝마다 weight을 subspace로 projection하여 ortho_weight에 더하는 방식으로 projected gradient descent를 구현한다.\n이렇게 되면 optimization의 여파는 subspace 내에서만 구성되고, subspace에 orthogonal한 weight을 더함으로써 기존의 weight은 유지하고 subspace 내에서의 update만을 취할 수 있게 된다.\nZCA를 활용한 rank reduction은 원문의 Appendix. D.를 참고한다.\nLayer selection\n원문에서는 convolution layer를 neighbor와의 정보 취합으로 edge, texture, shape 등을 구별해 내는 관점보다는, 하나의 feature vector가 local patch가 되면서 주변과 disentangle 되는 관점을 취하였고, 이것이 memory model로 해석되었다.\n원문에서는 실제로 ProgressiveGAN[1]과 StyleGANv2[2]의 일부 레이어에서 이런 feature 간 독립성을 띠고 있음을 보였다.\nfeature map을 MxN의 patch로 잘라 주변 정보 없이 적절한 크기의 output을 만들었을 때, 네트워크는 여전히 동일한 객체와 컨텍스트를 만들어 낼 수 있음을 보인다면, feature 간에 독립적인 정보를 담고 있음을 추론할 수 있다.\n레이어마다 patch를 잘라 output을 만들었을 때 Frechet Inception Distance (FID)가 작다면 해당 patch는 주변 정보로부터 less dependence 한 것이고, FID가 높다면 dependent 한 것임을 나타낼 것이다.\nFig. 13: FID of rendered cropped activations with respect to random crops of StyleGANv2 generated images\n그래프에서 6~11번째 layer가 FID가 가장 낮았고, 이 layer에서 key 값은 주변과 independent 한 정보를 가지고 있을 확률이 높다. 즉, 어느 한 layer의 key를 수정해야 한다면, 해당 layer를 수정하는 것이 object를 render 하는데 좋은 quality의 이미지를 만들 수 있음을 나타낸다.\nFig. 14: Comparison of rendered cropped activations at various layers of Style- GANv2 generated LSUN church images.\nExperiment\n이제 User는 copy\u0026amp;paste를 통해 image에 원하는 부분을 수정하고 (key-value), 몇몇 context image에 수정되었으면 하는 부분(key-context)을 표기하여 rewriter에게 전달한다.\nrewriter은 해당 key-context로부터 direction을 계산하고, pasted image와 original image 사이의 L1-loss를 기반으로 projected-optimization을 진행한다. 이에 따라 일반화된 model을 얻을 수 있고, editing을 마치게 된다.\nFig. 7: Giving horses a hat to wear.\nDiscussion\n저자는 GPT-3, WaveNet과 같이 image 이외의 분야에서도 vastly trained model에 rule을 수정하고자 하는 일이 있을 것이고, model rewriting은 이 경우에 새로운 contents, behavior, interaction을 부여할 충분한 방법론일 것이라 이야기한다.\nImplementation\npytorch, official: David Bau, rewriting pytorch, unofficial: revsic, Rewriting-A-Deep-Generative-Models References\nProgressive Growing of GANs for Improved Quality, Stability, and Variation, Tero Karras et al., 2017, arXiv:1710.10196. Analyzing and Improving the Image Quality of StyleGAN, Tero Karras et al., 2019. arXiv:1912.04958. ","permalink":"https://revsic.github.io/blog/rewriting/","tags":["Machine Learning","Deep Learning","Generative","Adversarial Learning","Model editing","Rewriting"],"title":"Rewriting a Deep Generative Model"},{"categories":["Generative"],"contents":" Stanislav Pidhorskyi et al., 2020, arXiv Keyword: Generative, Adversarial learning Problem: AE based approach has poor quality of output distribution. Solution: Adversarial setting and encoder, decoder decomposition. Benefits: Less entangled latent, sharp output distribution. Contribution: Learnable and less entangled latent with adversarial autoencoding structure. Weakness or Future work: - GAN and AE\nGenerative Adversarial Networks (GAN)은 complex distribution을 표현하는 데 좋은 성능을 보여왔다. 특히 sharp 한 generation에 특이점을 가져 많은 현실적인 이미지나 음성을 생성할 수 있었다.\nAutoencoder는 encoder, generator pair로 representation과 generation 모두를 포함하는 구조이다. 본문에서는 AE가 representation은 충분히 잘하고 있지만, generation까지 겸비한 모델은 아직 구현하지 못하였다고 이야기한다.\n이에 소개하고자 하는 것이 Adversarial Latent Autoencoder (ALAE)이고, GAN과 비슷한 generative power를 가지면서도 representation disentangle이 가능한 모델을 목표로 한다.\n대부분의 AE 연구들은 같은 가정을 하는데, latent space를 확률 분포로 모델링 하며, 이것을 고정된 prior에 맞춰야 한다는 것이다. 실제로 ELBO를 정의할 때 posterior q를 가정하고 variational inference를 진행하는데, KL-divergence가 대상으로 삼은 conditional prior가 intractable 하기 때문에 주로 고정된 prior를 사용하게 된다. 하지만 StyleGAN (Karras et al., 2018)에서는 분포상 제약을 받지 않고, 데이터로부터 학습된 latent space가 prior에서 많은 transform을 거칠수록, prior에서 거리가 멀어질수록, disentangle 하기 쉽다는 이야기를 한다.\n여기서 착안하여 저자는 AE가 latent distribution을 data에서 학습할 수 있게 하였고, output distribution은 adversarial strategy를 통해 학습하였다. 이를 통해 GAN만큼의 generative power를 가지면서도 disentanglement를 더 용이하게 하는 것이다. 이는 근래 GAN 관련 분야에서 연구된 여러 기법이나 휴리스틱을 덜 사용하면서도 효과적으로 데이터를 모델링할 수 있게 한다.\nPreliminaries: GAN Objectives\n본문에서 소개하는 GAN objective의 general formulation은 다음과 같다.\n$$V(\\mathtt G, \\mathtt D) = \\mathbb E_{p_D(x)}\\left[ f(\\mathtt D(x)) \\right] + \\mathbb E_{p(z)}\\left[ f(-\\mathtt D(\\mathtt G(z))) \\right]$$\n여기서 f를 softplus $f(t) = -\\log(1 + \\exp(-t))$로 두면 vanilla GAN과 같아지고, f를 identity $f(t) = t$로 두면 wasserstein GAN과 같아진다.\nAdversarial Latent Autoencoders\n기존의 GAN이 generator와 discriminator를 single module로 구성하였다면, ALAE에서는 가장 먼저 G와 D를 $\\mathtt G = G \\circ F$와 $\\mathtt D = D \\circ E$로 분해한다. 그리고 F와 G 사이, E와 D 사이의 represenation을 latent W로 둘 것이다. 이 때 F와 D는 deterministic, G와 E는 stochastic하게 가정한다. G가 additional independent noise $\\eta$를 받는다면 $G(w, \\eta)$의 general stochastic generator가 될 것이다. 이때 G에서 생성된 output x의 확률은 다음과 같다.\n$$q(x) = \\int_w\\int_\\eta q_G(x|w, \\eta) q_F(w) p_\\eta(\\eta) \\mathrm d\\eta \\mathrm dw$$\n마찬가지로 E에서 생성된 latent w의 확률은 다음과 같다.\n$$q_E(w) = \\int_x q_E(w|x)q(x)\\mathrm dx$$\n여기서 q(x)를 실제 데이터 분포 $p_D(x)$로 바꾼다면 데이터에 대한 latent $q_{E, D}(w)$가 될 것이다.\n여기서 앞서 소개한 GAN objective를 토대로 모델을 학습한다면 이는 synthetic distribution q(x)를 실제 데이터 분포 $p_D(x)$로 맞춰가는 작업이 된다. 여기에 더불어 ALAE에서는 하나의 조건을 더 걸게 되며, 이는 $q_F(w) = q_E(w)$로 latent distribution을 matching 하는 작업이다.\nAE는 latent와의 bijection을 위해 reciprocity, 자기복원의 기능을 가지는데, 크게 $x=G(E(x))$로 data space 상에서의 복원이 있을 수 있고, $w=E(G(w))$로 latent space 상에서의 복원이 있을 수 있다. 전자의 경우는 두 분포의 차이를 나타내는 reconstruction error를 가지게 되고, 각 픽셀을 독립된 확률 분포로 가정했을 때 prior에 따라 log-prob으로 l1이나 l2 loss를 띌 수 있다. 대부분의 AE 기반 모델에서 사용하지만 실제로는 blur나 noise 같은 output distribution에 표현되는 perceptual 한 손실을 만들기 때문에 지금까지의 AE 모델들이 쉽게 GAN에 비견되는 품질을 가질 수 없었다.\n반면 ALAE는 후자를 선택하였는데, latent space 상에서 차이를 나타내는 discrepancy measure를 두고, F와 EGF의 출력을 비교하는 것이다. output 상에서의 l2-loss는 human perception을 반영하기보다는 단순 픽셀 상의 차이에 집중하고, 이런 한두 개의 픽셀 차이는 latent 상에 작용하기 어려워야 한다. 이에 latent 상에 직접 discrepancy measure를 걸어 버리는 것이 human perception에 더 직접적으로 작용할 수 있게 학습하는 것이다.\n이는 GAN의 intuition과 비슷한데, GAN은 기존의 AE가 output space 상에서 independent 한 픽셀을 가정하고 discrepancy를 측정한 것에 반해, discriminator라는 human perception을 대체할만한 추가 모델을 두고, receptive field와 인지 능력을 학습받은 adaptive discrepancy를 측정할 수 있게 한 것이다.\nALAE에서는 이 discrepancy measure를 단순 l2로 두었는데, 이는 latent W에 어떠한 제약도 두고 싶지 않았기 때문이라고 한다. latent W에 distribution을 가정하고 KL-divergence와 같은 척도를 이용할 수도 있지만, 이렇게 되면 실상 F가 identity map과 같아지고 그 의미가 무색해진다. 대신 l2를 사용하였기 때문에 실제 데이터에 대한 latent $q_{E, D}(w)$와의 비교는 어려워졌다.\ninference에서는 E로 input data를 encoding 하여 만든 latent w와 G를 통해 이미지를 재생성하는 방식으로 작동한다.\n(StyleALAE에 대한 이야기는 보류한다.)\nDetail\n$L^{E, D}_ {adv} = \\mathrm{softplus}(D\\circ E \\circ G \\circ F(z)) + \\mathrm{softplus}(-D \\circ E(x)) + \\frac{\\gamma}{2}\\mathbb E_{p_D(x)}\\left[ ||\\nabla D \\circ E(x)||^2\\right]$\n$L^{F, G}_ {adv} = \\mathrm{softplus}(-D\\circ E \\circ G \\circ F(z))$\n$L^{E, G}_ {err} = ||F(z) - E \\circ G \\circ F(z)||^2_2$\nGAN objective의 f는 softplus를 사용하였고, 대신에 real data에 대한 gradient regularization term을 두었다. latent prior z는 standard gaussian으로 두었고, 따로 independent noise $\\eta$를 두지 않은 것으로 보인다.\nDiscussion\n실제로 MLP 기반의 MNIST 모델과 StyleALAE 기반의 여러 image synthesizing experiment를 진행하였고, image quality는 물론 latent 상에서의 preceptual path length가 짧아지는 등의 disentanglement 성능 향상도 보였다고 한다.\n다른 연구들과는 달리 adaptive latent를 가정하여 less entangle한 latent를 학습할 수 있었고, adversarial setting으로 output distribution의 sharpness를 유지할 수 있었다. reciprocity에 대한 ablation study 같은 것이 있었으면 좋을거 같다.\nImplementation\npytorch, official: ALAE tensorflow, unofficial, MNIST PoC: tf-alae Reference\nAdversarial Latent Autoencoders, Stanislav Pidhorskyi et al., 2020. StyleGAN: A Style-Based Generator Architecture for Generative Adversarial Networks, Tera Karras et al., 2018. ","permalink":"https://revsic.github.io/blog/alae/","tags":["Machine Learning","Deep Learning","Generative","Adversarial Learning","Autoencoder","ALAE"],"title":"Adversarial Latent Autoencoders"},{"categories":["Bayesian"],"contents":" Hyunjik kim et al., 2019, arXiv Keyword: Bayesian, Process Problem: Underfitting of Neural Process Solution: NP + Self-Attention, Cross-Attention Benefits: Improvement of prediction accuracy, training speed, model capability. Contribution: Solving underfitting on NP Weakness or Future work: Decoder + Self-Attention Neural Process and Gaussian Process\nNeural Process는 함수 분포를 모델링하기 위한 효과적인 메소드를 소개했다. linear time에 작동하며, 한번 학습되면 임의의 context pair와 query에 대해 target 분포를 예측할 수 있다. 그럼에도 NP와 GP를 직접 비교하기 어려운 이유는 NP는 stochastic process의 여러 realization (process에서 샘플링한 함수 표본) 에 대해서 학습하지만, GP는 하나의 realization에서 sample 된 observation에 대해 학습하기 때문이다.\nNP는 Scalability, Flexibility, Permutation Invariance라는 점에서 여러 장점이 있지만, consistency 문제를 가지고 있다. 이는 context로부터 target을 추론한 후, 다시 context에 덧붙여 target을 추가 추론했을 때와 온전한 context로부터 전체 target을 추론했을 때 분포차가 발생할 수 있음을 의미한다. 그러므로 NP를 그 자체로 consistent 하다고 보기보다는 consistent stochastic process의 근사라고 보는 것이 맞다.\nNP의 또 하나의 약점은 context set에 underfit한다는 것이다. 실제로 1D Curve Fitting 문제를 살펴보면, context point가 존재하는 지점에서도 과한 분산과 부적절한 평균점을 보인다. 본문에서는 이 이유를 NP가 context set을 고정된 크기의 latent로 변환시키는 과정에 permutation invariant function으로 mean-aggregation을 썼는데, 이 과정이 bottleneck으로 작용했기 때문이라고 판단하였다. 이는 모든 컨텍스트에 동일한 가중치를 주었기에, 디코더가 target을 예측할 때 context point로부터 적절한 관련 정보를 제공받지 못하고 있을 것으로 생각한 것이다.\n이러한 점을 해결하기 위해서 GP의 kernel function을 차용하였다. kernel은 입력값의 두 지점에 대해서 유사도를 측정하는 도구로 이용되는데, NP에는 이러한 메커니즘이 존재하지 않는 것이다. 그래서 제안하고자 하는 게 Attentive Neural Process (ANPs)이고, 이는 NP에 differentiable attention을 추가하여 context point에 대한 underfit을 줄인 모델이다.\nAttentive Neural Process\n먼저 입력과 출력 $x_i \\in \\mathbb R^{d_x}, \\ y_i \\in \\mathbb R^{d_y}$, 그리고 observed context $(x_C, y_C) := (x_i, y_i)_ {i \\in C}$ 와 targets $(x_T, y_T) := (x_i, y_i)_{i \\in T}$를 가정한다. context representation aggregator r에 대해 $r_C := r(x_C, y_C) \\in \\mathbb R^d$로 두고, latent encoder s에 대해 $s_C := s(x_C, y_C)$로 두면 NP는 다음을 모델링하는 것과 같다.\n$$p(y_T | x_T, x_C, y_C) := \\int p(y_T | x_T, r_C, z)q(z | s_C)dz$$\n여기서 NP가 가정하는 process F의 randomness는 global latent z에서 오기 때문에 likelihood를 최대화하는 과정은 z의 샘플링을 통해 여러 개로 realization 된 하나의 process를 학습하는 것과 같다.\nz_context = self.z_encoder(context, key=cx, query=cx)\rz_prob = self.latent_prob(z_context)\rlatent = z_prob.sample()\rself_attend = self.encoder(context, key=cx, query=cx) ANP는 여기에 두 가지 attention을 덧붙인다. 첫 번째는 self-attention으로 context 사이에서 정보를 공유하고 더 나은 intermediate representation을 만들기 위한 장치이다.\ncross_attend = self.cross_encoder(self_attend, key=cx, query=query)\rrep = self.decoder(cross_attend, query, latent)\rdist, mu, sigma = self.normal_dist(rep) context에 self-attention을 취하면 context 개수만큼의 intermediate representation(IR)이 생기고, 이는 target과 context의 유사도를 비교하는 cross attention을 통과하여 query-specific representation $r_* := r^*(x_C, y_C, x_ *)$을 만든다. 이는 모델이 실제로 어떤 컨텍스트 포인트를 조명할지 명시하기 때문에 target prediction에 도움을 줄 수 있다.\nlatent encoder의 경우에는 self-attention 이후 cross-attention 대신에 mean-aggregation을 선택했는데, 본문에서는 이를 global-latent로써 보존하고 싶었다고 한다. latent path에 cross-attention이 들어오면, latent에 locality가 발생하기 때문이다.\n$$\\log p(y_T | x_T, x_C, y_C) \\ge \\mathbb E_{q(z | s_T)} \\left[ \\log p(y_T | x_T, r_C, z) \\right] - D_{KL}(q(z | s_T) || q(z | s_C))$$\ntraining loss는 ELBO를 동일이 가져간다.\n이렇게 하면 computational complexity가 O(n(n + m))이 되는데, 이는 attention 과정에서 모든 컨텍스트를 탐방하기 때문이다. 하지만 dot-product attention 같은 matrix-multiplication 기반의 attention 알고리즘을 이용하면 대부분이 parallel 하게 동작할 수 있으므로 실제로는 training time이 NP와 비교할 만 하다고 한다.\nDiscussion\nANP는 attention mechanism을 통해 underfitting problem을 효과적으로 풀어냈다. 추측의 정확도가 높아졌고, 학습이 빨라졌으며, 모델링 할 수 있는 메소드의 범위도 늘었다. 저자는 ANP의 decoder에 self-attention을 붙여 expressiveness의 향상 정도를 확인하고 싶다고 한다. 하지만 이는 target prediction 사이에 상관성이 생기는 문제이니 ordering이나 grouping을 어떻게 해야 할지가 중요해질 것이라고 한다.\nImplementation\nTensorflow v1: tf-neural-process Reference\nConditional Neural Processes, Garnelo et al., 2018. Neural Processes, Garnelo et al., 2018. Attentive Neural Processes, Kim et al., 2019. ","permalink":"https://revsic.github.io/blog/anp/","tags":["Machine Learning","Deep Learning","Bayesian","Stochastic Process","Neural Process","Attentive Neural Process"],"title":"Attentive Neural Processes"},{"categories":["Bayesian"],"contents":" Marta Garnelo et al., 2018, arXiv Keyword: Bayesian, Process Problem: Data inefficiency, hard to train multiple datasets in one. Solution: Stochastic Process + Latent variable + NN Benefits: Concurrent training, global uncertainty, explicit latent variable. Contribution: CNP + global uncertainty, concurrent dataset, explicit latent Weakness or Future work: Pairwise correlation. Function Approximation\n딥러닝에서는 데이터 간의 상관관계를 찾기 위해 함수를 근사하는 작업을 하는데, 주로 지도 학습에서는 parameterized function의 파라미터 셋을 gradient를 통해 업데이트하는 방식을 차용한다. 이러한 경우 대부분의 workload가 학습 중에 이뤄지며, 추론 과정은 단순 forward pass만으로 가능하다. 하지만 한번 학습된 이후로는 추론 결과의 업데이트가 힘들다는 점에서 메타 러닝 쪽도 관심이 많아지는 편이다.\n그 대체재로 Stochastic Process와 그 에인 Gaussian Process(GP)가 있는데, 이러한 모델들은 training phase를 필요로 하지 않고, test-time에 원하는 쿼리를 직접 렌더링 하게 된다. 하지만 렌더링 과정이 O(N^3)의 연산이 필요하기 때문에 대형 데이터셋을 상대로 적용하기 쉽지 않고, kernel과 같은 prior에 의해 함수 모형이 바뀌는 등 여러 문제점도 존재한다.\n이에 제안하고자 하는 게 Neural Process이다. 함수에 대한 분포를 가정하고, observation을 통해 query와 prediction에 대한 uncertainty를 추정한다. GP와 달리 O(n + m)의 단순 forward pass만으로 추정을 진행할 수 있다는 점에서 장점을 지닌다.\nNeural Process\n먼저 random function $F: \\mathcal X \\to \\mathcal Y$와 finite seq $x_{1:n}=(x_1, \u0026hellip;, x_n)$ with $x_i \\in \\mathcal X$, function values $Y_{1:n} := (F(x_1), \u0026hellip;, F(x_n))$를 가정한다. 이 collection의 joint dist $\\rho_{x_{1:n}}$이 존재할 것이고, GP 라면 multivariate gaussian일 것이다.\n이 joint dist는 exchangeability와 consistentcy라는 조건에서 Kolmogorov Extension Theorem에 의해 stochastic process로 정의될 수 있다. 이 때 exchangeability는 permutation invariance를 의미하고, consistentcy는 marginlize한 범위 외의 sequence에 대해 marginalize했을 때 원본 시퀸스와 동일함을 의미한다.\nStochastic process F와 시퀸스 $x_{1:n}$, 그의 joint dist $\\rho_{x_{1:n}}$에 대해 instantiation of stochastic process f는 다음과 같다\n$$\\rho_{x_{1:n}} = \\int p(f)p(y_{1:n}|f, x_{1:n})df$$\nobservation noise를 고려하여 $Y_i \\sim \\mathcal N(f(x_i), \\sigma^2)$라 가정하면 proability p는 다음과 같다\n$$p(y_{1:n}|f, x_{1:n}) = \\prod^{n}_{i=1} \\mathcal N(y_i | f(x_i), \\sigma^2)$$\n이 때 joint dist $\\lbrace\\rho_{x_{1:n}}\\rbrace$의 exchangeability와 consistentcy에 의해 stochastic process F의 존재성이 증명된다. 여기서 NP가 하고 싶은 것은 high-dimensional random vector z로 F를 parameterize하고, fixed function g에 대해 F(x) = g(x, z)를 NN으로 학습하고 싶은 것이다.\n$$p(z, y_{1:n}|x_{1:n}) = p(z)\\prod^{n}_{i=1} \\mathcal N(y_i|g(x_i, z), \\sigma^2)$$\n이 때 random function과 distribution을 학습하기 위해서는 여러 데이터셋을 동시에 학습해야 한다. 여러 input seq $x_{1:n}$와 output seq $y_{1:n}$를 학습시켜 데이터 간의 variability를 학습할 수 있게 한다.\ng를 non-linear NN으로 두기 때문에 학습에는 variational inference를 이용한다. latent z와 prior p(z)는 standard multivariate gaussian으로 두고, variational posterior $q(z|x_{1:n}, y_{1:n})$를 가정한다.\n$$\\log p(y_{1:n}|x_{1:n}) \\ge \\mathbb E_{q(z|x_{1:n}, y_{1:n})}\\left[\\sum^{n}_{i=1}\\log p(y_i|z, x_i) + \\log \\frac{p(z)}{q(z|x _{1:n}, y _{1:n})}\\right]$$\n이 때 test time에 더욱 well-behave model을 만들기 위해 context-set과 target-set을 나누고, true posterior $p(z|x_{1:n}, y_{1:n})$ 대신 variational posterior로 approximate한다.\n$$\\log p(y_{1:n}|x_{1:n}) \\ge \\mathbb E_{q(z|x_{1:n}, y_{1:n})}\\left[\\sum^{n}_{i=m+1}\\log p(y_i|z, x_i) + \\log \\frac{q(z|x _{1:m}, y _{1:m})}{q(z|x _{1:n}, y _{1:n})}\\right]$$\n이렇게 되면 z가 process F를 capture하는 역할을 하고, 이것이 global uncertainty를 capture 했다고도 볼 수 있다.\n실제 구현체에서는 encoder h가 pair $(x, y)_i$에 대해 repr $r_i = h((x, y)_i)$로 구성하고, exchangeable aggregator $r = a(r_i) = \\frac{1}{n} \\sum^n _{i=1}r_i$를 통해 latent $z \\sim \\mathcal N(\\mu(r), I\\sigma(r))$를 표현한다. 마지막으로 decoder g와 sampled latent z에 대해 $y_T = g(z, x_T)$를 통해 output을 결정하게 된다.\nz_context = self.z_encoder(context) z_dist = self.z_prob(z_context) latent = z_dist.sample() rep = self.decoder(context, query, latent) dist = self.normal_dist(rep) log_prob = dist.log_prob(target) log_prob = tf.reduce_sum(log_prob) prior = self.z_prob(self.z_encoder(context)) posterior = self.z_prob(self.z_encoder([query, target])) kl = tfp.distributions.kl_divergence(prior, posterior) kl = tf.reduce_sum(kl) elbo = -log_prob + kl Conditional Neural Process, Marta Garnelo et al., 2018\n동일 저자는 같은 해에 CNP라는 논문을 냈는데, 차이점은 NP는 latent z를 통해 process F를 캡처하고, global uncertainty를 측정하는데, CNP는 그러한 과정 없이 deterministic 하게 context와 query에 대한 target을 내놓는다. NP는 latent를 명시적으로 설정하였기 때문에, concurrent 한 training process에서도 명확히 latent를 포착하는 것을 볼 수 있다.\nDiscussion\nNP는 역시 stochastic process와 NN을 합친 모델이다. 함수에 대한 분포를 정의하고, context conditioned prediction을 생성한다. regression task에 대해서 실험을 주로 했는데, future work로 high dimensional data에 관한 연구를 남겨두겠다 한다.\nImplementation\nTensorflow v1: tf-neural-process Reference\nConditional Neural Processes, Garnelo et al., 2018. Neural Processes, Garnelo et al., 2018. ","permalink":"https://revsic.github.io/blog/np/","tags":["Machine Learning","Deep Learning","Bayesian","Stochastic Process","Neural Process"],"title":"Neural Processes"},{"categories":["Bayesian"],"contents":" Marta Garnelo et al., 2018, arXiv Keyword: Bayesian, Process Problem: Weakness of knowledge sharing and data inefficiency of classical supervised learning Solution: Stochastic Process + NN Benefits: Data efficient, prior sharing Contribution: Encapsulation of parameterized NN function family. Weakness or Future work: Global uncertainty, pairwise correlation. Function Approximation\n우리는 데이터의 경향성을 파악해 추론을 얻어내기 위해 흔히 데이터셋 $\\lbrace(x_i, y_i)\\rbrace^{n-1}_{i=0}$과 함수 $f: X \\to Y$를 가정한다. 일반적인 지도학습에서는 $f$를 parameterized model로 가정하고, computation을 고정, parameter를 학습하는 방식을 취한다. 그 이후에는 deterministic하게 입력에 대해 출력이 결정된다. 이러한 방식은 prior의 적용이 한정적이고, 그에 따라 learning 사이의 정보 공유가 어려워 매번 대량의 데이터셋에 대한 새로운 학습이 요구되는 등 여러 한계를 보이기도 한다.\nStochastic process는 함수라는 카테고리를 하나의 확률 분포로 가정한다. 함수에 대한 사전 지식은 분포상의 가정으로 표현되고, 학습은 관측된 값들에 대한 조건부 확률과 사후 분포로써 표현된다.\n대표적인 예로 gaussian process는 함수의 smoothness prior를 kernel function으로 나타내었고, 이는 값들 사이의 유사도로 나타나게 된다. 하지만 이러한 메소드들은 prior에 따라서 computationally intractable하기도 하고, $O(N^3)$에 달하는 연산량에 현대에는 많이 쓰이지 않고 있다.\n이러한 문제를 풀기 위해 model family를 제안하고, 이것이 Conditional Neural Process 이다.\nStochastic Process\n먼저 observation $O = \\lbrace(x_i, y_i)\\rbrace \\subset X \\times Y$ 과 target $T=\\lbrace x_i\\rbrace^{n+m-1}_{i=n}$ 를 가정하자. 이 때 $f: X \\to Y$로의 함수와 이 함수의 분포 P가 존재한다면 $f \\sim P$ 이고, 조건부 분포 $P(f(T)|O, T)$로 표현된다.\nGP에서는 P를 Gaussian으로 가정하고, Covariance Matrix 대신 두 지점 사이의 유사도를 측정하는 kernel 함수를 도입한다. 이러한 모델은 data efficient 하지만, prior나 kernel 함수의 설정이 어렵고, 추론 과정이 $O((n+m)^3)$로 computationally expensive 하다.\nConditional Neural Process (CNPs)\nCNP는 함수를 observation에 대한 조건부 분포로 가정한다. CNP는 observation을 고정된 크기의 embedding vector로 표현하고, 이를 토대로 새로운 query에 대한 추론을 만든다. 이 모든 것이 NN을 통한 single forward pass에 이뤄지기 때문에 관측수 n과 쿼리수 m에 대해 O(n + m)의 복잡도만을 요구로 한다.\nobservation O가 주어질 때 CNP는 $Q_\\theta$ 의 conditional process를 가정한다. 기존의 stochastic process처럼 O와 T의 순서에 대해 추론이 변하지 않는 permutation invariance를 보장한다. 또한 factorization $Q_\\theta(f(T)|O, T)=\\Pi_{x \\in T}Q_\\theta(f(x)|O, x)$을 가정한다.\nCNP의 구조는 다음과 같다.\n$r_i = h_\\theta(x_i, y_i) \\quad \\forall (x_i, y_i) \\in O$\n$r = \\oplus^n_i r_i$\n$\\phi_i = g_\\theta(x_i, r) \\quad \\forall x_i \\in T$\n이 때 $h_\\theta: X \\times Y \\to \\mathbb R^d$ 이고, $g_\\theta: X \\times \\mathbb R^d \\to \\mathbb R^e$ 이다. $\\oplus$는 observation embedding을 합치는 operation으로 본문에서는 permutation invariance를 지키기 위해 commutative 하다는 가정을 두었다.\n그 결과 process는 $Q_\\theta(f(x_i) | O, x_i) = Q(f(x_i) | \\phi_i)$ 로 표현되며, 이 과정이 NN forward pass만으로 이뤄지기 때문에 O(n + m)의 복잡도를 가진다.\nregression 에서는 $\\phi_i = (\\mu_i, \\sigma_i^2)$ 와 $\\mathcal N(\\mu_i, \\sigma_i^2)$ 로 두어 최종 $f(x_i)$가 가우시안을 따르게 하고, classification에서는 categorical distribution의 logits로 두었다.\n학습은 nll을 minimize 하는 방식으로 이뤄진다.\n$\\mathcal L(\\theta) = -\\mathbb E_{f \\sim P}\\left[\\mathbb E_N\\left[\\log Q_\\theta(\\lbrace y_i\\rbrace^{n-1}_{i=1}|O_N, \\lbrace x_i\\rbrace^{n-1} _{i=0})\\right]\\right]$\nDiscussion\n본문에서는 CNP가 training 데이터에서 prior을 적절히 학습하였고, 이를 통해 observation 간의 learning share이 가능하다고 이야기한다. 실험에서도 보였듯 data efficient하면서도 NN의 adaptivity를 충분히 잘 활용 하였고, meta-learning이나 few-shot learning 과의 상관성에 대해서도 이야기하였다. 지금은 POC 수준이지만, statistical context에서 function family를 적절히 encapsulate 한 것이 주요 contribution이지 않을까 싶다.\n추후 Neural Process나 Attentive Neural Process에서도 이야기하지만, CNP는 global uncertainty를 측정하는 수단이나, observation과 target 사이의 correlation을 측정하는 수단이 명시적으로 존재하지 않는다는 점도 고려해야 한다.\nImplementation\nTensorflow v1: tf-neural-process Reference\nConditional Neural Processes, Garnelo et al., 2018. ","permalink":"https://revsic.github.io/blog/cnp/","tags":["Machine Learning","Deep Learning","Bayesian","Stochastic Process","Neural Process","Conditional Neural Process"],"title":"Conditional Neural Processes"},{"categories":["Portfolio"],"contents":"Skills\nLanguages : Python : C++ [revsic/cpp-obfuscator]\nML Framework : Tensorflow [revsic/tf-glow-tts, revsic/tf-diffwave] : PyTorch [revsic/torch-retriever-vc, revsic/torch-diffusion-wavegan] : Jax/Flax [revsic/jax-variational-diffwave]\nWindows Internal [revsic/cpp-veh-dbi]\nProjects - Machine Learning\nnp-gaussian-process [GIT], 2019. : Numpy implementation of Gaussian Process Regression.\nAlphaZero Connect6 [GIT], 2018. : AlphaZero training framework for game Connect6 written in Rust with C++, Python interface.\nnumpy-rnn [GIT], 2017.07 : Numpy implementation of vanilla-rnn and lstm for solving binary addition and mnist classification problem.\nFine Dust Prediction [GIT], 2017. : Predict amount of fine dust for next 7 days via Convolutional LSTM based on Tensorflow.\nBehavior based Malware Detection Using Branch Data [GIT], 2017. : Classify malware from benign software using branch data via LSTM based on Tensorflow\nProjects - Windows Internal\ncpp-veh-dbi [GIT], 2019. : C++ implementation of vectored exception handler based simple dynamic binary instrumentation tools.\nBranch Tracer [GIT], 2019. : C++ implementation of dll-based windows debugger for tracking branching instruction via vectored exception handler.\nCode-Injector [GIT], 2018. : C++ implementation of several code injection techniques like dll injection, queue user apc.\nAntiDebugging [GIT], 2017. : C++ implementation for defending windows debugger from attaching the target process.\nProjects\ncpp-concurrency [GIT], 2019. : C++ implementation of golang-style concurrency supports, thread pool, channel, wait-group\ncpp-obfuscator [GIT], 2019. : C++ implementation of compile time string and routine obfuscator.\nTopMost [GIT], 2019. : C++ implementation of topmost library for windows and javascript support.\nRosettaStone [GIT], 2018. : C++ implementation of game \u0026lsquo;Hearthstone\u0026rsquo; as training environment and A.I. for future work.\nHaskell Calculator [GIST], 2017. : Haskell implementation of calculator with generic binary operators.\nThreeByteVM [GIST], 2017. : C implementation of simple virtual machine that word size is 3 bytes.\nPacketInjector [GIT], 2016. : C++ implementation of simple packet detector and injector.\nELF Code Virtualization, 2015. : ELF (Executable Linkable Format) Virtualized Code Protection\nPaper implementation\ntorch-nansy++ [GIT], 2022.12. : NANSY++: Unified Voice Synthesis with Neural Analysis and Synthesis, openreview, 2022.\ntorch-whisper-guided-vc [GIT], 2022.12. : Torch implementation of Whisper-guided DDPM based Voice Conversion\ntorch-nansy [GIT], 2022.09. : Neural Analysis and Synthesis: Reconstructing Speech from Self-Supervised Representations, Choi et al., 2021.\ntorch-retriever-vc [GIT], 2022.04. : Retriever: Learning Content-Style Representation as a Token-Level Bipartite Graph, Yin et al., 2022.\ntorch-diffusion-wavegan [GIT], 2022.03. : Parallel waveform generation with DiffusionGAN, Xiao et al., 2021.\ntorch-tacotron [GIT], 2022.02. : PyTorch implementation of Tacotron, Wang et al., 2017.\ntf-mlptts [GIT], 2021.09. : Tensorflow implementation of MLP-Mixer based TTS.\njax-variational-diffwave [GIT], [arXiv:2107.00630], 2021.09. : Variational Diffusion Models\ntf-glow-tts [GIT] [arXiv:2005.11129], 2021.07. : Glow-TTS: A Generative Flow for Text-to-Speech via Monotonic Alignment Search\ntf-survae-flows [GIT], [arXiv:2007.023731], 2021.05. : SurVAE Flows: Surjections to Bridge the Gap between VAEs and Flows\ntf-diffwave [GIT] [arXiv:2009.09761], 2020.10. : DiffWave: A Versatile Diffusion Model for Audio Synthesis, Zhifeng Kong et al., 2020.\nRewriting-A-Deep-Generative-Models [GIT] [arXiv:2007.15646], 2020.09. : Rewriting a Deep Generative Model, David Bau et al., 2020.\ntf-alae [GIT] [arXiv:2004.04467], 2020.09. : Adversarial Latent Autoencoders, Stanislav Pidhorskyi et al., 2020.\ntf-neural-process [GIT] [arxiv: NP, CNP, ANP], 2019.05 : Neural process, Conditional Neural Process, Attentive Neural Process\ntf-vanilla-gan [GIT] [arXiv:1406.2661], 2018.01. : Generative Adversarial Nets, Ian J. Goodfellow et al., 2014.\nSchool Works\nHYU-ITE2038 [GIT] : Database Systems and Applications in Hanyang University\nHYU-CSE4007 [GIT] : Artificial Intelligence\nHYU-ELE3021 [GIT] : Operating System\nStudy\nModern C++ Challenge [GIT] : Challenge real-world problems with C++17 features\nStanford-CS166: Data Structure : Data structure for undergraduate\nPaper\nBehavior Based Malware Detection Using Branch Data : 2017 KIISE Korea Computer Science Conference, 2017. Presentation\nThe 2nd AI \u0026amp; Dining. Virtual Human and Generative Models : Sangmyung University, 2022.09.22.\nDeep learning and A.I. : Danggok High School, 2022.08.30.\n2022 A.I.U. Research generative models in Startup [Google Drive] : A.I.U. 2022 AI Confrerence, 2022.05.\nDeveloping Environment for RL : Nexon Developers Conference 2019 as team RosettaStone, 2019.\nGP to NP: Gaussian process and Neural Process : A.I.U 1st Open AI Conference, 2018.\nHearthstone++: Hearthstone simulator with reinforcement learning Deep Learning Camp Jeju, 2018.\nBehavior based Malware Detection Using Branch Data : CodeGate 2017 Junior, 2017.\nAwards\nKISA, 2016 Software Contest, Application Security Section 2nd Prize (Minister of Interior Award) 2016.09 Education\nB.S. Department of Mathematics Hanyang University (2019.03 ~)\nB.S. Department of Computer Software Engineering Hanyang University (2018.03 ~)\nVulnerability Analysis Track : 5th KITRI BoB (2016.05 ~ 2017.03)\nDepartment of Information and Communication Technology : Sunrin Internet High School (2015.03 ~ 2017.02)\nWorks\nVideo Synthesis, Deep learning Researcher LionRocket (2021.10 ~)\nResearch Team Lead LionRocket (2021.04 ~)\nText-to-Speech Deep learning Researcher LionRocket (2019.09 ~ 2021.10)\n","permalink":"https://revsic.github.io/blog/worklist/","tags":["Portfolio"],"title":"Work list"},{"categories":null,"contents":"stylegan과 stargan modal collapse와 dkl 대조군의 필요성\n","permalink":"https://revsic.github.io/blog/stylegan/","tags":null,"title":""},{"categories":null,"contents":"wavernn lpcnet flowavenet waveglow waveflow melgan pwg vocgan hifigan diffwave wavegrad gelp wavenet parallel wavenet hooligan ilpcnet excitnet univnet sf-hifigan\n","permalink":"https://revsic.github.io/blog/vocoder/","tags":null,"title":""}]