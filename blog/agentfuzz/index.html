<!DOCTYPE html>
<html lang="ko-kr"><head>
  <meta charset="utf-8">
  <title>revsic | ML Developer</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="AgentFuzz: Agentic Fuzzing Harness Generation with LLM">
  <meta name="author" content="YoungJoong Kim">
  <meta name="generator" content="Hugo 0.125.7">

  <!-- plugins -->
  
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css ">
  
  <link rel="stylesheet" href="/plugins/slick/slick.css ">
  
  <link rel="stylesheet" href="/plugins/themify-icons/themify-icons.css ">
  
  <link rel="stylesheet" href="/plugins/venobox/venobox.css ">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="/scss/style.min.css" media="screen">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->
<!-- navigation -->
<header class="navigation">
  <div class="container">
    
    <nav class="navbar navbar-expand-lg navbar-white bg-transparent border-bottom">
      <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation">
        <i class="ti-menu h3"></i>
      </button>

      <div class="collapse navbar-collapse text-center" id="navigation">
        <div class="desktop-view">
          <ul class="navbar-nav mr-auto">
            
            <li class="nav-item">
              <a class="nav-link" href="https://www.facebook.com/profile.php?id=100009484787654"><i class="ti-facebook"></i></a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link" href="https://github.com/revsic"><i class="ti-github"></i></a>
            </li>
            
            <li class="nav-item">
              <a class="nav-link" href="https://www.linkedin.com/in/young-joong-kim-878630154/"><i class="ti-linkedin"></i></a>
            </li>
            
          </ul>
        </div>

        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="https://revsic.github.io/"> Home </a>
          </li>
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about">About</a>
          </li>
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/blog">Post</a>
          </li>
          
          
        </ul>

        
        <!-- search -->
        <div class="search px-4">
          <button id="searchOpen" class="search-btn"><i class="ti-search"></i></button>
          <div class="search-wrapper">
            <form action="https://revsic.github.io//search" class="h-100">
              <input class="search-box px-4" id="search-query" name="s" type="search" placeholder="Type & Hit Enter...">
            </form>
            <button id="searchClose" class="search-close"><i class="ti-close text-dark"></i></button>
          </div>
        </div>
        

        
      </div>
    </nav>
  </div>
</header>
<!-- /navigation -->

<section class="section-sm">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 mx-auto">
        
        <a href="/categories/software-testing"
          class="text-primary">Software testing</a>
        
        <h2>[WIP] Research: AgentFuzz, Agentic Fuzzing Harness Generation with LLM</h2>
        <div class="mb-3 post-meta">
          <span>By YoungJoong Kim</span>
          
          <span class="border-bottom border-primary px-2 mx-1"></span>
          <span>10 November 2024</span>
          
        </div>
        
        <img src="/images/post/agentfuzz/head.png" class="img-fluid w-100 mb-4" alt="[WIP] Research: AgentFuzz, Agentic Fuzzing Harness Generation with LLM">
        
        <div class="content mb-5">
          <p>아래 글은 2024년 3월부터 11월까지 수행한 학부 졸업 프로젝트에 관한 수기이다.</p>
<ul>
<li>Research about the Automatic Fuzzing Harness Generation</li>
<li>Keyword: Software Testing, Fuzzing, Harness Generation, Large Language Model, LLM</li>
<li>Basis: How to increate Branch Coverage in fuzzing.</li>
<li>Problem: Low TP Rate in Harness Generation with PromptFuzz.</li>
<li>Solution: Agentic Harness Generation.</li>
<li>Benefits: Improved Branch Coverage of the three projects; libxml2, libtiff, and libaom.</li>
<li>Contribution: Suggest an LLM Agent for the Harness Generation.</li>
<li>Weakness or Future work: -</li>
</ul>
<p><strong>Introduction</strong></p>
<p>소프트웨어 테스팅에서 Fuzzing은 소프트웨어에 무작위 입력을 대입하여 결함의 발생 여부를 관찰하는 방법론을 일컫는다. 무작위 입력을 생성하여 소프트웨어에 대입하고, 결함의 관찰을 대행하는 도구를 Fuzzer라 지칭한다. 경우에 따라 완전히 무작위한 값을 생성하기도 하고, 사용자에 의해 주어진 입력을 활용하기도 한다.</p>
<p>일반적으로 무작위 값을 단순히 소프트웨어에 입력할 경우, 대다수는 인터페이스에 해당하는 영역에서 입력값 검증 등 조건 분기를 통과하지 못하고 조기에 종료된다. 이에 내부 구현에 해당하는 영역은 대개 실행되지 않고, 테스트의 범위는 좁아지게 된다. 테스트의 범위를 효과적으로 확장하기 위해서는 다양한 조건 분기를 관측 및 선택하여, 각 경로를 exhaustive하게 탐색하는 것이 유리하다.</p>
<p>분기의 탐색을 효과적으로 수행하기 위해 Fuzzer는 Coverage를 활용하기도 한다.</p>
<p>소프트웨어 테스팅에서는 소프트웨어의 동작 과정에서 어떤 코드 블럭/분기/함수 등이 몇 번 실행되었는지 기록하여, 이를 &ldquo;Coverage&quot;라는 이름으로 관리한다. 기존까지는 실행되지 않았던 새로운 코드 블럭/분기/함수가 실행된 경우, 우리는 Coverage가 증가하였다고 표현한다.</p>
<p>몇몇 Fuzzer는 Coverage를 증가시킨 입력에 높은 우선순위를 두고, 우선순위에 따라 과거의 입력을 선택하여 무작위로 변조-소프트웨어에 대입하는 일련의 작업을 반복한다. 이 경우 전략 없이 단순 무작위 입력값을 생성하는 Fuzzer에 비해 높은 확률로 Coverage가 증가하는 방향의 입력이 성생되길 기대할 수 있다.</p>
<p>이렇게 무작위로 값을 변조하는 과정을 Mutation이라 하고, 과거의 입력을 Seed Corpora(복수형 Seed corpus)라 하자. 또한 Coverage 기반의 Mutation 전략을 가지는 Fuzzer를 아래 수기에서는 Greybox Fuzzer라 표현하겠다.</p>
<hr>
<p>Greybox Fuzzer 역시 한계를 가진다. Coverage 기반의 Mutation 전략을 통해 상대적으로 테스트 범위를 확장할 수 있었지만, 충분히 복잡한 소프트웨어의 분기 구조 속에서 무작위 입력만으로 도달할 수 있는 코드에는 한계가 있다. 또한, 그래픽 인터페이스를 내세운 소프트웨어의 경우, 생성된 입력을 적절한 인터페이스에 전달할 별도의 장치도 필요하다.</p>
<p>이러한 상황 속 더욱 효과적인 테스트를 위해 등장한 것이 Fuzzer Harness이다. Harness는 무작위 입력을 테스트 대상에 전달하는 별도의 소프트웨어로, 무작위 값을 인자로 특정 함수를 호출하거나, 네트워크 혹은 GUI 이벤트를 모방하여 무작위 입력을 인터페이스에 연결한다. Fuzzer는 Harness를 실행하고, Harness는 Fuzzer가 생성한 무작위 입력을 소프트웨어에 전달한다.</p>
<p>이를 통해 인터페이스의 제약에서 벗어나 테스트 대상의 특정 구현체를 직접 Fuzzing 할 수 있다.</p>
<p>다만, 이러한 Harness를 작성하기 위해서는 테스트 대상에 관한 이해가 선행되어야 하며, 테스트 대상에 새 기능이 추가 되거나 수정될 경우 Harness 역시 수정되어야 할 수 있다.</p>
<p>OSS-Fuzz-Gen, PromptFuzz 등 프로젝트는 이에 대응하기 위해 LLM을 활용하여 Harness를 생성, Fuzzing을 수행한다. Harness 작성 시간을 단축하고, Fuzzing의 진행 경과에 따라 동적으로 테스트가 부족한 영역에 Harness를 보강하여 전반적인 테스트 커버리지를 높여간다.</p>
<p>이번 졸업 프로젝트는 이러한 맥락 속에서 OSS-Fuzz-Gen과 PromptFuzz의 문제점을 정의하고, 그 개선점으로 AgentFuzz; Agentic fuzz harness generation을 제안한다.</p>
<p><strong>Relative Works: OSS-Fuzz-Gen</strong></p>
<p>OSS-Fuzz[<a href="https://github.com/google/oss-fuzz">google/oss-fuzz</a>]는 구글에서 운영하는 오픈소스 Fuzzing 프로젝트이다. 오픈소스 제공자가 빌드 스크립트와 Fuzzer를 제공하면 구글이 ClusterFuzz[<a href="https://github.com/google/clusterfuzz">google/cluster-fuzz</a>]를 통해 Google Cloud Platform(이하 GCP) 위에서 분산 Fuzzing을 구동-결과를 통고해 주는 방식으로 작동한다.</p>
<figure><img src="/images/post/agentfuzz/ossfuzz.png"
    alt="Figure 1. google/oss-fuzz#Overview" width="100%"><figcaption>
      <p>Figure 1. google/oss-fuzz#Overview</p>
    </figcaption>
</figure>

<p>일부 오픈소스 프로젝트에 대해 OSS-Fuzz는 LLM 기반으로 Harness를 생성-테스트하는 일련의 파이프라인을 제공한다; OSS-Fuzz-Gen[<a href="https://github.com/google/oss-fuzz-gen">google/oss-fuzz-gen</a>].</p>
<p>OSS-Fuzz는 Fuzz-introspector[<a href="https://github.com/ossf/fuzz-introspector">ossf/fuzz-introspector</a>]를 통해 ClusterFuzz의 실행 결과로부터 어떤 함수가 얼마나 호출되었고, 어떤 분기에 의해 후속 함수의 호출이 불발되었는지 분석-전달한다(i.e. fuzz-blocker, Figure 2.). OSS-Fuzz-Gen은 테스트가 미진한(호출되지 않았거나, 테스트 범위에 포함되지 않은) 함수를 fuzz-introspector의 보고서로부터 발췌하여 LLM에게 해당 함수의 Harness 생성을 요청한다.</p>
<figure><img src="/images/post/agentfuzz/overlay-1.png"
    alt="Figure 2. Reachability tree with coverage overlay (ref:git&#43;ossf/fuzz-introspector)" width="80%"><figcaption>
      <p>Figure 2. Reachability tree with coverage overlay (ref:git+ossf/fuzz-introspector)</p>
    </figcaption>
</figure>

<p>e.g. Prompt (from:<a href="https://storage.googleapis.com/oss-fuzz-llm-targets-public/index.html">oss-fuzz-llm-targets-public</a>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-md" data-lang="md"><span style="display:flex;"><span>You are a security testing engineer who wants to write a C++ program to execute all lines in a given function by defining and initialising its parameters in a suitable way before fuzzing the function through <span style="color:#d14">`LLVMFuzzerTestOneInput`</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Carefully study the function signature and its parameters, then follow the example problems and solutions to answer the final problem. YOU MUST call the function to fuzz in the solution.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Try as many variations of these inputs as possible. Do not use a random number generator such as <span style="color:#d14">`rand()`</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>All variables used MUST be declared and initialized. Carefully make sure that the variable and argument types in your code match and compiles successfully. Add type casts to make types match.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>You MUST call <span style="color:#d14">`CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON *const a, const cJSON *const b, const cJSON_bool case_sensitive)`</span> in your solution!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-style:italic">*SKIPPED*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Problem:
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span>CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON *const a, const cJSON *const b, const cJSON_bool case_sensitive)
</span></span><span style="display:flex;"><span>``
</span></span></code></pre></div><p>Generated:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;stdint.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span><span style="color:#000;font-weight:bold">extern</span> <span style="color:#d14">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#include</span> <span style="color:#999;font-weight:bold;font-style:italic">&#34;../cJSON.h&#34;</span><span style="color:#999;font-weight:bold;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">LLVMFuzzerTestOneInput</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">uint8_t</span> <span style="color:#000;font-weight:bold">*</span>data, <span style="color:#458;font-weight:bold">size_t</span> size); <span style="color:#998;font-style:italic">/* required by C89 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">LLVMFuzzerTestOneInput</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">uint8_t</span><span style="color:#000;font-weight:bold">*</span> data, <span style="color:#458;font-weight:bold">size_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cJSON <span style="color:#000;font-weight:bold">*</span>a <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">cJSON_Parse</span>((<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>)data);
</span></span><span style="display:flex;"><span>    cJSON <span style="color:#000;font-weight:bold">*</span>b <span style="color:#000;font-weight:bold">=</span> <span style="color:#900;font-weight:bold">cJSON_Parse</span>((<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span>)data);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span>(a <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span> <span style="color:#000;font-weight:bold">||</span> b <span style="color:#000;font-weight:bold">==</span> <span style="color:#0086b3">NULL</span>) <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">cJSON_Compare</span>(a, b, <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">cJSON_Compare</span>(a, b, <span style="color:#099">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">cJSON_Delete</span>(a);
</span></span><span style="display:flex;"><span>    <span style="color:#900;font-weight:bold">cJSON_Delete</span>(b);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic"></span>}
</span></span><span style="display:flex;"><span><span style="color:#999;font-weight:bold;font-style:italic">#endif
</span></span></span></code></pre></div><p>LLM은 함수의 Spec을 입력으로 Harness를 작성한다(주로 OpenAI GPT, Google Gemini). 단번에 Syntax Error가 없는 Harness를 생성하기는 어려우므로, OSS-Fuzz-Gen은 컴파일 에러 메시지를 LLM에게 전달하여 오류 수정을 요구한다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-md" data-lang="md"><span style="display:flex;"><span>Given the following C program and its build error message, fix the code without affecting its functionality. First explain the reason, then output the whole fixed code.
</span></span><span style="display:flex;"><span>If a function is missing, fix it by including the related libraries.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Code:
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span>CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON *const a, const cJSON *const b, const cJSON_bool case_sensitive)
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Solution:
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span><span style="color:#999">#include &lt;stdlib.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#999"></span>/* <span style="color:#000;font-style:italic">*SKIPPED*</span> */
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Build error message:
</span></span><span style="display:flex;"><span>/src/cjson/fuzzing/cjson_read_fuzzer.c:1:1: error: unknown type name &#39;CJSON_PUBLIC&#39;
</span></span><span style="display:flex;"><span>CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON *const a, const cJSON *const b, const cJSON_bool case_sensitive)
</span></span><span style="display:flex;"><span>^
</span></span><span style="display:flex;"><span>/src/cjson/fuzzing/cjson_read_fuzzer.c:1:25: error: expected &#39;;&#39; after top level declarator
</span></span><span style="display:flex;"><span>CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON *const a, const cJSON *const b, const cJSON_bool case_sensitive)
</span></span><span style="display:flex;"><span>                        ^
</span></span><span style="display:flex;"><span>                        ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fixed code:
</span></span></code></pre></div><p>최대 3~5회까지 수정을 반복하여 Syntax Error를 수정하고, 컴파일에 성공한 경우 최초 시동을 통해 Harness가 Fuzzing과 무관히 Crash를 내는지 확인한다. Fuzzing 전부터 Crash가 발생한다면, 생성된 Harness를 활용하여 Fuzzing을 수행하는 것이 무의미할 것이다.</p>
<p>FYI. 끝내 Syntax Error 해결에 실패한 경우 해당 Harness는 폐기하고, LLM에게 새 Harness 합성을 요구한다.</p>
<p>정상 작동한 Harness는 ClusterFuzz로 전달되고, GCP 위에서 Fuzzer를 구동한다.</p>
<p>OSS-Fuzz-Gen은 LLM을 활용하여 tinyxml2 등 프로젝트에서 Test Coverage를 30%까지 추가 획득하였다고 이야기한다[<a href="https://security.googleblog.com/2023/08/ai-powered-fuzzing-breaking-bug-hunting.html">googleblog</a>].</p>
<p><strong>Relative Works: PromptFuzz</strong></p>
<p>OSS-Fuzz-Gen은 LLM을 기반으로 가용한 Harness를 생성할 수 있다는 점을 보였다. 하지만, 대개 함수 개개에 대한 Harness를 작성하기에, API 간의 유기 관계를 테스트하는 것에는 한계가 있다. 특히나 Internal State를 공유하고, 이에 따라 조건 분기를 취하는 라이브러리의 경우, 어떻게 API를 조합하느냐에 따라 trigging할 수 있는 코드 블럭의 부류가 달라질 수 있다.</p>
<p>PromptFuzz[<a href="https://arxiv.org/abs/2312.17677">arXiv:2312.17677</a>, <a href="https://github.com/PromptFuzz/PromptFuzz">git+PromptFuzz/PromptFuzz</a>]는 이에 대응하고자 여러 API를 하나의 Harness에서 동시에 호출하는 방식을 취하고, 어떤 API를 선택하는 것이 테스트에 유리할지 전략을 제시한다.</p>
<figure><img src="/images/post/agentfuzz/workflow.png"
    alt="Figure 3. PromptFuzz/PromptFuzz#workflow" width="100%"><figcaption>
      <p>Figure 3. PromptFuzz/PromptFuzz#workflow</p>
    </figcaption>
</figure>

<p>PromptFuzz는 라이브러리의 헤더 파일로부터 AST 파서를 활용해 함수(API) 및 타입의 선언을 발췌, Gadget이라는 이름으로 관리한다. PromptFuzz는 매 Round마다 이 중 일부를 선택하여 LLM에 Harness 생성을 요구한다.</p>
<p>PromptFuzz는 생성된 Harness의 유효성, Correctness를 검증하기 위한 몇 가지 방법론을 제안하며, 이를 모두 통과한 Harness에 대해서만 Fuzzing을 수행한다.</p>
<p><strong>PromptFuzz: Harness Mutation</strong></p>
<p>가장 먼저 고민한 문제는 어떤 API Gadget을 골라 Harness를 만드는가이다. PromptFuzz가 API의 유기 관계를 모델링하기 위해 선택한 방식은 상용 Fuzzer가 Seed Corpus를 Mutation 하는 정책과 동일 선상에 있다.</p>
<p>상용 Fuzzer는 유전 알고리즘을 통해 Coverage가 높은 Seed Corpora를 선택하고, 이를 무작위로 조작하여(random mutation을 가하여) 새로운 입력을 생성한다. Coverage를 측정하여 상위부터 Mutation을 수행하는 일련의 과정을 반복하며, Coverage를 높일 입력을 찾아나가는 것이다.</p>
<p>PromptFuzz는 API Gadget의 순열(이하 API Sequence)을 잘 선택하여 Harness를 구성, 테스트 범위를 확장하길 바란다. 그렇기에 API Sequence를 평가할 지표를 두어 서로 다른 API Sequence 사이에 순서를 정하고, 상위 API Sequence부터 Random Mutation을 수행하여 LLM에게 Harness 생성을 요청한다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#998;font-style:italic">## PSEUDO CODE OF PROMPTFUZZ</span>
</span></span><span style="display:flex;"><span><span style="color:#0086b3">type</span> APISequence <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">list</span>[APIGadget]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">round</span>(seed_harnesses: <span style="color:#0086b3">list</span>[Harness]):
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># selection</span>
</span></span><span style="display:flex;"><span>    selected: Harness <span style="color:#000;font-weight:bold">=</span> weighted_sample(
</span></span><span style="display:flex;"><span>        seed_harnesses,
</span></span><span style="display:flex;"><span>        weight_fn<span style="color:#000;font-weight:bold">=</span>quality_measure,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># mutation</span>
</span></span><span style="display:flex;"><span>    new_api_sequence: APISequence <span style="color:#000;font-weight:bold">=</span> mutation(selected)
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># generate to harness</span>
</span></span><span style="display:flex;"><span>    harness: Harness <span style="color:#000;font-weight:bold">=</span> LLM(
</span></span><span style="display:flex;"><span>        SYSTEM_PROMPT,
</span></span><span style="display:flex;"><span>        <span style="color:#d14">f</span><span style="color:#d14">&#34;Generate a fuzzer harness containing the given APIs: </span><span style="color:#d14">{</span>new_api_sequence<span style="color:#d14">}</span><span style="color:#d14">&#34;</span>,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># validation</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">not</span> is_valid(harness):
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> ValidationFailureError()
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># run the fuzzer</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#000;font-weight:bold">=</span> run_fuzzer(harness)
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># append to seeds</span>
</span></span><span style="display:flex;"><span>    seed_harnesses<span style="color:#000;font-weight:bold">.</span>append(harness)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> result
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>seed_harnesses, quiet <span style="color:#000;font-weight:bold">=</span> [], <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># given</span>
</span></span><span style="display:flex;"><span>max_round: <span style="color:#0086b3">int</span>
</span></span><span style="display:flex;"><span>max_budget: <span style="color:#0086b3">float</span>
</span></span><span style="display:flex;"><span>max_quiet: <span style="color:#0086b3">int</span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"># run the PromptFuzz</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">for</span> _ <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(max_round):
</span></span><span style="display:flex;"><span>    result <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">round</span>(seed_harnesses)
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># terminal condition#1: API Budget</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> litellm<span style="color:#000;font-weight:bold">.</span>_current_cost <span style="color:#000;font-weight:bold">&gt;</span> max_budget:
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># terminal condition#2: Quiet round</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">not</span> <span style="color:#0086b3">isinstance</span>(result, ValidationFailureError):
</span></span><span style="display:flex;"><span>        quiet <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">elif</span> quiet <span style="color:#000;font-weight:bold">&gt;</span> max_quiet:
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>        quiet <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span></code></pre></div><p>PromptFuzz는 Harness 역시 Mutation의 대상으로 바라보아 전략적으로 테스트 범위 확장을 의도한다.</p>
<p>Greybox Fuzzer가 Coverage를 Seed Corpus 평가의 지표로 두었다면, PromptFuzz는 API Sequence에 대해 Quality라는 지표를 제안한다.</p>
<p><strong>Measure</strong></p>
<p>Quality는 Density와 #Unique Branches의 곱으로 표현된다. Harness Mutation의 목표는 Coverage 확보이다. Mutated Harness를 통해 Coverage(혹은 #Unique Branches)가 얼마나 확보되었는지 파악하는 것은 자명한 일이다. 여기서 중요한 것은 Density의 역할이다.</p>
<p>FYI. #Unique Branches는 Harness를 단위 시간 동안 Fuzzing 하였을 때, Harness에 의해 실행된 대상 프로젝트 내 분기의 수이다. 대상 프로젝트의 Coverage는 #Unique Branches를 프로젝트 내 전체 분기의 수로 나눈 것과 같다.</p>
<p>$$\mathrm{Quality}(g) = \mathrm{Density}(g) \times (1 + \mathrm{UniqueBranches}(g))$$</p>
<p>PromptFuzz는 Harness 내 API의 유기 관계를 적극 활용하여 Coverage를 높이고자 한다. API의 유기 관계에 대한 평가 지표가 제안되어야 하고, 해당 지표가 Coverage 확보에 기여함을 보인다면 명쾌할 것이다.</p>
<p>PromptFuzz가 이를 위해 제안한 지표가 Density이다. API의 유기 관계는 앞선 API의 호출이 후속 API의 실행 흐름에 얼마나 영향을 미치는지로 표현된다. 한 API의 호출이 다른 API의 실행 흐름에 영향을 주기 위해서는 (1) 앞선 호출이 프로젝트의 State를 변화시켜, 후속 실행 흐름에 간접적 영향을 주거나 (2) 앞선 호출의 결과값이 후속 API의 인자로 전달되어 직접적 영향을 주는 2가지 경우로 나뉠 것이다.</p>
<p>Density는 이중 후자의 경우에 집중한다. Harness 내에 존재하는 API를 Node로 표현하고, Taint Analysis를 통해 Harness의 실행 흐름 중 한 API의 반환값이 다른 API의 인자로 전달되는 경우를 Directed Edge로 하여 API Call Depedency Graph를 그린다.</p>
<p>만약 아래의 Harness가 있다면, 다음의 CDG를 예상해 볼 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vpx_codec_dec_cfg_t dec_cfg <span style="color:#000;font-weight:bold">=</span> {<span style="color:#099">0</span>};
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Initialize the decoder
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>vpx_codec_ctx_t decoder;
</span></span><span style="display:flex;"><span>vpx_codec_iface_t <span style="color:#000;font-weight:bold">*</span>decoder_iface <span style="color:#000;font-weight:bold">=</span> vpx_codec_vp8_dx();
</span></span><span style="display:flex;"><span>vpx_codec_err_t decoder_init_res <span style="color:#000;font-weight:bold">=</span> vpx_codec_dec_init_ver(
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">&amp;</span>decoder, decoder_iface, <span style="color:#000;font-weight:bold">&amp;</span>dec_cfg, <span style="color:#099">0</span>, VPX_DECODER_ABI_VERSION);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (decoder_init_res <span style="color:#000;font-weight:bold">!=</span> VPX_CODEC_OK) {
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Process the input data
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>vpx_codec_err_t decode_res <span style="color:#000;font-weight:bold">=</span> vpx_codec_decode(<span style="color:#000;font-weight:bold">&amp;</span>decoder, data, size, <span style="color:#0086b3">NULL</span>, <span style="color:#099">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">if</span> (decode_res <span style="color:#000;font-weight:bold">!=</span> VPX_CODEC_OK) {
</span></span><span style="display:flex;"><span>    vpx_codec_destroy(<span style="color:#000;font-weight:bold">&amp;</span>decoder);
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Get the decoded frame
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>vpx_image_t <span style="color:#000;font-weight:bold">*</span>img <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>vpx_codec_iter_t iter <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> ((img <span style="color:#000;font-weight:bold">=</span> vpx_codec_get_frame(<span style="color:#000;font-weight:bold">&amp;</span>decoder, <span style="color:#000;font-weight:bold">&amp;</span>iter)) <span style="color:#000;font-weight:bold">!=</span> <span style="color:#0086b3">NULL</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Process the frame
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    vpx_img_flip(img);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// Cleanup
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>vpx_codec_destroy(<span style="color:#000;font-weight:bold">&amp;</span>decoder);
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">return</span> <span style="color:#099">0</span>;
</span></span></code></pre></div><figure><img src="/images/post/agentfuzz/cdg.png"
    alt="Figure 4. Call Dependency Graph" width="50%"><figcaption>
      <p>Figure 4. Call Dependency Graph</p>
    </figcaption>
</figure>

<p>FYI. 위는 예시이며, 실제 구현과는 다를 수 있다.</p>
<p>Graph는 SCC로 분해가능하고, 각 Component의 Cardinality(집합 내 원소의 수) 중 가장 큰 값을 Density라 명명한다.</p>
<p>FYI. SCC(Strongly Connected Component): 노드의 집합, (1) 집합 내 어떤 임의의 두 노드를 선택하여도 이를 잇는 경로가 존재하고-Strongly Connected, (2) Graph 내 어떤 두 노드가 Strongly Connected이면 둘은 같은 SCC에 속함-Component. (Strongly Connected Nodes의 집합 중 가장 크기가 큰 집합.)</p>
<p>FYI. Graph는 SCC로 Partition 가능하다. (i.e. Graph는 SCC의 집합으로 표현 가능하고, Graph 내 모든 SCC는 mutually disjoint이다.)</p>
<p>위 CDG는 기재된 모든 함수 사이에 서로를 잇는 Edge가 존재하므로 Graph 전체가 하나의 SCC이며, Density는 SCC 내 노드의 개수인 6이다.</p>
<p>Density는 Harness 내 직접적 영향을 주고 받는 API의 군집 중 가장 큰 군집의 크기를 의미한다. Density가 크다는 것은 Harness 내의 API 유기 관계에 부피감이 있음을 의미한다. (1) 이는 너비를 의미할 수도 있고-여러 API의 독립적 실행 결과가 하나의 API에 영향을 가함, (2) 깊이를 의미할 수도 있으며-API의 호출이 순차적으로 영향을 가함, (3) 이 둘 모두를 의미할 수도 있다.</p>
<p>Density는 Taint Analysis의 범위에 따라 간접 영향에 관하여는 모델링하지 못할 수도 있고, 그 부피감이 어떤 형태의 Call Dependency를 가지는지 묘사하지 못하기도 한다.</p>
<p>결국 Quality는 (1) Coverage가 높을수록 (2) API의 유기 관계에 부피감이 있을수록 좋은 Harness라 정의하고 있다.</p>
<p><strong>Mutation</strong></p>
<p>Quality에 따라 Harness가 선택되고 나면 PromptFuzz는 Mutation을 수행한다. Byte string을 직접 조작하는 Corpus Mutation과 달리, Harness Mutation은 API Sequence 수준에서 Mutation을 가하고, LLM을 통해 Mutated API Sequence를 새로운 Harness로 생성하는 과정을 거친다.</p>
<p>$$\mathrm{Harness} \mapsto \mathrm{API\ Sequence} \mapsto \mathrm{Mutated} \mapsto \mathrm{New\ Harness}$$</p>
<p>LLM이 Mutated API Sequence를 토대로 Harness를 만들어도, 제시된 API가 모두 Harness에 포함되어 있지는 않다(LLM의 한계). 따라서 Harness에서 사용한 API를 모두 발췌하여 실행 순서에 따라 Topological Sort를 수행, 생성된 Harness의 API Sequence로 정의한다.</p>
<p>API Sequence에는 (1) API Insert, (2) API Remove, (3) Crossover 3가지 방식의 Mutation 중 하나를 무작위 선택하여 가하게 된다.</p>
<p>API Insert와 Remove는 주어진 API Sequence의 임의 지점에 새로운 API Gadget을 삽입하거나, 임의 지점의 API Gadget을 제거하는 방식으로 작동한다. Crossover는 또 다른 API Sequence와 임의 지점에서 Sequence 전-후반을 접합하는 방식으로 작동한다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#998;font-style:italic">## PSEUDO CODE OF MUTATION</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">insert</span>(harness: Harness, gadgets: <span style="color:#0086b3">list</span>[APIGadget]):
</span></span><span style="display:flex;"><span>    seq: APISequence <span style="color:#000;font-weight:bold">=</span> extract_apis(harness)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">while</span> <span style="color:#000;font-weight:bold">True</span>:
</span></span><span style="display:flex;"><span>        api: APIGadget <span style="color:#000;font-weight:bold">=</span> weighted_sample(
</span></span><span style="display:flex;"><span>            gadgets,
</span></span><span style="display:flex;"><span>            weight_fn<span style="color:#000;font-weight:bold">=</span>energy_measure,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">if</span> api <span style="color:#000;font-weight:bold">not</span> <span style="color:#000;font-weight:bold">in</span> seq:
</span></span><span style="display:flex;"><span>            <span style="color:#000;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>    seq<span style="color:#000;font-weight:bold">.</span>insert(random<span style="color:#000;font-weight:bold">.</span>randint(<span style="color:#099">0</span>, <span style="color:#0086b3">len</span>(seq)), api)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> seq
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">remove</span>(harness: Harness):
</span></span><span style="display:flex;"><span>    seq: APISequence <span style="color:#000;font-weight:bold">=</span> extract_apis(hanress)
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic"># inverse energy order</span>
</span></span><span style="display:flex;"><span>    api: APIGadget <span style="color:#000;font-weight:bold">=</span> weighted_sample(
</span></span><span style="display:flex;"><span>        seq,
</span></span><span style="display:flex;"><span>        weight_fn<span style="color:#000;font-weight:bold">=</span><span style="color:#000;font-weight:bold">lambda</span> x: <span style="color:#099">1</span> <span style="color:#000;font-weight:bold">/</span> energy_measure(x),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    seq<span style="color:#000;font-weight:bold">.</span>remove(api)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> seq
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">crossover</span>(harness: Harness, seed_harnesses: <span style="color:#0086b3">list</span>[Harness]):
</span></span><span style="display:flex;"><span>    seq: APISequence <span style="color:#000;font-weight:bold">=</span> extract_apis(harness)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    other: Harness <span style="color:#000;font-weight:bold">=</span> weighted_sample(
</span></span><span style="display:flex;"><span>        seed_harnesses,
</span></span><span style="display:flex;"><span>        weight_fn<span style="color:#000;font-weight:bold">=</span>quality_measure,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    other_seq: APISequence <span style="color:#000;font-weight:bold">=</span> extract_apis(other)
</span></span><span style="display:flex;"><span>    i <span style="color:#000;font-weight:bold">=</span> random<span style="color:#000;font-weight:bold">.</span>randint(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(seq) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    j <span style="color:#000;font-weight:bold">=</span> random<span style="color:#000;font-weight:bold">.</span>randint(<span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(other_seq) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> seq[:i] <span style="color:#000;font-weight:bold">+</span> other_seq[j:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>new_api_sequence: APISequence
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">match</span> random<span style="color:#000;font-weight:bold">.</span>randint(<span style="color:#099">0</span>, <span style="color:#099">2</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">0</span>: new_api_sequence <span style="color:#000;font-weight:bold">=</span> insert(harness, gadgets)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">1</span>: new_api_sequence <span style="color:#000;font-weight:bold">=</span> remove(harness)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">case</span> <span style="color:#099">2</span>: new_api_sequence <span style="color:#000;font-weight:bold">=</span> crossover(harness, seed_harnesses)
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">return</span> new_api_sequence
</span></span></code></pre></div><p>Crossover는 역시 Quality에 따라 Harness를 추가 선발하여 활용한다. 동일 논리라면, Insert와 Remove 역시 추가 혹은 제거 대상으로 삼을 API의 기준이 필요할 것이다.</p>
<p>프로젝트에 따라 PromptFuzz에서 발췌된 API Gadget은 만여개 단위까지 늘어난다. 이 중에는 실제로도 자주 쓰이는 API로, LLM 역시 단번에 활용처를 이해하고 컴파일까지 성공하는 API가 있는반면, 자주 쓰이지 않아 LLM 역시 컴파일에 실패하거나 빈번히 오사용하는 API도 있다.</p>
<p>PromptFuzz는 이러한 상황에서 이미 충분히 테스트 되었다 판단된 API의 사용을 줄이고, 테스트 되지 않은 API의 사용 시도를 늘리기 위해 Insert와 Remove의 대상에 Energy라는 기준을 제시한다.</p>
<p>$$\mathrm{Energy}(a) = \frac{1 - \mathrm{Coverage}(a)}{(1 + \mathrm{Seed}(a))^E \times (1 + \mathrm{Prompt}(a))^E}$$</p>
<p>Energy는 각 API에 대한 평가 지표로, Energy가 높을수록 Mutation 후 Harness에 해당 API가 잔존할 확률을 높이고, Energy가 낮을수록 잔존 확률을 낮춘다.</p>
<p>FYI. Coverage(a)는 API $a$ 내부의 분기 중 실행된 분기의 비율. Prompt(a)는 mutated api sequence에 API $a$가 포함된 횟수(LLM에게 전달된 횟수). Seed(a)는 실제 API $a$를 포함하고 있는 Seed Harnesses의 수(API가 LLM에게 합성 요청되어도 실제 Harness에 포함되지 않을 수 있고, 포함되더라도 Validation 단계를 통과하지 못해 Seed Harnesses에 포함되지 않을 수 있음.)</p>
<p>FYI. E는 하이퍼파라미터, git+PromptFuzz/PromptFuzz는 1로 가정.</p>
<p>API가 충분히 테스트 되었다 판단될수록(i.e. Coverage가 100%에 가까워질수록) API는 Mutated Harness에 포함될 가능성이 줄어든다. 이는 자명하다.</p>
<p>어떤 API는 LLM에게 많이 합성 요청되었지만, 컴파일 오류나 오사용으로 인해 Fuzzing 대상이 되지 못할 수 있다. 이 경우는 LLM의 성능상 한계라 이해하고, Energy를 통해 해당 API 역시 Mutated Harness에 포함될 가능성을 낮춘다.</p>
<p>결국 PromptFuzz는 Quality와 Energy를 통해 API가 고루 테스트 될 수 있도록 하고, 지표 기반 Mutation으로 좋은 Harness를 찾아나간다.</p>
<p><strong>PromptFuzz: Harness Validation</strong></p>
<p>생성된 Harness는 유효성, Correctness를 검증받게 된다. Syntax Error를 포함하여 컴파일이 불가능하거나, API의 오사용으로 인해 새로이 탐색 가능한 분기가 없다면 굳이 이를 구동할 이유가 없을 것이다. PromptFuzz는 효과적인 Fuzzing을 위해 몇 가지 검증 기준을 제안한다.</p>
<p>가장 간단히는 컴파일이 가능해야 한다. LLM의 응답으로부터 ```의 코드 블록이 존재한다면, 블록 내에서 코드를 발췌-컴파일을 시도한다. Syntax Error가 발생할 경우 LLM에게 오류 수정을 요구하는 OSS-Fuzz-Gen과 달리 PromptFuzz는 곧장 생성된 Harness를 폐기하고, 새로 생성을 시도한다.</p>
<p>컴파일에 성공했다면, 최대 10분간 Fuzzer를 구동한다. 1분 단위로 현재 Fuzzer의 Coverage를 측정하여, Coverage가 증가할 경우 지속-유지될 경우 구동을 중지한다. 이후 기존까지 실행되었던 Seed Harnesses의 Fuzzing 결과와 비교하여 새로운 분기가 발견되었는지 검사한다. 만약 분기가 발견되지 않았다면, 현재 검토 중인 Harness는 Coverage 확보에 기여하기 어렵다 판단하여 폐기한다.</p>
<p>만약 컴파일에도 성공하고, 새로운 분기도 확인하였다면 <em>Critical Path</em> 검증으로 마무리 한다.</p>
<p><strong>Critical Path</strong></p>
<p>Critical Path는 Harness 내 여러 Control Flow 중 가장 많은 API를 호출할 수 있는 흐름을 의미한다. 예를 들면, Figure 4.의 예시에서 Critical Path는 다음 6개 API를 포함하고 있다.</p>
<p>vpx_codec_vp8_dx &gt; vpx_codec_dec_init_ver &gt; vpx_codec_decode &gt; vpx_codec_get_frame &gt; vpx_img_flip &gt; vpx_codec_destroy</p>
<p>PromtpFuzz는 최대 10분간의 Harness 구동 중 Critical Path 내의 모든 API가 Hit 되었는지 검사한다.</p>
<p>만약 생성된 Harness가 API를 오사용하였다면 테스트는 비정상 종료될 것이고, Harness에 포함된 API 중 일부는 실행되지 않을 것이다. 반대로 모든 API가 사용되었는지를 테스트한다면, 주류 흐름 외의 에러 핸들링에 사용되는 API까지 강제되는 등 통과가 불가능하거나 비효율적인 평가가 이뤄질 수 있다.</p>
<p>이에 PromptFuzz는 주류 API 흐름의 실행을 보장하고자 Critical Path를 정의하고, 주류 흐름 내의 모든 API가 실행되었는지를 검토한다.</p>
<p><strong>PromptFuzz: Benchmarks</strong></p>
<p>PromptFuzz는 총 14개 프로젝트에 대해 벤치마크 테스트를 수행한다.</p>
<figure><img src="/images/post/agentfuzz/table1.png"
    alt="Table 1. Overall results for PromptFuzz-generated fuzz drivers" width="100%"><figcaption>
      <p>Table 1. Overall results for PromptFuzz-generated fuzz drivers</p>
    </figcaption>
</figure>

<p>AgentFuzz의 개발 전, <a href="https://github.com/PromptFuzz/PromptFuzz">git+PromptFuzz/PromptFuzz</a>를 토대로 벤치마크 테스트를 재현하였다. 논문에서 Harness 생성에 사용한 gpt-3.5-turbo-0613 모델은 현재 Deprecate 되어 사용이 불가능하다. 아래는 gpt-4o-mini-2024-07-18을 운용하였을 때의 결과를 첨부한다.</p>
<figure><img src="/images/post/agentfuzz/corr.png"
    alt="Figure 5. Evaluation results of the benchmark projects." width="100%"><figcaption>
      <p>Figure 5. Evaluation results of the benchmark projects.</p>
    </figcaption>
</figure>

<p>프로젝트의 Branch Coverage는 대개 프로젝트의 전체 Branch 수(i.e. # Total Branch, log-scale)와, 전체 API Gadget 중 실행된 API의 비율(i.e. api/executed, %)에 상관관계를 갖는다. 이 둘은 직관 상 자명한 지표이다.</p>
<p>(1) 일정 깊이 이상의 경로를 Random mutation만으로 접근하게 될 가능성은 깊이에 따라 기하급수적으로 감소한다. Branch가 많아지면 Nested Branch의 존재 가능성이 커지고, 자연스레 Mutation의 한계로 Branch Coverage가 감소하는 것이다.</p>
<p>(2) AgentFuzz는 거의 모든 API를 LLM에게 1회 이상 전달한다. 하지만 LLM의 성능상 한계로 인해, 생성된 Harness가 요청된 API 중 일부를 포함하지 않거나, 포함하더라도 평가를 통과하지 못해 결국 테스트 되지 않는 API가 발생한다. 해당 API에 포함된 Branch는 실행 기회를 얻지 못하고, Branch Coverage에는 상한선이 발생한다.</p>
<table>
<thead>
<tr>
<th>proj#revision</th>
<th>Branch Cov</th>
<th>Total Branch</th>
<th>Executed API</th>
<th>Exposed API</th>
<th>Coverage(R/UB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>cjson#424ce4c</td>
<td>82.08%</td>
<td>1038</td>
<td>100%</td>
<td>67.85%</td>
<td>82.08%</td>
</tr>
<tr>
<td>zlib#545f194</td>
<td>70.09%</td>
<td>2906</td>
<td>92.04%</td>
<td>57.89%</td>
<td>83.12%</td>
</tr>
<tr>
<td>c-ares#3b8058</td>
<td>59.96%</td>
<td>8076</td>
<td><strong>12.59%</strong></td>
<td>17.44%</td>
<td>76.67%</td>
</tr>
<tr>
<td>sqlite3#27095f</td>
<td>62.44%</td>
<td>39926</td>
<td>77.66%</td>
<td>10.66%</td>
<td>91.93%</td>
</tr>
<tr>
<td>libpng#d3cf9b</td>
<td>44.58%</td>
<td>7750</td>
<td>93.08%</td>
<td>47.49%</td>
<td><strong>52.31%</strong></td>
</tr>
<tr>
<td>libmagic#cf6bf1</td>
<td>48.31%</td>
<td>7470</td>
<td><strong>61.11%</strong></td>
<td><strong>5.84%</strong></td>
<td>163.51%</td>
</tr>
<tr>
<td>libpcap(1.11.0)</td>
<td>36.76%</td>
<td>7808</td>
<td>90.47%</td>
<td>15.30%</td>
<td><strong>36.90%</strong></td>
</tr>
<tr>
<td>lcms#5c54a6</td>
<td>42.70%</td>
<td>9220</td>
<td>75.94%</td>
<td>24.31%</td>
<td><strong>63.10%</strong></td>
</tr>
<tr>
<td>libtiff#7a3fb2</td>
<td>29.29%</td>
<td>14576</td>
<td><strong>38.26%</strong></td>
<td>21.77%</td>
<td>155.42%</td>
</tr>
<tr>
<td>libvpx#b15d2a</td>
<td>17.70%</td>
<td>35050</td>
<td>97.29%</td>
<td><strong>0.88%</strong></td>
<td><strong>20.35%</strong></td>
</tr>
<tr>
<td>libaom#47f42d</td>
<td>15.79%</td>
<td>60100</td>
<td>97.87%</td>
<td><strong>0.48%</strong></td>
<td><strong>15.87%</strong></td>
</tr>
<tr>
<td>libxml2(2.9.4)</td>
<td>1.31%</td>
<td>71378</td>
<td><strong>9.41%</strong></td>
<td>54.32%</td>
<td><strong>7.06%</strong></td>
</tr>
</tbody>
</table>
<p>이를 기반으로 성능 분석과 개선점 확보를 위해 다음과 같이 분류해 보았다.</p>
<ul>
<li>Executed API 비율 70% 미만: c-ares(59.96%), libmagic(48.31%), libtiff(29.29%), libxml2(1.31%)</li>
<li>상한 대비 Coverage 70% 미만
<ul>
<li>API 노출 비율 10% 미만: libvpx(17.70%), libaom(15.79%)</li>
<li>원인 불명: libpng(52.31%), libpcap(36.90%)</li>
<li>lcms(42.70%): 다소 못 미치지만, 다른 프로젝트에 비해 비교적 양호한 Coverage를 확보</li>
</ul>
</li>
<li>Executed API 비율 70% 이상, 상한 대비 Coverage 70% 이상: cjson(82.08%), zlib(70.09%), sqlite3(62.44%)</li>
</ul>
<p>FYI. Executed API: 전체 API Gadget 중 실행이 확인된 API의 비율 (i.e. api/executed, %)</p>
<p>FYI. 상한 대비 Coverage(R/UB; Relative coverage to upper bound): 실행된 API의 전체 Branch 모수 대비 실행된 Branch의 비율(실행되지 않은 API의 Branch는 모수에서 제외).</p>
<p>Executed API의 비율이 70% 미만인 네 개 프로젝트(c-ares 12.59%, libmagic 61.11%, libtiff 38.26%, libxml2 9.41%)는 Branch Coverage가 60% 미만이다. 이는 생성된 Harness가 API를 충분히 포함하지 않아, Coverage 확보에 불리한 조건을 가지고 시작하는 사례이다.</p>
<p>Coverage(R/UB)의 관찰 목적은 LLM이 만든 Harness가 API Gadget을 충분히 포함한다면, 이후 Branch Coverage 확보에 문제가 없는지 확인하기 위함이다. Nested Branch가 유독 많거나, Branch의 조건이 tight 한 경우에는 많은 API가 테스트 되어도 Random Mutation 등의 한계로 여전히 Branch Coverage 확보가 어려울 수 있다.</p>
<p>실제로 상한 대비 Coverage가 70% 미만인 프로젝트는 총 6건이 관찰되었다. 이중 libvpx와 libaom은 비디오 코덱 라이브러리로, 입력에 따라 어떤 코덱 모듈이 실행될지 결정된다. Public corpus에 특정 코덱이 주어지지 않거나, 운이 좋게 변조된 입력이 다른 코덱으로 인식되어도, 후속 파싱 과정에서 sanity check failure로 조기 종료될 가능성이 높다.</p>
<p>이러한 사례들은 라이브러리에 존재하는 전체 함수의 수 대비 API로 공개된 함수의 수가 10% 미만이다(이하 Exposed API, %).</p>
<p>원인 불명의 두 개 라이브러리 libpng와 libpcap을 제외하면 나머지는 Executed API의 비율 70% 이상, 상한 대비 Coverage(R/UB) 역시 70% 이상으로 양호한 경향을 보인다.</p>
<p><strong>TP Rate and Executed API</strong></p>
<p>다음은 12개 프로젝트, 40회의 실험에 대한 Pearson Correlation Matrix이다.</p>
<figure><img src="/images/post/agentfuzz/corrmat.png"
    alt="Figure 6. Matrix of Pearson Correlation" width="80%"><figcaption>
      <p>Figure 6. Matrix of Pearson Correlation</p>
    </figcaption>
</figure>

<p><details>
    <summary>항목 설명</summary>
    <ul>
<li>api/prompted(%): 전체 API Gadget 중 Harness 생성 프롬프트에 기재된 API Gadget의 비율</li>
<li>api/executed(%): 전체 API Gadget 중 TP Harness에 포함되어 1회 이상 테스트 된 API Gadget의 비율</li>
<li>api/energies(mean): Harness 생성 시도가 종료된 후 최종 API별 Energy 값의 평균</li>
<li>api/coverages(mean): Harness 생성 시도가 종료된 후 최종 API별 Branch Coverage의 평균</li>
<li>api/#apis(log): 전체 API Gadget의 수 (log-scale)</li>
<li>branch/#branches(log): 프로젝트 내 전체 Branch의 수 (log-scale)</li>
<li>branch/coverage(%): Fuzzing 종료 후 최종 Branch Coverage</li>
<li>llm/quota($): Harness 생성에 사용한 LLM API 비용</li>
<li>llm/#call: Harness 생성 중 총 LLM을 호출한 횟수</li>
<li>llm/tp-rate(%): 생성된 Harness 중 검증 과정을 전부 통과한 Harness의 수</li>
</ul>

</details> <br>
이번 AgentFuzz 프로젝트는 Branch Coverage 확보를 대전제로 잡는다.</p>
<p>Branch Coverage(i.e. branch/coverage, %)와 다른 지표의 상관관계를 살피면, 다음의 순서대로 계수가 높은 것을 확인할 수 있다.</p>
<ul>
<li>(절댓값 기준) api/coverages(mean) 0.88 &gt; api/energies(mean) 0.76 &gt; branch/#branches(log) 0.75 &gt; llm/tp-rate(%) 0.73 &gt; api/#apis(log) 0.71 &gt; api/executed(%) 0.70</li>
</ul>
<p>이중 api/coverages(mean)과 api/energies(mean)은 직접적으로 Branch Coverage와 포함 관계를 가지는 지표이기에 제외, branch/#branches(log)와 api/#apis(log)는 프로젝트와 함께 주어지는 수치이므로 제외한다.</p>
<p>현재 관찰된 지표 내에서 0.70 이상의 계수를 가지며, 개선의 대상으로 삼을 수 있는 지표는 TP Rate와 Executed API의 비율이다.</p>
<p>앞서 확인하였듯, Executed API는 직접적으로 Branch Coverage와 인과 관계를 가지는 지표이며, 12개의 프로젝트 중 4개의 프로젝트는 70% 미만의 Executed API를 가진다. 이는 특히 libxml2에서 그 문제가 두드러진다(Executed API 9.41%).</p>
<p>Executed API를 개선할 수 있다면, 확보 가능한 Branch Coverage의 상한을 높이는 일이 될 것이다.</p>
<p><strong>Q. 정말 대부분의 API가 LLM에게 전달되었는가</strong></p>
<p>Executed API를 살피기 전, 정말 대부분의 API가 LLM에 전달되었는지 확인해야 한다. 만약 LLM에 API가 전달되지 않았다면, Execution은 당연히 기대할 수 없다.</p>
<table>
<thead>
<tr>
<th>proj#revision</th>
<th>Total API</th>
<th>Prompted API</th>
<th>Executed API</th>
<th>Executed/Prompted (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>cjson#424ce4c</td>
<td>76</td>
<td>76(100%)</td>
<td>76(100%)</td>
<td>100%</td>
</tr>
<tr>
<td>zlib#545f194</td>
<td>88</td>
<td>87(98.86%)</td>
<td>81(92.04%)</td>
<td>93.10%</td>
</tr>
<tr>
<td>c-ares#3b8058</td>
<td>135</td>
<td>135(100%)</td>
<td>17(12.59%)</td>
<td><strong>12.59%</strong></td>
</tr>
<tr>
<td>sqlite3#27095f</td>
<td>291</td>
<td>290(99.65%)</td>
<td>226(77.66%)</td>
<td><strong>77.93%</strong></td>
</tr>
<tr>
<td>libpng#d3cf9b</td>
<td>246</td>
<td>246(100%)</td>
<td>229(93.08%)</td>
<td>93.08%</td>
</tr>
<tr>
<td>libmagic#cf6bf1</td>
<td>18</td>
<td>18(100%)</td>
<td>11(61.11%)</td>
<td><strong>61.11%</strong></td>
</tr>
<tr>
<td>libpcap(1.11.0)</td>
<td>84</td>
<td>83(98.80%)</td>
<td>76(90.47%)</td>
<td>91.56%</td>
</tr>
<tr>
<td>lcms#5c54a6</td>
<td>291</td>
<td>287(98.62%)</td>
<td>221(75.94%)</td>
<td><strong>77.00%</strong></td>
</tr>
<tr>
<td>libtiff#7a3fb2</td>
<td>196</td>
<td>193(98.46%)</td>
<td>75(38.26%)</td>
<td><strong>38.86%</strong></td>
</tr>
<tr>
<td>libvpx#b15d2a</td>
<td>37</td>
<td>37(100%)</td>
<td>36(97.29%)</td>
<td>97.29%</td>
</tr>
<tr>
<td>libaom#47f42d</td>
<td>47</td>
<td>45(95.74%)</td>
<td>46(97.87%)</td>
<td>97.82%</td>
</tr>
<tr>
<td>libxml2(2.9.4)</td>
<td>1594</td>
<td><strong>1109(69.57%)</strong></td>
<td>150(9.41%)</td>
<td><strong>13.52%</strong></td>
</tr>
</tbody>
</table>
<p>확인 결과 libxml2를 제외한 11개 프로젝트는 모두 95% 이상의 API가 LLM에게 전달되었다. libxml2 역시 70%에 가까운 API가 LLM에게 전달되었으나, 전달된 API 중 13.52%만이 실제 TP Harness에 1회 이상 포함되었다.</p>
<p>앞서 Executed API의 비중이 70%를 넘지 않았던 c-ares, libmagic, libtiff, libxml2는 Prompted API 대비 Executed API의 비율이 역시 70%를 넘지 않았다.</p>
<p>이는 반대로 API Gadget이 1천여개를 넘지 않는다면, gpt-4o-mini 기준 5$의 budget 내에서 현재의 Harness Mutation이 만드는 조합이 전체 API를 1회 이상 테스트하는데 충분함을 의미한다.</p>
<figure><img src="/images/post/agentfuzz/apimut.png"
    alt="Figure 7. API Mutations (좌: libpcap 1.11.0, 우: libxml2 2.9.4)" width="100%"><figcaption>
      <p>Figure 7. API Mutations (좌: libpcap 1.11.0, 우: libxml2 2.9.4)</p>
    </figcaption>
</figure>

<p>위는 각 Round에서 몇 개의 API가 Mutator에 의해 제거되었고(removed), 유지되었으며(keep), 새로 추가되었는지를 보인다(inserted). API Mutator는 평균 80% 이상의 API를 매번 교체한다(libpcap 82%, libxml2 98%).</p>
<p>Prompted API에 포함되지 않은 API는 Budget 등 조건에 의해 Harness 생성이 조기 종료되지 않는다면, 시간이 지남에 따라 충분히 포함될 여지를 가진다.</p>
<p>FYI. 1회 이상의 테스트를 통해 Quality와 Density 지표를 기반으로 API의 조합에 따른 경향을 살피고 싶다면, 5$ 이상의 Budget을 요구할 수 있다. 이는 이번 프로젝트에서는 다루지 않는다.</p>
<p><strong>Problems; TP Rate</strong></p>
<p>아래는 각 벤치마크를 5$ 내에서 구동하며 LLM이 생성한 Harness의 수(Generated Harnesses)와 모든 검증 과정을 통과한 Harness의 수(TP Harnesses)이다.</p>
<table>
<thead>
<tr>
<th>proj#revision</th>
<th>Generated Harnesses</th>
<th>TP Harnesses</th>
<th>TP Rate</th>
</tr>
</thead>
<tbody>
<tr>
<td>cjson#424ce4c</td>
<td>1050</td>
<td>170</td>
<td>16.19%</td>
</tr>
<tr>
<td>zlib#545f194</td>
<td>1660</td>
<td>155</td>
<td>9.33%</td>
</tr>
<tr>
<td>c-ares#3b8058</td>
<td>8880</td>
<td>92</td>
<td>1.03%</td>
</tr>
<tr>
<td>sqlite3#27095f</td>
<td>4300</td>
<td>797</td>
<td>18.53%</td>
</tr>
<tr>
<td>libpng#d3cf9b</td>
<td>5450</td>
<td>327</td>
<td>6.00%</td>
</tr>
<tr>
<td>libmagic#cf6bf1</td>
<td>10000</td>
<td>8</td>
<td>0.08%</td>
</tr>
<tr>
<td>libpcap(1.11.0)</td>
<td>8950</td>
<td>187</td>
<td>2.89%</td>
</tr>
<tr>
<td>lcms#5c54a6</td>
<td>8620</td>
<td>267</td>
<td>3.09%</td>
</tr>
<tr>
<td>libtiff#7a3fb2</td>
<td>11660</td>
<td>2</td>
<td>0.017%</td>
</tr>
<tr>
<td>libvpx#b15d2a</td>
<td>8180</td>
<td>194</td>
<td>2.37%</td>
</tr>
<tr>
<td>libaom#47f42d</td>
<td>2500</td>
<td>145</td>
<td>5.80%</td>
</tr>
<tr>
<td>libxml2(2.9.4)</td>
<td>8770</td>
<td>15</td>
<td>0.17%</td>
</tr>
</tbody>
</table>
<p>도표에서 확인할 수 있듯, 대개 TP Rate는 10%를 넘지 않는다.</p>
<p>libxml2의 사례를 살폈을 때, 각 검증 단계의 실패 비율은 다음과 같다(모수 8770개 Harness).</p>
<table>
<thead>
<tr>
<th>Syntax Error</th>
<th>Link Error</th>
<th>Execution Failure</th>
<th>Coverage Ungrowth</th>
<th>Critical Path Unhit</th>
<th>Hang</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>76%</strong></td>
<td>0.98%</td>
<td>17.9%</td>
<td>0.18%</td>
<td>4.5%</td>
<td>0.1%</td>
</tr>
</tbody>
</table>
<p>사실상 대부분의 Harness가 단번의 컴파일에 성공하지 못하는 상황이다. OSS-Fuzz-Gen과 달리 PromptFuzz는 재시도를 수행하지 않기에, LLM이 자체적으로 고칠 수 있는 컴파일 에러 역시 묵과하고 모두 실패 처리한다.</p>
<p>이 중 일부는 Instruction Prompt에 기재된 API Gadget의 시그니처만으로 인자를 정상 기입하지 못해 발생한다. 인자의 타입이 aliased type인지, 구조체라면 어떤 타입의 멤버를 가지는지 등 정보를 충분히 확보하지 못했다면, LLM은 인자에 기입할 데이터의 타입을 적절히 선정하지 못하고, 이는 syntax error로 이어진다.</p>
<p>이러한 API를 포함한 Harness는 지속적으로 검증에 실패하고, 해당 API는 테스트 되지 못한 채 $\mathrm{Prompt(\cdot)}$ 항에 의해 Energy의 감소를 겪어, 끝내 TP Harness에 단 한 번도 포함되지 않는다. 앞서 Executed API의 비율이 특히 낮았던 libxml2에서 자주 관측되는 사례이다.</p>
<p>결국 Executed API의 비중을 높여, 실행 가능한 Branch의 상한을 추가 확보하기 위해서는 Syntax Error를 통과할 수 있는 환경을 구성해야 한다.</p>
<p>그러고 나면 Exposed API의 비중이 낮은 2개 사례를 제외하고, Executed API의 비중이 낮은 4개 프로젝트, 상한 대비 Coverage가 70% 미만인 원인 불명의 2개 프로젝트에서 개선을 관측할 수 있길 기대한다.</p>
<p><strong>Pre-trials</strong></p>
<p>다음은 AgentFuzz 개발 이전의 개선 시도이다. 실험의 대상은 가장 경과가 좋지 않았던 libxml2이다.</p>
<p><strong>Trial#1: Fix Syntax Error</strong></p>
<p>가장 먼저 시도한 것은 OSS-Fuzz-Gen과 같은 Syntax Error 개선 시도이다.</p>
<p>PromptFuzz는 컴파일에 실패한 모든 Harness를 폐기한다. 생성된 Harness 중 76%가 Syntax Error 단계에서 폐기된다. OSS-Fuzz-Gen은 최대 5회까지 컴파일 에러를 LLM에게 전달하여 Syntax Error 수정을 요구한다. 이를 참고하여 동일한 instruction으로 PromptFuzz에서도 Harness의 수정을 시도하였다. <br>
(ref:<a href="https://github.com/revsic/PromptFuzz/commit/7438a0dc86cfb3604618bc33f470b9e3cd60990c">git+revsic/PromptFuzz/commit/7438a0dc86cfb3604618bc33f470b9e3cd60990c</a>)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-md" data-lang="md"><span style="display:flex;"><span>Given the above C fuzz harness and its build error message, fix the code to make it build for fuzzing.
</span></span><span style="display:flex;"><span>If there is undeclared identifier or unknown type name error, fix it by finding and including the related libraries.
</span></span><span style="display:flex;"><span>MUST RETURN THE FULL CODE, INCLUDING UNCHANGED PARTS.
</span></span><span style="display:flex;"><span>Below is the error to fix:
</span></span><span style="display:flex;"><span>The code has the following build issues:
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span>{}
</span></span><span style="display:flex;"><span>``
</span></span><span style="display:flex;"><span>Fix code:
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">1.</span> Consider possible solutions for the issues listed above.
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">2.</span> Choose a solution that can maximize fuzzing result, which is utilizing the function under test and feeding it not null input.
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">3.</span> Apply the solutions to the original code.
</span></span><span style="display:flex;"><span>It&#39;s important to show the complete code, not only the fixed line.
</span></span></code></pre></div><table>
<thead>
<tr>
<th>proj#revision</th>
<th>TP Rate</th>
<th>Branch Cov</th>
<th>Executed API</th>
</tr>
</thead>
<tbody>
<tr>
<td>libpcap(1.11.0)</td>
<td>187/8950(2.89%)</td>
<td>39.76%</td>
<td>76/83/84(90.47%)</td>
</tr>
<tr>
<td>libpcap(1.11.0) syntax-error fix</td>
<td>68/4255(1.598%)</td>
<td>35.30%</td>
<td>76/83/84(90.47%)</td>
</tr>
<tr>
<td>libxml2(2.9.4)</td>
<td>15/8770(0.17%)</td>
<td>1.31%</td>
<td>150/1109/1594(9.41%)</td>
</tr>
<tr>
<td>libxml2(2.9.4)  syntax-error fix</td>
<td>20/2138(0.935%)</td>
<td>1.38%</td>
<td>153/476/1594(9.59%)</td>
</tr>
</tbody>
</table>
<p>기본적으로 Syntax Error를 수정하는 과정에서 LLM API 비용이 추가 발생하므로, 동일 Budget 내에서 생성된 Harness의 모수는 줄어들었다(8950 &gt; 4255, 8770 &gt; 2138). libpcap에서는 TP Rate가 줄어들었으나, 실행된 API의 비율은 동일하게 유지되었다. 동일 Harness 생성 모수 187개까지 비용을 더 투자하였다면, 선형 추정 시 TP Harness는 143개였을 것이기에 Branch Cov 역시 유사한 수준까지 오를 것이라 기대할 수 있다.</p>
<p>libxml2에서도 극적인 개선을 보이지는 않았다. 마찬가지로 Harness 생성 시도가 줄었지만, TP Rate는 5배가량 개선되었다. 그에 따라 Executed API와 Branch Coverage도 미세하게 증가하였다. Prompted API 대비 Executed API의 비중은 13.52%(150/1109)에서 32.14%(153/476)로 증가한 만큼, Saturation의 속도는 감소할 것으로 기대한다.</p>
<p>실제로 Syntax Error에 의한 검증 실패는 6천여건에서 1천여건 이상 감소하였지만(~16% 감소), 후속 Coverage Growth와 Critical Path Hit 단계의 오류는 증가하였다.</p>
<p>이를 두고 동일 Budget 내에서 Tp Rate이 개선되었다고 보기는 어렵다.</p>
<p><strong>Trial#2: Extend gadget length</strong></p>
<p>다음은 Gadget length를 늘려보았다.</p>
<p>PromptFuzz는 API Sequence의 길이를 10으로 두어, LLM에게 최대 10개의 API를 포함하는 Harness 생성을 요구한다. 이 시도는 libxml2만을 위한 시도로, API의 수가 많아 Prompted API가 유독 낮은 프로젝트에 대해 API Sequence의 길이를 20까지 증가시켜 Prompted API의 비율을 높일 수 있는지 보았다.</p>
<table>
<thead>
<tr>
<th>proj#revision</th>
<th>TP Rate</th>
<th>Branch Cov</th>
<th>Executed API</th>
</tr>
</thead>
<tbody>
<tr>
<td>libxml2(2.9.4)</td>
<td>15/8770(0.17%)</td>
<td>1.31%</td>
<td>150/1109/1594(9.41%)</td>
</tr>
<tr>
<td>+ gadget length=20</td>
<td>11/8640(0.127%)</td>
<td>1.06%</td>
<td>63/1585/1594(3.95%)</td>
</tr>
</tbody>
</table>
<p>실제로 Prompted API는 99.43%에 가깝게 증가하였지만, 오히려 TP Rate와 Coverage는 감소하였다. 이는 Gadget의 수가 증가하면서 인자의 타입 추정 실패로 인한 Syntax Error가 더 자주 발생하여 TP Rate를 낮춘 것이 원인일 것으로 추정된다.</p>
<table>
<thead>
<tr>
<th>Gadget length</th>
<th>Syntax Error</th>
<th>Link Error</th>
<th>Execution Failure</th>
<th>Coverage Ungrowth</th>
<th>Critical Path Unhit</th>
<th>Hang</th>
</tr>
</thead>
<tbody>
<tr>
<td>5~10</td>
<td>76%(6669)</td>
<td>0.98%(86)</td>
<td>17.9%(1573)</td>
<td>0.18%(16)</td>
<td>4.5%(401)</td>
<td>0.1%(10)</td>
</tr>
<tr>
<td>10~20</td>
<td><strong>81%(7105)</strong></td>
<td>1.1%(96%)</td>
<td>14.5%(1255)</td>
<td>0.092%(8)</td>
<td>2.8%(247)</td>
<td>0.92%(8)</td>
</tr>
</tbody>
</table>
<p><strong>Q. Generate Harness until all APIs are executed ?</strong></p>
<p>API Sequence의 길이를 늘리는 것이 부수 효과를 발생시켜 오히려 TP Rate를 낮추는 현상을 확인했다. 그렇다면 Budget 등 종료 조건이 없는 상황에서 시간과 자원을 투자한다면 70% 이상의 Executed API를 확보할 수 있을까.</p>
<p>우선 libxml2에 대해 10$ API Budget을 모두 소모할 때까지 돌려보았다. 총 218시간(=9일 2시간) 동안 구동하였지만, TP Rate 0.601%, Branch Coverage 2.43%이다. 선형 추정하였을 때도 Branch Coverage 100%를 위해서는 500달러(25.01.27.기준 71만원)의 Budget과 10,900시간(454일)의 시간이 필요하다.</p>
<table>
<thead>
<tr>
<th>proj#revision</th>
<th>TP Rate</th>
<th>Cost(4o-mini)</th>
<th>Coverage</th>
<th>Expectation</th>
</tr>
</thead>
<tbody>
<tr>
<td>lcms#5c54a6</td>
<td>3.09%</td>
<td>78H, 5.0$</td>
<td>42.70%</td>
<td>182H(7D), 11.70$</td>
</tr>
<tr>
<td>libaom#47f42d</td>
<td>5.80%</td>
<td>176H, 10$</td>
<td>15.79%</td>
<td>1,114H(46D), 63.33$</td>
</tr>
<tr>
<td>libxml2(2.9.4)</td>
<td>0.601%</td>
<td>218H, 10$</td>
<td>2.43%</td>
<td>10,900H(454D), 500$</td>
</tr>
<tr>
<td>sqlite3#27095f</td>
<td>18.53%</td>
<td>266H, 10$</td>
<td>62.44%</td>
<td>426H(17D), 16.01$</td>
</tr>
</tbody>
</table>
<p>이는 선형 추정이므로, Saturation을 고려하였을 때는 이보다 많은 시간과 비용이 필요할 것이다. TP Rate는 단순 Executed API 확보뿐 아니라, 현실적 시간 내에 유의미한 Harness를 얼마나 만들 수 있는가의 또 다른 논의를 만든다.</p>
<p><strong>AgentFuzz</strong></p>
<p>AgentFuzz는 단위 시간 내 TP Rate 개선을 목표로 하였다.</p>
<ul>
<li><a href="https://github.com/revsic/agent-fuzz">git+revsic/agent-fuzz</a></li>
</ul>
<p>Syntax Error에 관한 피드백은 해당 단계의 오류를 1천여건 이상 감소시켰지만, 그만큼의 오류가 후속 검증 단계로 옮겨갔다. 전반적인 검증 단계에서의 오류 수정 시도가 필요하다.</p>
<p>그를 위해서는 LLM이 &ldquo;Project에 대한 이해&quot;를 가져야 한다고 판단한다. 여기서 &ldquo;이해&quot;는 &ldquo;특정 브랜치를 Hit 하도록 Harness를 조작하기 위해 필요한 지식&quot;으로 정의한다. 함수의 정의, 함수 간 참조 관계 등의 정보가 필요할 것으로 보인다.</p>
<p>이러한 이해를 LLM에게 전달하기 위해서는, 사전에 정보를 모두 전달하거나 필요할 때마다 Tool Call을 통해 획득할 수 있게 두어야 한다. 사전에 모든 정보를 전달하기에 C 프로젝트의 함수는 하나하나의 길이가 길어, 전문을 첨부할 경우 Context length에 의한 추론 성능 하락이 발생할 수 있다[ref:<a href="https://arxiv.org/abs/2404.06654">RULER, Hsieh et al., 2024. arXiv:2404.06654</a>]. 이에 필요에 따라 정보를 획득하도록 설계하였고, LLM Agent의 형태로 구현하여 &ldquo;agent-fuzz&rdquo; 프로젝트로 명명했다.</p>
<p><strong>Re-implement PromptFuzz with Python</strong></p>
<p>가장 먼저 PromptFuzz를 Python으로 재현하였다. <br>
PromptFuzz는 Rust로 구현되어 있었고, 그다지 친숙하지는 않은 개발 환경이었기에 가장 활발히 사용한 언어로 재현하며 구현 상세를 이해하고자 하였다.</p>
<p>재현하는 과정에서 PromptFuzz를 구동하며 겪은 불편함도 몇 가지 해결하였다.</p>
<p>PromptFuzz는 CDG를 구성하고 Critical Path를 발췌하는 과정에서 직접 AST를 순회한다. 문제는 이 과정에서 Visitor가 구현되지 않은 AST Node가 발견되면 panic을 내며 Harness 생성을 종료한다. 직접 AST Visitor를 구현한다면 재현체에서도 동일하게 발생할 문제이기에, LLVM의 <code>opt</code>를 활용하여 CFG를 생성하는 방식으로 대체하였다.</p>
<figure><img src="/images/post/agentfuzz/graph.png"
    alt="Figure 8. A dot-CFG Sample" width="100%"><figcaption>
      <p>Figure 8. A dot-CFG Sample</p>
    </figcaption>
</figure>

<p><code>opt</code>는 LLVM Optimizer 겸 Analyzer로, IR을 입력으로 CFG를 생성하는 옵션을 제공한다. 생성된 CFG를 기반으로 가장 긴 API Call Sequence를 파싱한다면 구현되지 않은 AST Visitor를 고민할 필요가 사라진다.</p>
<p>그 외에도 C/C++이 아닌 언어에서도 사용할 수 있도록 추상화하는 작업과 프롬프트 템플릿 분리 등 몇몇 리팩토링을 병행하였다.</p>
<p><strong>Tool Call Design</strong></p>
<p>AgentFuzz는 검증을 통과하지 못한 Harness를 재사용하여 TP-Rate를 높이는 것이 목표이다. 이는 현실적인 시간 내에 가용한 Harness를 많이 확보하기 위함이고, 이를 통해 Executed API의 비중을 높여 프로젝트의 전반적인 Coverage를 상향 평준화하기 위함이다.</p>
<p>이를 위해 AgentFuzz는 두 가지 기능상 요구사항을 가진다.</p>
<ol>
<li>생성된 Harness가 검증에 실패할 경우, 실패 원인을 피드백하여 LLM에 개선을 요구할 수 있어야 한다.</li>
<li>Harness 개선에 필요한 정보를 제공할 수 있어야 한다.</li>
</ol>
<p>요구사항을 LLM Agent에 녹여내기 위해 (1) 생성한 Harness를 평가하고 피드백하는 Tool과 (2) 프로젝트의 정보를 제공하는 Tool을 구현하였다.</p>
<p>프로젝트의 정보 검색 Tool은 Harness에 포함하라 전달된 API의 정의를 검색할 수 있는 기능과 소스 코드의 일부를 읽고 반환하는 기능 두 가지로 단순히 구성하였다.</p>
<p><strong>Validation Feedback</strong></p>
<p>Harness Validation에 관한 Tool로는 <code>validate</code> 함수를 구현하였다.</p>
<p>LLM은 Harness를 반환하기 이전, 생성한 Harness를 <code>validate</code> Tool을 통해 검증할 것을 요구받는다. OpenAI의 Tool Calling API를 통해 <code>validate</code> Tool의 명세를 전달하면, LLM은 Harness를 입력으로 <code>validate</code> Tool을 호출한다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">validate</span>(<span style="color:#999">self</span>, harness: <span style="color:#0086b3">str</span>) <span style="color:#000;font-weight:bold">-&gt;</span> <span style="color:#0086b3">dict</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#d14">&#34;&#34;&#34;Validate the given harness.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    Validation consists of seven steps.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    1. Parse the code segment from the requested harness. The process only uses the code segment enclosed within ``` ```.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    2. Compile the code segment into a runnable fuzzer.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    3. Run the fuzzer.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    4. Check whether the coverage has increased more than the global coverage.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    5. Check whether all APIs have been hit.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    If all steps pass, you will see a &#34;success&#34; flag in the response.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    However, if something is wrong, you will see an error flag and the steps where the error occurs.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    Then you should fix the harness to ensure the steps pass and retry the validation.
</span></span></span><span style="display:flex;"><span><span style="color:#d14">
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    Parameters
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    ----------
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    harness : str
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        The requested harness, for example,
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        ```cpp
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        #include &lt;stdlib.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        #include &lt;stdint.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#d14">
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        extern &#34;C&#34; int LLVMFuzzerTestOneInput(const uint8_t data, size_t size) {
</span></span></span><span style="display:flex;"><span><span style="color:#d14">            // your harness here
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        }
</span></span></span><span style="display:flex;"><span><span style="color:#d14">        ```
</span></span></span><span style="display:flex;"><span><span style="color:#d14">    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>Validator는 Harness를 각 단계에 맞게 검증하고, 실패할 경우 사전에 정의된 피드백을 전달한다.</p>
<figure><img src="/images/post/agentfuzz/validate.png"
    alt="Figure 9. Tool Call: Harness Validation (Compile failure)" width="100%"><figcaption>
      <p>Figure 9. Tool Call: Harness Validation (Compile failure)</p>
    </figcaption>
</figure>

<p>Figure 9은 그 중 컴파일에 실패했을 때의 피드백이다. 단순히 컴파일 에러를 첨부하는 것만으로도 LLM이 Syntax Error가 수정된 Harness를 생산할 수 있음을 확인하였다.</p>
<figure><img src="/images/post/agentfuzz/feedback1.png"
    alt="Figure 10. Tool Call: Harness Validation (Coverage Ungrowth)" width="80%"><figcaption>
      <p>Figure 10. Tool Call: Harness Validation (Coverage Ungrowth)</p>
    </figcaption>
</figure>

<p>다음은 Coverage Ungrowth이다. 현재까지의 Harness Generation 과정에서 발견하지 못했던 Branch가 존재하는지를 피드백한다. 우선은 단순히 Coverage가 낮음을 지적한다.</p>
<p>FYI. Ideation: Fuzz blocker나 Hit되지 않은 새로운 Branch를 명시적으로 제안하는 것도 하나의 피드백이 될 수 있어 보인다.</p>
<figure><img src="/images/post/agentfuzz/feedback2.png"
    alt="Figure 11. Tool Call: Harness Validation (Critical Path Unhit)" width="80%"><figcaption>
      <p>Figure 11. Tool Call: Harness Validation (Critical Path Unhit)</p>
    </figcaption>
</figure>

<p>마지막은 Critical Path Unhit이다. Critical Path에 포함된 API 중 일부가 호출되지 않은 경우에, Local Coverage를 토대로 호출된 함수와 호출되지 않은 함수를 구분하여 전달한다.</p>
<p>FYI. Local Coverage: 현행 Validation 단계에서 10분간 Fuzzing을 수행하면서 획득한 Coverage로 명명한다. 이전까지의 Seed Harnesses에서 획득한 모든 Coverage는 별도로 병합하여 Global Coverage로 명명-관리한다.</p>
<p><strong>Initial Run</strong></p>
<p>이렇게 두 가지 툴이 주어졌을 때, 최대 30회의 Tool Call 내에 Harness 생성을 지시했다. gpt-4o-mini-2024-07-18은 대개 다음 순서에 따라 Harness 생성을 시도한다.</p>
<ol>
<li>API Sequence에 포함된 <strong>API 각각의 정의</strong>를 검색</li>
<li>정의 검색 결과를 토대로 정의에 해당하는 <strong>코드 영역을 리뷰</strong></li>
<li>Harness 생성, <strong>평가 함수 호출 반복</strong></li>
</ol>
<p>최초에는 미리 함수의 정의를 전달하는 것이 비효율적일 것이라 판단하였으나, 실제 LLM의 경향상 정의를 사전에 전달하여도 무관했을 것으로 보인다.</p>
<p>AgentFuzz의 최초 Testbed는 cJSON으로 삼았다. API의 수가 적고 PromptFuzz에서도 Coverage가 높았던 프로젝트이기에, 상대적으로 쉬운 대상으로 여겼다.</p>
<p>cJSON 프로젝트 기준, Agent는 최초 시동에서 39회의 Harness 생성 시도 중 회당 평균 13.84회의 Tool Call을 수행하였다. 이 중 4회는 LLM을 30회 이상 호출하여 강제 중지되었으며, 21개의 Harness가 정상 생성되었다.</p>
<p>TP Rate는 53.84%(21/39)이며, 회당 평균 13.84회의 LLM 호출이 있었으므로 PromptFuzz와 비교한다면 3.88%(21/540)로 볼 수 있다. 기존 16.19%(170/1050)와 비교한다면 23% 정도로 많이 감소한 수치이지만, Branch Coverage는 77.53%로(기존 82.08%) 감소 폭이 상대적으로 적은 편이다.</p>
<p>다음은 LLM Agent를 통해 Harness 생성을 시도하면서 1493회의 Tool Call, 그중 1261회의 Validation Failure를 통계화한 도표이다.</p>
<table>
<thead>
<tr>
<th>Parse Error</th>
<th>Compile Error</th>
<th>Execution Failure</th>
<th>Coverage Ungrowth</th>
<th>Critical Path Unhit</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.40%</td>
<td>3.82%</td>
<td>0%</td>
<td>62.76%</td>
<td>1.94%</td>
</tr>
</tbody>
</table>
<p>Harness 평가에 관한 피드백 이후 Compile Error는 3.82% 수준이다. 하지만 cJSON은 libxml2과 대비하여 Compile Error의 비율이 낮았던 프로젝트이기에, 기존의 컴파일 에러 76%와 직접 비교할 수는 없다.</p>
<p>그 외에 Coverage Ungrowth에서 상당히 큰 비중이 발생함을 확인할 수 있다.</p>
<table>
<thead>
<tr>
<th>proj#revision</th>
<th>TP Rate</th>
<th>Branch Cov</th>
<th>Executed API</th>
</tr>
</thead>
<tbody>
<tr>
<td>cjson#424ce4c</td>
<td>170/1050(16.19%)</td>
<td>852/1038(82.08%)</td>
<td>76/76/76(100%)</td>
</tr>
<tr>
<td>- agentfuzz</td>
<td>42/135(31.11%)</td>
<td>809/1038(77.93%)</td>
<td>70/72/76(92.10%)</td>
</tr>
<tr>
<td>libpcap(1.11.0)</td>
<td>187/8950(2.89%)</td>
<td>3129/7870(39.76%)</td>
<td>76/83/84(90.47%)</td>
</tr>
<tr>
<td>- agentfuzz</td>
<td>48/167(28.74%)</td>
<td>2684/6476(41.44%)</td>
<td>134/302/317(44.86%)</td>
</tr>
<tr>
<td>libxml2(2.9.4)</td>
<td>15/8770(0.17%)</td>
<td>935/71378(1.31%)</td>
<td>150/1109/1594(9.41%)</td>
</tr>
<tr>
<td>- agentfuzz</td>
<td>77/142(54.22%)</td>
<td>4925/40018(12.30%)</td>
<td>213/755/1683(12.65%)</td>
</tr>
</tbody>
</table>
<p>최초 시동 이후 3개 프로젝트에 관하여 10$ Budget 내에서 구동을 시도하였다. 실제로 TP Rate는 높게 나왔으나, 시도 횟수는 Tool Call 빈도에 비례하여 줄어들었다. 또한 구현상의 차이로 집계된 API의 수와 Branch의 수가 다소 차이가 나기도 한다. 이에 표에는 모수를 병기한다.</p>
<p>cJSON은 모수가 온전히 동일함에도 4% 정도의 Branch Coverage 하락을 보였다. libpcap 또한 Cover 된 Branch의 수가 줄었으나, libxml2에서는 확연한 개선을 보였다. Executed API와 Branch Cov 모두 월등히 증가하였다.</p>
<p>최초 목표와 같이 상향 평준화의 논의에서 유의하다.</p>
<p><strong>Trials</strong></p>
<p>TBD; saturation, validation failures, response study, prompt engineering (ref:24.10.14.)</p>
<p>TBD; harness vs unit test, repetition (24.10.21.)</p>
<p>TBD; pre-validation, reducing contexts (24.10.28.)</p>
<p><strong>Conclusion</strong></p>
<p>TBD;</p>
<p><strong>Future works</strong></p>
<p>TBD;</p>

        </div>

        
        
      </div>
    </div>
  </div>
</section>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-12 text-center mb-5">
      </div>
      <div class="col-lg-3 col-sm-6 mb-5">
        <h6 class="mb-4">Contact Me</h6>
        <ul class="list-unstyled">
          <li class="mb-3"><a class="text-dark" href="tel:"><i
                class="ti-mobile mr-3 text-primary"></i></a></li>
          <li class="mb-3"><i class="ti-location-pin mr-3 text-primary"></i>Seoul, Korea</li>
          <li class="mb-3"><a class="text-dark" href="mailto:revsic99@gmail.com"><i
                class="ti-email mr-3 text-primary"></i>revsic99@gmail.com</a>
          </li>
        </ul>
      </div>
      <div class="col-lg-3 col-sm-6 mb-5">
        <h6 class="mb-4">Social Contacts</h6>
        <ul class="list-unstyled">
          
          <li class="mb-3"><a class="text-dark" href="https://www.facebook.com/profile.php?id=100009484787654">facebook</a></li>
          
          <li class="mb-3"><a class="text-dark" href="https://github.com/revsic">github</a></li>
          
          <li class="mb-3"><a class="text-dark" href="https://www.linkedin.com/in/young-joong-kim-878630154/">linkedin</a></li>
          
        </ul>
      </div>
      <div class="col-lg-3 col-sm-6 mb-5">
        <h6 class="mb-4">Categories</h6>
        <ul class="list-unstyled">
          <li class="mb-3"><a class="text-dark"
              href="/categories/attention">Attention</a>
          </li>
          <li class="mb-3"><a class="text-dark"
              href="/categories/bayesian">Bayesian</a>
          </li>
          <li class="mb-3"><a class="text-dark"
              href="/categories/generative">Generative</a>
          </li>
          <li class="mb-3"><a class="text-dark"
              href="/categories/portfolio">Portfolio</a>
          </li>
          <li class="mb-3"><a class="text-dark"
              href="/categories/software-testing">Software testing</a>
          </li>
          <li class="mb-3"><a class="text-dark"
              href="/categories/vocoder">Vocoder</a>
          </li>
          <li class="mb-3"><a class="text-dark"
              href="/categories/writing">Writing</a>
          </li>
        </ul>
      </div>
      <div class="col-lg-3 col-sm-6 mb-5">
        <h6 class="mb-4">Quick Links</h6>
        <ul class="list-unstyled">
          
          <li class="mb-3"><a class="text-dark" href="/about">About</a></li>
          
          <li class="mb-3"><a class="text-dark" href="/blog">Post</a></li>
          
        </ul>
      </div>
      <div class="col-12 border-top py-4 text-center">
        | copyright © 2020 <a href="https://revsic.github.io">YoungJoong Kim</a> All Rights Reserved |
      </div>
    </div>
  </div>
</footer>

<script>
  var indexURL = "/index.json"
</script>

<!-- JS Plugins -->

<script src="/plugins/jQuery/jquery.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/venobox/venobox.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/search/search.js"></script>

<!-- Main Script -->

<script src="/js/script.min.js"></script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']],
    }
  }
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@4.0.0-beta.4/tex-mml-chtml.js"></script>
</body>
</html>